---
title: 二叉树总结 #文章页面上的显示名称，可以任意修改，不会出现在URL中
date: 2020-08-25 20:15:30 #文章生成时间，一般不改，当然也可以任意修改
categories: 算法 #分类
tags: 算法 #文章标签，可空，多标签请用格式，注意:后面有个空格
---
## 二叉树的常见形式
### 1. 对象数组。
```js 
function TreeNode(value,left,right){
    this.left = left;
    this.right = right;
    this.value = value;
}
```

## 二叉树的遍历方式
1. 先序(根)遍历。Preorder Traversal (VLR)
2. 中序(根)遍历。
3. 后序(根)遍历。
4. 按层遍历

### 先序遍历
根-左-右

#### 递归实现：
```js
function preorderTraversal(root){
    let result = [];

    var preorderTraversalNode = function(node){ // 定义一个函数，用来递归向result数组中添加先序遍历的结果。
        if(node){ // 如果当前节点存在值，则将当前节点加入至结果数组，并且遍历其左右子树。
            result.push(node.value);
            preorderTraversalNode(node.left);
            preorderTraversalNode(node.right);
        }
    };
    preorderTraversalNode(root);

    return result;
} 
```

#### 迭代实现
* 广度优先遍历
* 维护一个可走路径的栈。

```js
function preorderTraversal(root){
    var stack = [],
        result = [];

    if(root) stack.push(root); // 将根节点入栈
    while(stack.length > 0){
        let curNode = stack.pop();  // 取出当前遍历的节点
        list.push(curNode.value);   // 将当前节点值放入结果数组。
        if(curNode.right){          
            stack.push(curNode.right);  // 如果右子树存在，则将右子树入栈。
        }
        if(curNode.left){
            stack.push(curNode.left);   // 如果左子树存在，则将左子树入栈。
        }
    }
    
    return result;
}

```
### 中序遍历
左-根-右

#### 递归实现：
```js
function inorderTraversal(root){
    let result = [];

    var preorderTraversalNode = function(node){
        if(node){
            preorderTraversalNode(node.left);
            result.push(node.value);
            preorderTraversalNode(node.right);
        }
    }
    preorderTraversalNode(root);

    return result; 
}
```

#### 迭代实现
整体思路：
* 深度优先遍历，仍然需要一个栈来存储路径。
* 走过的路径入栈，遇到无路可走时出栈，不断地尝试，直到栈为空（循环，出口为栈为空）。
* 不急于走（不先将当前节点入栈），先试探（尝试）当前节点是否能走，如果能走则走当前节点（入栈），然后根据优先级判断下面可以走的节点，然后继续试探（进入下个循环）。

```js
function inorderTraversal(root){
    let result = [],
        stack = [],
        curNode = null;

    // 取当前节点为根节点。
    if(root) {
        curNode = root;
    }
    while(stack.length || curNode){
        if(curNode){ // 如果当前节点可以走，则加入路径（入栈）。
            stack.push(curNode);
            curNode = curNode.left; // 下一步往左走。
        }else{
            curNode = stack.pop();
            result.push(curNode.value);
            curNode = curNode.right; // 下一个节点为当前节点的右子树。
        }
    }

    return result; 
}
```

### 后序遍历
左-右-根

#### 递归实现
```js
function postorderTraversal(root){
    let result = [];
    var postorderTraversalNode = function(node){
        if(node){
            postorderTraversalNode(node.left);
            postorderTraversalNode(node.right);
            result.push(node.value);
        }
    }
    postorderTraversalNode(root);
    return result;
}
```

#### 迭代实现
将原序列从反顺序遍历。根节点在结果数组中一定晚于左子树和右子树节点出现，且右子树一定晚于左子树出现。

```js
function postorderTraversal(root){
    let result = [],
        stack = [];

    if(root){
        stack.push(root);
    }
    while(stack.length){
        let node = stack.pop();
        node.left && stack.push(node.left);
        node.right && stack.push(node.right);
        result.unshift(node.value);
    }

    return result;
}
```


### 按层遍历
从上到下，从左到右，依次遍历。

```js
function levelTraversal(root){
    let result = [],
        queue = [];

    if(root) queue.push(root);
    while(queue.length){
        let node = queue.shift();
        result.push(node.value);
        node.left && queue.push(node.left);
        node.right && queue.push(node.right);
    }

    return result;
}
```

#### [LeetCode102：二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

```
二叉树：[3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7

返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]

```

题解：
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    let result = [],
        pathQueue = [],
        depthQueue = [];

    if(root){
        pathQueue.push(root);
        depthQueue.push(0);
    } 
    while(pathQueue.length){
        let node = pathQueue.shift(),
            depth = depthQueue.shift();
        
        if(!result[depth]){
            result[depth] = [];
        }
        result[depth].push(node.val);
        
        if(node.left){
            pathQueue.push(node.left);
            depthQueue.push(depth + 1);
        }
        if(node.right){
            pathQueue.push(node.right);
            depthQueue.push(depth+1);
        }
    }
    return result;
};
```