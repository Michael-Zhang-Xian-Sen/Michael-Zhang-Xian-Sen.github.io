---
title:  js出现舍入误差的原因及应对方案 #文章页面上的显示名称，可以任意修改，不会出现在URL中
date: 2020-08-25 10:34:30 #文章生成时间，一般不改，当然也可以任意修改
categories: 前端 #分类
tags: [前端]  #文章标签，可空，多标签请用格式，注意:后面有个空格
---

### 舍入误差
Number类型使用IEEE 754 双精度 64 位浮点数格式来表示整数和浮点值。
* 符号位，第63位（共1位），用来区分正负数。
* 指数，第52-62位（共11位），即2的指数。
* 第0到51是尾数位（共52位）。
因此，2^(-53)到2^53之间的整数都可以精确表示，但是对于计算机而言，两个数字在相加时是以二进制形式进行的，在呈现结果时才转换成十进制，所以浮点数不一定能精确表示。

#### 十进制小数转二进制小数
用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，此时0或1为二进制的最后一位。或者达到所要求的精度为止。

```
如：0.1 =（0.0 0011 0011 0011...(0011无限循环下去)）B
0.1*2=0.2========取出整数部分0
0.2*2=0.4========取出整数部分0
0.4*2=0.8========取出整数部分0
0.8*2=1.6========取出整数部分1
0.6*2=1.2========取出整数部分1
0.2*2=0.4========取出整数部分0
0.4*2=0.8========取出整数部分0
0.8*2=1.6========取出整数部分1
0.6*2=1.2========取出整数部分1
0.2*2=0.4========取出整数部分0
```

0.1和0.2的表示如下所示：
* 0.1：e = -4; m =1.1001100110011001100110011001100110011001100110011010 (52位)
* 0.2：e = -3; m =1.1001100110011001100110011001100110011001100110011010 (52位)

#### 二进制的舍入规则
舍入的目标即尽可能使舍入后的结果与真实值误差最小（尽可能减小舍入处理的影响）。如果以形式1.RR..RDD..D表示浮点数（R表示有效位，或保留位，而D表示舍去位），舍入规则就是：
* 如果DD..D < 10..0，则向下舍入。如：`1.001011`，保留四位有效数字，由于舍去位`011 < 100`，故保留位最后一位不进位，结果为：`1.001`。
* 如果DD..D > 10..0，则向上舍入。如：`1.001101`，保留四位有效数字，由于舍去位`101 > 100`，故保留位最后一位进位1，结果为：`1.010`。
* 如要DD..D = 10..0，则向最近偶数舍入，细则如下 ：
    * 如果RR..R = XX..0 （最低有效位是0），则向下舍入。如：`1.100100`，保留四位有效数字，由于最低有效位是0，故不进位，结果为：`1.100`。
    * 如果RR..R = XX..1（最低有效位是1），则向上舍入。如：`1.001100`，保留四位有效数字，由于最低有效位是1，故进位1，结果为：`1.010`。

#### 0.1 + 0.2 !== 0.3
0.1与0.2二进制相加，步骤如下：
1. 对齐二进制位。由于0.1与0.2的指数不一致，需要对齐。
    * 0.1：e = -3; m = 0.1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101
    + 0.2：e = -3; m = 1.1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010
2. 对应位数相加
    * 相加后得到的结果：e = -3; m = 10.0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0111
3. 超出的精度需要舍入。由于最后的舍去位是`1`，且最低有效位是`1`，故向上舍入，保留位最后一位进1.
    * 最终结果：e = -2; m = 1.0011001100110011001100110011001100110011001100110100(52位)
    * 最终结果的二进制形式：0.010011001100110011001100110011001100110011001100110100
    * 最终结果的十进制形式：0.30000000000000004

解决js中（或者说遵循IEEE 754规范）的语言中，两浮点数相加结果不正确的问题，可以设置一个误差范围值，即“机器精度”。对于Javascript来说，这个值通常是2^-52。

ES6中新增属性`Number.EMPSILON`，表示 1 与Number可表示的大于 1 的最小的浮点数之间的差值。可以使用`Number.EMPSILON`作为机器精度。

一个用于判断两数是否相等，并且消除了浮点数相加时舍入误差带来的影响：
```js
function isEqual(a, b){
    return Math.abs(a-b) < Number.EPSILON;
}
```

### 参考资料
1. 深入探讨浮点数舍入问题：https://blog.csdn.net/qq_42372980/article/details/80554247?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight
2. Javascript中的Number类型和BigInt类型：https://blog.csdn.net/RaeZhang/article/details/107624193
3. MDN中有关Number.EPSILON的介绍：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON