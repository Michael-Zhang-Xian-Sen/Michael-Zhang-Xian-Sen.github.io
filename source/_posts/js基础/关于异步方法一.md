---
title: 关于异步方法（一）：使用Promise #文章页面上的显示名称，可以任意修改，不会出现在URL中
date: 2020-03-05 10:05:50 #文章生成时间，一般不改，当然也可以任意修改
categories: 前端 #分类
tags: [js异步] #文章标签，可空，多标签请用格式，注意:后面有个空格
description: js异步
---

## 1. 时刻牢记：ajax请求是异步的。
比如：A方法调用ajax请求,B方法调用A方法，同时B方法调用C方法进行一些涉及到ajax返回的数据的处理工作（因某些原因该工作不能放到ajax请求的回调函数中，比如需要用到另一个ajax请求的内容）。

伪代码如下，用axios替代ajax请求：
```
// 这段代码的目的：通过B函数，成功为经过ajax请求获取到的id设置name。

// 全局变量
var data = []   // 我们最终要设置的变量
var mapRelation = [{userId:123,userName:1234}]  // 注意：这是通过另外一个ajax请求获得的。所以处理函数C不能或者说不方便放到A方法中。

// 该方法通过异步请求，获取Id。
function A(){
    return axios(请求参数).then(res=>{
        // 对请求所返回内容的处理工作
        // 假如res为{userId:123};
        data.push(res); 
    }).catch(err=>console.log(err))
}


// 该方法通过对象data的userId，为data设置userName。
function C(data){
    mapRelation.map(userItem=>{
        if(userItem.userId === data.userId){
            data.userName = userItem.uesrName;
        }
    })
}

// 设计B函数，为经过ajax请求获取到的id设置name。
// 错误的写法。
function bWrong(){
    // 这里并不会成功地为后台传来的userId找到usernName。
    // 因为A中axios请求的回调函数和函数C()是并行的关系。
    A();
    C();
}

// 正确的写法
function bCorrect(){
    // 由于axios().then()返回的是一个promise对象（），该对象又被A函数返回，于是可以通过.then()的方式进行串行处理请求。
    A().then(()=>{
        C();
    })
}
```

#### 补充：
1. Promise.then()的语法如下。其中`[]`中的内容代表可选内容。`Promise.then(onFulfilled[,onRejected])。`
2. then()返回一个 Promise 对象。(关于Promise.then()的更多内容[mdn](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then))
3. catch()返回一个 Promise 对象。(关于Promise.catch()的更多内容[mdn](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch))
2. Promise定义于ES6.

## 2. 在多个异步请求执行完毕后，执行一段代码——Promise.all()
在写项目的时候经常会遇到，需要得到两个ajax请求的结果后，才能进行数据处理的场景。此时用Promise.all()便能将两个异步请求与数据处理方法进行串行化。

一般的写法是：
```
Promise.all([方法1，方法2]).then(res=>{
    需要串行执行的方法
})
```

#### 补充：
1. Promise.all(iterable)方法，返回一个Promise实例。如果iterable参数的所有方法执行成功，则返回的Promise实例中的参数为iterable执行成功后的返回值。否则返回没有成功执行的原因。

## 3. 不得不说：Promise真的是个好东西。
1. 解决了异步请求进行同步执行的问题。
2. 解决了回调地狱的问题，链式调用简介又直观还好写。

### Promise对象的状态
* pendding，指异步操作正在进行中。
* fulfilled，指异步操作成功完成。
* rejected，指异步操作执行失败。

#### 补充：Promise相关的方法
1. `Promise.resolve()`：个人理解是Prmoise的一个状态，指问题成功解决、代码成功运行,设置Promise处于fulfilled状态。
2. `Promise.reject()`：问题解决失败或代码运行失败。
3. `Promise.then(succes,failed)`：在then中加入Promise状态为fulfilled或者reject的回调函数，链式执行。
4. `Promise.catch(failed)`：仅在Promise状态为reject或者抛出异常时运行catch中的函数。
5. `Promise.finally()`：仅在Promise结束时运行，无论结果是reject还是fulfilled。
6. `Promise.all(iterator)`：执行iterator中的所有方法，方法之间是且的关系。如果全部方法的执行结果全部为fulfilled或未返回Promise的情况，回调fulfilled，否则回调reject。
7.  `Promise.race(iterator)`：执行iterator中的方法，方法之间可以理解为或的关系。回调的是最早执行的函数的状态，如果最早的函数执行结果是fulfilled，则回调fulfilled，否则回调reject。如果迭代内容iterator是空，则永远等待。
8. `Promise.allSettled(iterator)`将iterator包装成一个Prmoise实例，再执行iterator中的方法，所有方法都完成后才返回结果，返回结果是包含iterator执行结果的数组，且返回时Promise的状态一定是fulfilled。返回结果的数组中，每一项都有status属性，对应着Prmoise的执行结果，值为`'fulfilled'`或`'rejected'`。该方法由ES2020引入。
9. `Promise.any(iterator)`执行iterator中的方法。如果iterator中某个方法返回的Promise状态为fulfilled，则函数回调fulfilled，否则当所有方法都返回rejected时，才回调rejected方法。该方法当前处于第三阶段提案。
10. `Promise.try()`现在仍然属于提案，可以捕获Promise执行函数中的所有同步和异步错误。与`Promise.catch()`相呼应。


## 参考资料
* 使用Promise。From mdn：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises
* Promise对象：From mdn：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise
* Promise对象：From 阮一峰：https://es6.ruanyifeng.com/#docs/promise#Promise-reject