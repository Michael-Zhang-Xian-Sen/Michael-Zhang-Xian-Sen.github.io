---
title: 关于异步（二）：async function #文章页面上的显示名称，可以任意修改，不会出现在URL中
date: 2020-03-10 15:09:00 #文章生成时间，一般不改，当然也可以任意修改
categories: 前端 #分类
tags: [js异步] #文章标签，可空，多标签请用格式，注意:后面有个空格
description: js异步
---

只需要两个关键字：async、await，辅助Promise的一些方法，即可优雅地将异步请求进行串行处理。

本文主要展示async的用法。顺带将async与Promise进行比较，同时指出了setTimeout函数的一些注意事项。

<!-- more-->

## async和await
### 使用async和await将异步请求串行传里的方法
1. 首先要将包含异步操作的函数，声明为异步函数
2. 在异步方法前加await关键字。

### async关键字
1. async关键字的功能：声明异步函数。

### await关键字
1. await关键字的功能：暂停异步函数的执行，等接收到Promise的执行结果后，再继续异步函数的执行。
2. await关键字的返回值：返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。
2. await关键字的使用条件：必须在async function中才能使用。


### 用法示例
```javascript
    async function(){
        console.log("准备执行异步方法...");
        var returnVal = await asyncFunction();  // asyncFunciton 是一个包含异步方法的函数，如包含ajax通信或setTimeout的函数
        console.log("异步方法执行完毕！")
    }
```

## 具体示例1：串行执行异步方法

只言片语可能无法很好理解，下面是一个小的示例，比较了promise的链式语法和async function的区别。

我们期望在两秒后，对value变量设置一个值，并打印其结果。但是在实现上有些条件。
1. 需要在一个方法中调用setTimeout。
2. 在另一个方法中调用这个方法，并设置变量的值。

是不是像极了平时写项目时，在一个方法中发起ajax请求，再另一个方法中调用这个请求，并接收请求返回的内容，对内容进行下一步的处理？

### 第一种写法：一种错误的示例
不使用Promise、不使用async function，博主在什么都不懂时便写过类似的代码，但这种写法肯定不行，无法满足要求。
```
function setValueAfter2Seconds(){
    return setTimeout(()=>{
        console.log("setTimeout 执行完毕")
        return "new value"
    },2000)
}

function test(){
    var value = "old value";
    console.log("准备调用");
    value = setValueAfter2Seconds()
    console.log("结束调用，准备打印值");
    console.log(value);
}
```

错误原因：
1. 注意，setTimeout回调函数的返回值和setTimeout的返回值没有任何关系！没有任何关系！没有任何关系！所以通过在setTimeout函数中进行return没有任何作用！setTimeout的返回值是一个唯一的id，用于传入给`clearTimeout`后可取消该定时器。
2. setTimeout方法和其他语句是异步执行的，具体原因需要了解js中的并发模型与事件循环的机制。我们只消知道setTimeout是个异步的方法即可。

### 第二种写法：Promise的写法
使用Promise链式语法的方案如下所示：
```javascript
function setValueAfter2Seconds(){
    return new Promise((resolve)=>{
        console.log(`setTimeout 准备执行`)
        setTimeout(()=>{
            console.log(`setTimeout 执行结束`)
            resolve(`new value`);
        },2000)
    })
}

function test(){
    var value = "old value";

    console.log("Promise执行函数 准备执行");
    setValueAfter2Seconds().then(res=>{
        console.log("Promise执行函数 执行结束");
        value = res;
        console.log(value);
    });
    console.log("Promise链外部的内容仍然会先于setTimeout执行");
}
```
下面对代码进行分析
1. 在`setValueAfter2Seconds()`中，返回了一个Promise对象。该对象的参数为一个函数，叫做“执行函数”。执行函数接受的第一个参数resolve，是Promise的一个方法。当执行函数中的所有内容顺利完成时，将调用resolve函数，否则会调用reject函数（此处未添加，reject是执行器函数的第二个参数）。
2. 在`test()`中，运行了`setValueAfter2Seconds()`后，执行Promise对象的then方法（`then()`即Promise的执行函数顺利完成后执行的方法），`then()`接收的参数为一个函数，被称作“处理方法（handlers）”。所有期望在`setValueAfter2Seconds()`方法执行完毕后，继续执行的代码需要写到“处理方法(handlers)”中。"处理方法"之外的语句，与Promise链中的语句仍然是异步执行（这点注意，这是Promise与async不同的最大表现之一）。

### 第三种写法：使用async
```javascript
async function setValueAfter2Seconds(){
    return new Promise((resolve)=>{
        console.log(`setTimeout 准备执行`)
        setTimeout(()=>{
            console.log(`setTimeout 执行结束`)
            resolve(`new value`);
        },2000)
    })
}

async function test(){
    var value = "old value";

    console.log("Prmomise执行函数准备执行");
    value = await setValueAfter2Seconds();
    console.log("Promise执行函数 执行结束");
    console.log(value);
}
```
下面对代码进行分析：
1. 使用`async`关键字声明`test()`是一个异步函数。
2. 使用`await`关键字暂停异步函数的执行，等待Promise执行函数运行完毕，接收Promise对象的处理结果，即resolve函数的参数`new value`，并赋值给value变量，然后执行后续的代码。

### 具体示例2：并行执行异步方法

### Promise写法
```javascript
var asyncFunction1 = function() {
    console.log("异步方法1 准备执行 等待时间设置为1秒");
    return new Promise(resolve => {
        setTimeout(function() {
            resolve("异步方法1");
            console.log("异步方法1 执行完毕");
        }, 1000);
    });
};

var asyncFunction2 = function() {
    console.log("异步方法2 准备执行 等待时间设置为2秒");
    return new Promise(resolve => {
        setTimeout(function() {
            resolve("异步方法2");
            console.log("异步方法2 执行完毕");
        }, 2000);
    });
};


var concurrentPromise = function() {
    console.log("开始并行执行异步方法");

    Promise.all([asyncFunction1(), asyncFunction2()]).then((messages) => {
        console.log(messages[0]);
        console.log(messages[1]);
    });
    console.log("Promise.all外部的内容仍然会先于setTimeout执行");
}
```

### async写法1：使用Promise.all，所有异步方法执行完毕后执行后续内容。
```javascript
var asyncFunction1 = function() {
    console.log("异步方法1 准备执行 等待时间设置为1秒");
    return new Promise(resolve => {
        setTimeout(function() {
            resolve("异步方法1");
            console.log("异步方法1 执行完毕");
        }, 1000);
    });
};

var asyncFunction2 = function() {
    console.log("异步方法2 准备执行 等待时间设置为2秒");
    return new Promise(resolve => {
        setTimeout(function() {
            resolve("异步方法2");
            console.log("异步方法2 执行完毕");
        }, 2000);
    });
};


var concurrentAsync1 = async function() {
    console.log("开始并行执行异步方法");

    await Promise.all([asyncFunction1(), asyncFunction2()]).then((messages) => {
        console.log(messages[0]);
        console.log(messages[1]);
    });
    console.log("Promise.all外部的内容与Promise.all顺序执行");
}
```

### async写法2：异步方法同时执行，其他内容串行执行，遇到await时阻塞。
```javascript
var asyncFunction1 = function() {
    console.log("异步方法1 准备执行 等待时间设置为1秒");
    return new Promise(resolve => {
        setTimeout(function() {
            resolve("异步方法1");
            console.log("异步方法1 执行完毕");
        }, 1000);
    });
};

var asyncFunction2 = function() {
    console.log("异步方法2 准备执行 等待时间设置为2秒");
    return new Promise(resolve => {
        setTimeout(function() {
            resolve("异步方法2");
            console.log("异步方法2 执行完毕");
        }, 2000);
    });
};


var concurrentAsync2 = async function() {
    var message = [0,0];
    console.log("开始并行执行异步方法");
    
    message[0] = asyncFunction1();
    message[1] = asyncFunction2();

    console.log(await message[0]);
    console.log(await message[1]);
    console.log("async1Funvtion1、asyncFunction2的并行执行，其他内容串行执行");
}
```


## async await和Promise链式写法的区别
1. async写法避免了Promise的链式写法。
2. 结合使用async和Promise能发挥更大的作用。