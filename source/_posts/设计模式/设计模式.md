---
title: 23种设计模式概览 #文章页面上的显示名称，可以任意修改，不会出现在URL中

date: 2019-12-02 11:35:30 #文章生成时间，一般不改，当然也可以任意修改

categories: 软件设计 #分类

tags: 软件设计 #文章标签，可空，多标签请用格式，注意:后面有个空格

description: 23种设计模式，包括设计模式的UML图、定义、优缺点及java代码实现

thumbnail: http://cdn.ewinds.pw/kungfu.jpeg
---

23种设计模式，包括设计模式的UML图、定义、优缺点及java代码实现。

代码详见github：https://github.com/Michael-Zhang-Xian-Sen/design-pattern

<!-- more -->

# 目录
1. 创建型模式
    1. 抽象工厂模式（Abstract Factory Pattern）
    2. 工厂方法模式（Factory Method Pattern）
    3. 简单工厂（Simple Factory Pattern）（注：不属于设计模式。）
    4. 原型模式（Prototype Pattern）
    5. 单例模式（Singleton Pattern）
    6. 建造者模式（Builder Pattern）（又名：生成器模式）
2. 行为型模式
    1. 观察者模式（Observer Pattern）
    2. 模版方法模式（Template Pattern）
    3. 命令模式（Command Pattern）
    4. 状态模式（State Pattern）
    5. 职责链模式（Chain of Responsibility）
    6. 解释器模式（Interpreter Pattern）
    7. 中介者模式（Mediator Pattern）（又名：调停者模式）
    8. 访问者模式（Visitor Pattern）
    9. 策略模式（Strategy Pattern）
    10. 备忘录模式（Memento Pattern）
    11. 迭代器模式（Iterator Pattern）
3. 结构型模式
    1. 适配器模式（Adapter Pattern）
    2. 桥接模式（Bridge Pattern）
    3. 组合模式（Composite Pattern）
    4. 装饰模式（Decorator Pattern）
    5. 外观模式（Facade Pattern）
    6. 享元模式（Flyweight Pattern）
    7. 代理模式（Proxy Pattern）

## 1. 创建型模式

### 1.1. 抽象工厂模式
#### UML图：
![image](http://cdn.ewinds.pw/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.jpg)

#### 定义
抽象工厂模式（AbstractFactory）提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

#### 优点
1. 抽象工厂的工厂最为强大。
2. 易于交换产品系列。由于具体工厂类在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，只需改变具体工厂的内容便可改变不同的产品配置。符合里氏替换原则。
3. 抽象工厂使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中。
4. 该模式帮助我们针对抽象编程，而不是针对具体编程。
5. 通过减少程序和具体类之间的依赖，促进松耦合。

#### 缺点
添加产品族很简单，只需要对每个接口添加一个类，符合开闭原则；但是添加产品比较麻烦，如果新添加了产品C，那么所有工厂都要添加产品C，违反了开闭原则。

### 1.2. 工厂方法模式
#### UML图
![image](http://cdn.ewinds.pw/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.jpg)

#### 定义
定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。（即：工厂方法把简单工厂的逻辑判断移动到了客户端）

#### 优点
符合开闭原则。

#### 缺点
增加新的产品时，需要增加新的工厂类和产品类，会带来更大的开销。
抽象层的加入使得理解难度增大。


### 1.3 简单工厂
#### UML图
![image](http://cdn.ewinds.pw/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.jpg)

#### 定义
将创建对象的代码进行封装。

#### 优点
* 根据客户端的条件，动态实例化相关的类。对于客户端来说，去除了与具体产品的依赖。

#### 缺点
* 由于若要添加逻辑，需要修改工厂类，违背了开闭原则

### 1.4 原型模式
#### UML图
![image](http://cdn.ewinds.pw/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
用原型实例制定创建对象的种类，并且通过拷贝原型这些原型创建新的对象。
感觉重点就在于实现了clone方法。

#### 浅拷贝

被复制的对象的所有变量都含有与原来对象相同的值。故所有的对其他对象的引用都仍然指向原来的对象。

#### 深拷贝

在浅拷贝的基础上，将引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。

#### 优点
1. 向客户隐藏制造新实例的复杂性。
2. 提供让客户能够产生未知类型对象的选项。
3. 在某些环境下，复制对象比创建新对象更有效。

#### 缺点
1. 对象的复制有时相当复杂。

#### 用途
1. 在一个复杂的类层次中，当系统必须从其中的许多类型创建新对象时，可以考虑原型。

### 1.5 单例模式
#### UML图
![image](http://cdn.ewinds.pw/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
保证一个类仅有一个实例，并提供一个访问它的全局访问点。

#### 补充
* 通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。

#### 饿汉式单例类
在类被加载时便将自己实例化。

#### 懒汉式单例类
在第一次被引用时将自己实例化。

#### 注意
* 多线程的单例，需要加锁，避免同时创建多个实例。

#### 优点
* 可以使用单例模式替换全局变量。

#### 缺点
* 单例模式引入了许多的其他问题，比如在创建单例对象的时候需要加锁。

### 1.6 建造者模式（生成器模式）
#### UML图
![image](http://cdn.ewinds.pw/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

#### 优点
1. 将一个复杂对象的创建过程封装起来
2. 允许对象通过多个步骤来创建，并且可以改变过程。（这和只有一个步骤的工厂模式不同）
3. 向客户隐藏产品内部的表现。
4. 产品的实现可以被替换，因为客户只看到一个抽象的接口。

#### 缺点
1. 与工厂模式相比，采用生成器模式创建对象需要具备更多的领域知识。

#### 用途
1. 经常被用来创建组合结构。


## 2. 行为型模式
### 2.1. 观察者模式（发布-订阅模式）
#### UML图：
![image](http://cdn.ewinds.pw/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

#### 优点
1. 让主题和观察者之间松耦合。它们之间依然可以交互，但是不太清楚彼此的细节，使互相的依赖降到了最低。

#### 缺点


### 2.2 模版方法模式
#### UML图
![image](http://cdn.ewinds.pw/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.jpg)

（注：父类是抽象类）
#### 定义
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

#### 优点
模板方法模式通过把不变的行为搬移到超类，去除子类中的重复代码来体现它的优势。即当不变的行为和可变的行为在子类中混杂在一起的时候，不变的行为会在子类中重复出现，通过模板方法模式把这些行为搬移到父类或其他的地方，可以帮助子类摆脱重复的不变行为的纠缠。

### 2.3 命令模式
#### UML图
![image](http://cdn.ewinds.pw/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

#### 优点
1. 能够容易地设计一个命令队列。
2. 在需要的情况下，可以容易地将命令记入日志。
3. 允许接受请求的一方决定是否要否决请求。
4. 可以容易地实现对请求的撤销和重做。
5. 由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。
6. 把请求一个操作的对象与知道怎么执行一个操作的对象分割开。

### 2.4 状态模式
#### UML图
![image](http://cdn.ewinds.pw/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了这个类。
主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况，把状态的判断逻辑转移到表示不同状态的一些列类当中，可以把复杂的判断逻辑简化。

#### 优点
将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。

### 2.5 职责链模式
#### UML图
![image](http://cdn.ewinds.pw/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象可以处理它为止。

#### 用途

经常被用在窗口系统中，处理鼠标和键盘之类的事件。

#### 优点

1. 可以随时添加或修改处理一个请求的结构。增强了给对象指派职责的灵活性。
2. 将请求的发送者和接收者解耦。（状态模式两个请求之间仍然存在耦合）
3. 可以简化Client对象，因为Client对象不需要知道链的结构。
4. 通过改变指责链内的成员或调动他们的次序，允许使用者动态地新增或删除责任。

#### 缺点
并不能保证请求一定被执行。
不容易观察运行时的特征，有碍于debug。

### 2.6 解释器模式

#### UML图
![image](http://cdn.ewinds.pw/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

#### 应用场景
如果一种特定类型的问题发生频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。

### 2.7 中介者模式（调停者模式）

#### UML图
![image](http://cdn.ewinds.pw/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
用一个中介对象来封装一系列的对象交互。中介者使各个对象之间不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

### 2.8 访问者模式

#### UML图
![image](http://cdn.ewinds.pw/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

### 2.9 策略模式

#### UML图
![image](http://cdn.ewinds.pw/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户。

### 2.10 备忘录模式

#### UML图
![image](http://cdn.ewinds.pw/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

### 2.11 迭代器模式

#### UML图
![image](http://cdn.ewinds.pw/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

该模式已经被多种语言所实现为

## 3. 结构型模式
### 3.1 适配器模式

#### UML图
![image](http://cdn.ewinds.pw/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

#### 优点

### 3.2 桥接模式

#### UML图
![image](http://cdn.ewinds.pw/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
Bridge，将抽象部分与它的实现部分分离，使他们都可以独立地变化。
* 补充理解1：实现的方式有多种。桥接模式的核心意图就是把这些实现独立出来，让它们各自地变化。这就使得每种实现的变化不会影响其他实现，从而达到应对变化的目的。
* 补充理解2：实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。

### 3.3 组合模式

#### UML图

##### 透明模式
![image](http://cdn.ewinds.pw/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%28%E9%80%8F%E6%98%8E%E6%A8%A1%E5%BC%8F%29.jpg)

##### 安全模式
![image](http://cdn.ewinds.pw/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%28%E5%AE%89%E5%85%A8%E6%96%B9%E5%BC%8F%29.jpg)

#### 定义
将对象组合成树形结构，以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
* 透明方式：Componet中声明所有用来管理子对象的方法。
* 安全方式：Componet接口中不声明管理子对象的方法，而是在Composite中声明所有用来管理子对象的方法。


### 3.4 装饰模式

#### UML图
![image](http://cdn.ewinds.pw/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。

### 3.5 外观模式

#### UML图
![image](http://cdn.ewinds.pw/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
* 外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

#### 优点
* 符合迪米特法则
* 符合依赖倒置原则

### 3.6 享元模式

#### UML图
![image](http://cdn.ewinds.pw/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
* Flyweight，运用共享技术有效地支持大量细粒度的对象。
* 享元对象的内部状态：不会随环境改变而改变的共享部分。
* 享元对象的外部状态：随环境改变而改变的、不可以共享的状态。 

#### 优点
节约存储空间。

#### 缺点
需要将部分状态外部化，使得逻辑更为复杂，

### 3.7 代理模式

#### UML图
![image](http://cdn.ewinds.pw/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg)

#### 定义
为其他对象提供一种代理以控制这个对象的访问。

#### 优点

#### 应用场景
* 远程代理
* 虚拟代理
* 安全代理
