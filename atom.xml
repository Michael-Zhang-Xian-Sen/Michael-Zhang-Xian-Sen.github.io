<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XD</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nice2meetu.site/"/>
  <updated>2020-09-24T15:59:52.620Z</updated>
  <id>http://nice2meetu.site/</id>
  
  <author>
    <name>Michael Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js数组去重</title>
    <link href="http://nice2meetu.site/2020/09/24/js%E5%9F%BA%E7%A1%80/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>http://nice2meetu.site/2020/09/24/js基础/js数组去重/</id>
    <published>2020-09-24T14:50:30.000Z</published>
    <updated>2020-09-24T15:59:52.620Z</updated>
    
    <content type="html"><![CDATA[<p>根据是否改变原数组可分为两类，然后根据是否使用ES6特性，再进行细分。</p><!-- TOC --><ol><li><a href="#不改变原数组">不改变原数组</a><ol><li><a href="#利用es6的set">利用ES6的Set</a></li><li><a href="#利用indexof额外数组">利用indexOf+额外数组</a></li><li><a href="#利用filterindexof">利用filter+indexOf</a></li></ol></li><li><a href="#改变原数组">改变原数组</a><ol><li><a href="#利用splice方法">利用splice方法</a></li></ol></li><li><a href="#其他注意内容">其他注意内容</a></li></ol><!-- /TOC --><h1 id="不改变原数组"><a href="#不改变原数组" class="headerlink" title="不改变原数组"></a>不改变原数组</h1><h2 id="利用ES6的Set"><a href="#利用ES6的Set" class="headerlink" title="利用ES6的Set"></a>利用ES6的Set</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：无法去掉<code>{}</code>空对象。</p><h2 id="利用indexOf-额外数组"><a href="#利用indexOf-额外数组" class="headerlink" title="利用indexOf+额外数组"></a>利用indexOf+额外数组</h2><p>借助额外的数组array。遍历原数组，如果该元素在array中不存在，则加入至array，否则跳过。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = [],</span><br><span class="line">        len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.indexOf(arr[i]) === <span class="number">-1</span>) array.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="利用filter-indexOf"><a href="#利用filter-indexOf" class="headerlink" title="利用filter+indexOf"></a>利用filter+indexOf</h2><p>利用filter方法遍历数组，使用indexOf判断元素是否重复，将重复的元素剔除。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">cur,idx,array</span>)=&gt;</span>array.indexOf(cur) === idx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="改变原数组"><a href="#改变原数组" class="headerlink" title="改变原数组"></a>改变原数组</h1><h2 id="利用splice方法"><a href="#利用splice方法" class="headerlink" title="利用splice方法"></a>利用splice方法</h2><p>遍历数组，使用indexOf判断元素是否重复，如果重复则利用splice从原数组中剔除该元素。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.indexOf(arr[i]) !== i)&#123;</span><br><span class="line">            arr.splice(i--,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="其他注意内容"><a href="#其他注意内容" class="headerlink" title="其他注意内容"></a>其他注意内容</h1><p>需要判断接收的参数是否为数组，若不为数组则提示”Type Error”并返回一个空数组。</p>]]></content>
    
    <summary type="html">
    
      你不知道的JavaScript的读书笔记
    
    </summary>
    
      <category term="js" scheme="http://nice2meetu.site/categories/js/"/>
    
    
      <category term="js" scheme="http://nice2meetu.site/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vsc的使用技巧及实用插件</title>
    <link href="http://nice2meetu.site/2020/09/03/IDE/vsc%E5%AE%9E%E7%94%A8%E7%9A%84%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%8F%92%E4%BB%B6/"/>
    <id>http://nice2meetu.site/2020/09/03/IDE/vsc实用的技巧与插件/</id>
    <published>2020-09-03T10:25:30.000Z</published>
    <updated>2020-09-24T16:00:04.209Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ol><li><a href="#实用插件">实用插件</a><ol><li><a href="#editorconfig">EditorConfig</a></li><li><a href="#markdown-toc">Markdown TOC</a></li></ol></li></ol><!-- /TOC --><h1 id="实用插件"><a href="#实用插件" class="headerlink" title="实用插件"></a>实用插件</h1><h2 id="EditorConfig"><a href="#EditorConfig" class="headerlink" title="EditorConfig"></a>EditorConfig</h2><p>用于统一项目的编码风格，如采用何种方式缩进。该插件的优先级高于编辑器默认的代码格式化规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* .editorconfig文件 */</span></span><br><span class="line">[*.&#123;js,jsx,ts,tsx,vue&#125;]</span><br><span class="line">root = <span class="literal">true</span></span><br><span class="line"># 缩进风格：空格</span><br><span class="line">indent_style = space</span><br><span class="line"># 缩进大小：4</span><br><span class="line">indent_size = <span class="number">4</span></span><br><span class="line"># 是否删除行尾的空格：true</span><br><span class="line">trim_trailing_whitespace = <span class="literal">true</span></span><br><span class="line"># 是否在文件的最后插入一个空行：true</span><br><span class="line">insert_final_newline = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="Markdown-TOC"><a href="#Markdown-TOC" class="headerlink" title="Markdown TOC"></a>Markdown TOC</h2><p>用于生成markdown的目录。本文的目录便是使用该插件生成。</p><p>该插件在vsc的插件市场中下载量极高，但是原作者不维护了，当前的可下载版本存在一些问题，大致如下：</p><ol><li>生成的目录没有换行，且出现大量<code>auto</code>。错误原因是当前vsc配置的EOL为<code>LF(\n)</code>，修改为<code>CRLF(\r\n)</code>即可。</li><li>生成的标题从0开始计数。原因是标题必须从<code>#</code>开始。个人感觉这条规定很不合理，有些场景根本不适合用那么大的标题，但是若想正常使用插件便必须按照他的规定来。</li></ol><p>默默吐槽一下。由于原作者已不再维护该插件，于是一些用户fork源码后自行维护，导致vsc插件市场上有三四个类似的插件，但是…仍然都有bug…直观感受是类似拆了东墙补西墙…而且很少有人讨论修改后冒出来的奇葩问题…算了就用原作者的吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#实用插件&quot;&gt;实用插件&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#editorconfig&quot;&gt;EditorConfig&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#markdown-toc&quot;&gt;Markdown TO
      
    
    </summary>
    
      <category term="vsc" scheme="http://nice2meetu.site/categories/vsc/"/>
    
    
      <category term="vsc" scheme="http://nice2meetu.site/tags/vsc/"/>
    
  </entry>
  
  <entry>
    <title>web安全：xss攻击</title>
    <link href="http://nice2meetu.site/2020/09/02/web%E5%AE%89%E5%85%A8/xss/"/>
    <id>http://nice2meetu.site/2020/09/02/web安全/xss/</id>
    <published>2020-09-02T13:35:30.000Z</published>
    <updated>2020-09-03T10:19:22.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xss（Cross-Site-Scripting）攻击"><a href="#xss（Cross-Site-Scripting）攻击" class="headerlink" title="xss（Cross-Site Scripting）攻击"></a>xss（Cross-Site Scripting）攻击</h1><p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</p><h3 id="不可信内容"><a href="#不可信内容" class="headerlink" title="不可信内容"></a>不可信内容</h3><ul><li>来自用户的 UGC（User Generated Content） 信息</li><li>来自第三方的链接</li><li>URL 参数</li><li>POST 参数</li><li>Referer （可能来自不可信的来源）</li><li>Cookie （可能来自其他子域注入）</li></ul><h3 id="XSS-注入的方法"><a href="#XSS-注入的方法" class="headerlink" title="XSS 注入的方法"></a>XSS 注入的方法</h3><ol><li>在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。</li><li>在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。</li><li>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。</li><li>在标签的 href、src 等属性中，包含 javascript: 等可执行代码。</li><li>在 onload、onerror、onclick 等事件中，注入不受控制代码。</li><li>在 style 属性和标签中，包含类似 background-image:url(“javascript:…”); 的代码（新版本浏览器已经可以防范）。</li><li>在 style 属性和标签中，包含类似 expression(…) 的 CSS 表达式代码（新版本浏览器已经可以防范）。</li><li>总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。</li></ol><h3 id="XSS攻击的两大要素："><a href="#XSS攻击的两大要素：" class="headerlink" title="XSS攻击的两大要素："></a>XSS攻击的两大要素：</h3><ol><li>攻击者提交恶意代码。</li><li>浏览器执行恶意代码。</li></ol><h3 id="前端应对方案："><a href="#前端应对方案：" class="headerlink" title="前端应对方案："></a>前端应对方案：</h3><ol><li>输入过滤。并不是终极方案，且不是特别好。</li><li>纯前端渲染。</li><li>避免将不可信的数据传递给以下能把字符串作为代码执行的api：<ol><li>DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等。</li><li><a> 标签的 href 属性。</a></li><li>JavaScript 的 eval()、setTimeout()、setInterval() 等</li></ol></li><li>严格进行CSP防范。</li><li>输入内容长度控制。</li><li>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</li><li>验证码：防止脚本冒充用户提交危险操作。</li><li>避免拼接 HTML。</li></ol><h3 id="如何减少xss漏洞"><a href="#如何减少xss漏洞" class="headerlink" title="如何减少xss漏洞"></a>如何减少xss漏洞</h3><ol><li>利用模板引擎。</li><li>避免内联事件。</li><li>避免拼接 HTML。</li><li>时刻保持警惕。</li><li>增加攻击难度，降低攻击后果。</li><li>主动检测和发现。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;xss（Cross-Site-Scripting）攻击&quot;&gt;&lt;a href=&quot;#xss（Cross-Site-Scripting）攻击&quot; class=&quot;headerlink&quot; title=&quot;xss（Cross-Site Scripting）攻击&quot;&gt;&lt;/a&gt;xss（C
      
    
    </summary>
    
      <category term="web安全" scheme="http://nice2meetu.site/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://nice2meetu.site/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>TCP三次握手与四次挥手</title>
    <link href="http://nice2meetu.site/2020/09/01/%E7%BD%91%E7%BB%9C/http/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%8A%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://nice2meetu.site/2020/09/01/网络/http/TCP三次握手及四次挥手/</id>
    <published>2020-09-01T02:11:00.000Z</published>
    <updated>2020-09-08T07:46:06.362Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p>为了对每次发送的数据量进行跟踪与协商，确保数据段的发送和接收同步，根据所接收到的数据量而确认数据发送、接收完毕后何时撤消联系，并建立虚连接。</p><p>第一次 客户端-&gt;服务端 SYN_SENT状态 syn,同时发送序号x<br>第二次 客户端&lt;-服务端 SYN_RECV状态 syn+ack包，返回确认号x+1，同时发送序号y<br>第三次 客户端-&gt;服务端 ESTABLISHED状态 syn+ack，返回确认号y+1。</p><h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><p>第一次 客户端-&gt;服务端 FIN=1,seq=u                   告诉服务端，我准备关闭连接了！此时客户端不向服务端发数据了，但是能收数据。<br>第二次 客户端&lt;-服务端 ACK=1,seq=v ack=u+1           哦，你要关连接啊，那我准备一下。<br>第三次 客户端&lt;-服务端 FIN=1,ACK=1,seq=w,ack=u+1     我准备好了，你关吧！停止向客户端发数据，但是能收数据<br>第四次 客户端-&gt;服务端 ACK=1,seq=u+1,ack=w+1         好的，我停止接收了，你停止接收吧，</p>]]></content>
    
    <summary type="html">
    
      TCP三次握手与四次挥手
    
    </summary>
    
      <category term="TCP" scheme="http://nice2meetu.site/categories/TCP/"/>
    
    
      <category term="TCP" scheme="http://nice2meetu.site/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>同源策略及跨域</title>
    <link href="http://nice2meetu.site/2020/08/31/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%8F%8A%E8%B7%A8%E5%9F%9F/"/>
    <id>http://nice2meetu.site/2020/08/31/浏览器/同源策略及跨域/</id>
    <published>2020-08-31T11:10:30.000Z</published>
    <updated>2020-09-02T05:38:13.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h1><ol><li>同源策略（Same origin policy），浏览器的一个安全策略，现代浏览器大部分都实现了该策略。<ol><li>同源指：域名、协议、端口相同。</li><li>禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。</li><li>禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。</li></ol></li><li>http协议的<code>Content-Type</code>字段：如果该字段在http request header（请求头）里，指“前端向后台传递的数据的类型”，后台框架可能会根据该字段，自动地对前端发来的内容进行解析；如果该字段在htttp response header(响应头)里，指“后台向前端传递的数据的类型”。</li></ol><p>如果要跨域就要解决两个关键问题，一个是浏览器不让你发请求（实质上是浏览器根据预检请求得到的结果，不让你发正式的请求），另一个是浏览器不让你收请求。</p><h1 id="如何绕开同源策略（如何跨域）？"><a href="#如何绕开同源策略（如何跨域）？" class="headerlink" title="如何绕开同源策略（如何跨域）？"></a>如何绕开同源策略（如何跨域）？</h1><h2 id="1-jsonp跨域"><a href="#1-jsonp跨域" class="headerlink" title="1. jsonp跨域"></a>1. jsonp跨域</h2><p>JSONP（JSON with Padding，带填充的json），是由Bob Ippolito在2005年提出的一种跨域手段。jsonp跨域的两个关键点，一个是<code>&lt;script&gt;</code>标签，另一个是回调函数。</p><p>jsonp利用<code>script</code>标签从前端向后台请求数据。前端获得响应后，会在该<code>script</code>标签内执行一个回调函数。</p><p>为什么是<code>&lt;script&gt;</code>标签呢？因为一些HTML标签是不受同源策略限制的，如<code>script</code>、<code>img</code>，因此使用这些标签可以发请求。</p><p>为什么不用<code>img</code>标签呢？因为实际场景，前端不仅要发、收请求，还要对请求的结果进行下一步的处理。script标签内的内容可以作为js代码被浏览器执行，因此script非常符合我们的需求。</p><p>jsonp的另一个关键点就是回调函数了。利用<code>&lt;script&gt;</code>发起请求，返回内容是由后台生成的，因此在<code>script</code>标签内执行的代码只能是后台响应的数据。<br>这样一来..是不是有点尴尬，“后台大哥，我前端只能执行你发的数据，要不我等会代码写好了拷贝一份发你吧！”，后台大哥：“滚！”….<br>我们当然不能这样做，也不一定可行（作用域问题）。我们应该好好利用一个东西：函数！函数能把我们的业务代码囊括进去，一行代码便能执行数十行代码，还能利用闭包解决作用域的问题，简直太棒了！所以我们仅需要把回调函数告诉后台，让后台以函数的调用形式作为请求的响应内容返回就好了！至此，利用jsonp跨域的理论基础便建立起来了。</p><p>所以，利用jsonp发起一个跨域请求的具体步骤大致如下：</p><ol><li>前端创建一个<code>script</code>标签，并设置该标签的<code>src</code>属性为我们期望请求api的url，设置<code>type</code>属性为”text/javascript”。</li><li>将该<code>script</code>标签添加至dom树。该标签加入dom树后，便会自动向<code>src</code>指定的url发送请求。</li><li>后台向前端响应的内容，应该是一段调用回调函数的代码，如：<code>前端回调函数名(参数)</code>。</li><li>在前端声明一个回调函数，该函数在请求成功响应后执行。（注意，大部分情况都是要将该函数挂到全局对象上哦，因为script标签内的作用域是全局作用域）</li></ol><p>jsonp跨域的一些缺点：</p><ol><li>仅支持<code>get</code>请求。</li></ol><h3 id="1-1-jsonp跨域的原生实现："><a href="#1-1-jsonp跨域的原生实现：" class="headerlink" title="1.1 jsonp跨域的原生实现："></a>1.1 jsonp跨域的原生实现：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* vue前端 */</span></span><br><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>), <span class="comment">// 创建一个script标签</span></span><br><span class="line">    jsonpCallbackName = <span class="string">"jsonpCallback"</span>, <span class="comment">// 消除魔法字符串，统一后续的jsonp回调函数名称。</span></span><br><span class="line">    context = <span class="keyword">this</span>; <span class="comment">// 记录当前的上下文。博主的这段代码实际是在vue中编写的，具体代码可见文末的demo。这条赋值语句可以忽略。</span></span><br><span class="line"></span><br><span class="line">script.type = <span class="string">"text/javascript"</span>; <span class="comment">// 使该标签请求获得的数据可以被浏览器执行。</span></span><br><span class="line">script.src = <span class="string">`http://localhost:3000/api/testGet?anything=<span class="subst">$&#123;<span class="keyword">this</span>.form.anything&#125;</span>&amp;callback=<span class="subst">$&#123;jsonpCallbackName&#125;</span>`</span>; <span class="comment">// 建议传一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数。</span></span><br><span class="line"><span class="built_in">document</span>.head.appendChild(script); <span class="comment">// 将该标签添加至dom树，加入dom树后该标签会触发向src的请求。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// script标签请求成功后的回调函数。</span></span><br><span class="line"><span class="built_in">window</span>[jsonpCallbackName] = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.head.removeChild(script);</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">window</span>[jsonpCallbackName];</span><br><span class="line">    context.returnMsg = res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* node后台 */</span></span><br><span class="line">router.get(<span class="string">'/testGet'</span>, (ctx) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`后台testGet接口被触发`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`接收到数据：<span class="subst">$&#123;ctx.request.query.anything&#125;</span>`</span>);</span><br><span class="line">    ctx.response.status = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 后台返回的内容必须为模拟执行回调函数的代码，即：回调函数名(参数)</span></span><br><span class="line">    ctx.body = <span class="string">`<span class="subst">$&#123;ctx.request.query.callback&#125;</span>(&#123;"status":"success"&#125;)`</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于实现过程中的一些细节的解释：</p><ol><li>为什么一定要给<code>script</code>标签设置<code>type</code>属性？<blockquote><p><code>type</code>属性定义script元素包含或src引用的脚本语言。属性的值为MIME类型; 支持的MIME类型包括text/javascript, text/ecmascript, application/javascript, 和application/ecmascript。如果没有定义这个属性，脚本会被视作JavaScript。如果MIME类型不是JavaScript类型（上述支持的类型），则该元素所包含的内容会被当作数据块而不会被浏览器执行。 <strong><em><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script" target="_blank" rel="noopener">(摘自mdn)</a></em></strong></p></blockquote></li><li>为什么要将回调函数挂载到window上？<ul><li>因为<code>script</code>标签内的代码的执行环境是全局作用域，如果不将回调函数挂载到window上，script标签内的代码访问不到该回调函数。</li></ul></li><li>为什么要在回调函数里删除该方法？<ul><li>为了避免内存泄漏。function也是会占用一定内存的。</li></ul></li></ol><p>可能会遇到的报错：</p><ol><li><blockquote><p>Cross-Origin Read Blocking (CORB) blocked cross-origin response <a href="http://localhost:3000/api/testGet?name=test&amp;callback=handleCallback" target="_blank" rel="noopener">http://localhost:3000/api/testGet?name=test&amp;callback=handleCallback</a> with MIME type application/json. See <a href="https://www.chromestatus.com/feature/5629709824032768" target="_blank" rel="noopener">https://www.chromestatus.com/feature/5629709824032768</a> for more details.</p></blockquote></li></ol><ul><li>出现原因：因为CORB策略（详见参考资料1）。后台返回的内容可能满足了CORB的保护规则，触发了CORB，因此前端无法获取到响应信息。</li><li>解决方案：博主是初学时不懂后台要返回一个方法的调用（如：<code>前端回调函数名(参数)</code>），而是返回了一段json数据才导致的这个错误。</li></ul><h3 id="1-2-jquery版本的jsonp跨域"><a href="#1-2-jquery版本的jsonp跨域" class="headerlink" title="1.2 jquery版本的jsonp跨域"></a>1.2 jquery版本的jsonp跨域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonpCallbackName = <span class="string">"jsonpCallback"</span>,</span><br><span class="line">    context = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>[jsonpCallbackName] = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">window</span>[jsonpCallbackName];</span><br><span class="line">    context.returnMsg = res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"http://localhost:3000/api/testGet"</span>,</span><br><span class="line">    type: <span class="string">"get"</span>,</span><br><span class="line">    dataType: <span class="string">"jsonp"</span>, <span class="comment">// 预期服务器返回的数据类型。当值为"jsonp"时，会在url中自动添加"callback=?"，其中?会被自动替换为jsonpCallback字段设置的函数名。</span></span><br><span class="line">    jsonpCallback: jsonpCallbackName, <span class="comment">// 回调函数的函数名。</span></span><br><span class="line">    data: &#123;</span><br><span class="line">        anything: <span class="keyword">this</span>.form.anything,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-iframe-form跨域"><a href="#2-iframe-form跨域" class="headerlink" title="2. iframe+form跨域"></a>2. iframe+form跨域</h2><p>由于form表单在提交时不会出现跨域问题，因此可以利用form表单进行跨域。<br>ifame标签，主要用来避免页面刷新的问题，收到响应数据后直接将表单的数据显示到iframe标签中。<br>但是该方法的局限性比较大，后台传递回来的数据只在<code>iframe</code>中渲染，在<code>iframe</code>的父页面中无法获取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前端 */</span></span><br><span class="line"><span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>), <span class="comment">// 首先创建一个用来发送数据的iframe.</span></span><br><span class="line">form = <span class="built_in">document</span>.createElement(<span class="string">"form"</span>),</span><br><span class="line">node = <span class="built_in">document</span>.createElement(<span class="string">"input"</span>),</span><br><span class="line">context = <span class="keyword">this</span>,</span><br><span class="line">data = &#123;</span><br><span class="line">    anything: <span class="keyword">this</span>.form.anything,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置并添加iframe至dom树</span></span><br><span class="line">iframe.name = <span class="string">"iframePost"</span>;</span><br><span class="line">iframe.style.display = <span class="string">"none"</span>;</span><br><span class="line">iframe.src = <span class="string">"http://localhost:8080"</span>;</span><br><span class="line">iframe.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 暂时还没有解决无法接收后台数据的问题。</span></span><br><span class="line">    context.returnMsg = res;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置并添加form至iframe</span></span><br><span class="line">form.action = <span class="string">"http://localhost:3000/api/testPost"</span>;</span><br><span class="line">form.target = iframe.name; <span class="comment">// 在提交表单之后，在指定的iframe中显示响应信息</span></span><br><span class="line">form.method = <span class="string">"post"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> data) &#123;</span><br><span class="line">    node.name = prop;</span><br><span class="line">    node.value = data[prop].toString();</span><br><span class="line">    form.appendChild(node.cloneNode());</span><br><span class="line">&#125;</span><br><span class="line">form.style.display = <span class="string">"none"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(form);</span><br><span class="line">form.submit(); <span class="comment">// 发送form</span></span><br><span class="line"><span class="built_in">document</span>.body.removeChild(form); <span class="comment">// 表单提交后,就可以删除这个表单,不影响下次的数据发送.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 后台 */</span></span><br><span class="line">router.post(<span class="string">'/testPost'</span>, (ctx) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`后台testPost接口被触发`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`接收到数据：<span class="subst">$&#123;ctx.request.body&#125;</span>`</span>);</span><br><span class="line">    ctx.response.status = <span class="number">200</span>;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">        status: <span class="string">"success"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-CORS（Cross-origin-resource-sharing，跨域资源共享）"><a href="#3-CORS（Cross-origin-resource-sharing，跨域资源共享）" class="headerlink" title="3. CORS（Cross-origin resource sharing，跨域资源共享）"></a>3. CORS（Cross-origin resource sharing，跨域资源共享）</h2><p>cors是一种规范，这个规范规定了一些能够进行跨域的情况。<br>如果我们需要根据cors规范跨域，绝大多数情况下仅需要在前后端设置一下http请求的header。</p><h3 id="关于cors规范，有些内容你必须了解"><a href="#关于cors规范，有些内容你必须了解" class="headerlink" title="关于cors规范，有些内容你必须了解"></a>关于cors规范，有些内容你必须了解</h3><h4 id="1-简单请求和非简单请求"><a href="#1-简单请求和非简单请求" class="headerlink" title="1. 简单请求和非简单请求"></a>1. 简单请求和非简单请求</h4><p>cors规范将请求分为了<strong>简单请求</strong>和<strong>非简单请求</strong>。为什么要划分呢?因为有些http请求可能会对服务器数据产生副作用，划分请求便是为了阻止这些副作用。</p><p>这两个请求的最大区别，便是简单请求只需发送一个http请求，而非简单请求一共需要发送两个http请求。非简单请求首先发起一个预检请求，获知后台是否允许跨域请求，确认允许后才可以发起实际的HTTP请求。简单请求直接发送实际的HTTP请求。</p><p>满足以下所有条件即简单请求(<strong><em><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">摘自mdn</a></em></strong>)</p><blockquote><ul><li>使用下列方法之一<ul><li>GET</li><li>HEAD</li><li>POST</li></ul></li><li>除了被用户代理自动设置的首部字段（例如 Connection ，User-Agent）和在 Fetch 规范中定义为 禁用首部名称 的其他首部，允许人为设置的字段为 Fetch 规范定义的 对 CORS 安全的首部字段集合。该集合为：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type （需要注意额外的限制）</li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul></li><li>Content-Type 的值仅限于下列三者之一：（牢记，容易出问题，我们常用的application/json并不包括在里面）<ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul></li><li>请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</li><li>请求中没有使用 ReadableStream 对象。</li></ul></blockquote><h3 id="cors跨域该如何设置？"><a href="#cors跨域该如何设置？" class="headerlink" title="cors跨域该如何设置？"></a>cors跨域该如何设置？</h3><p>前端：</p><ol><li>如果需要携带认证信息（包括cookie），需要设置<code>xhr.withCredentials = true</code>。</li><li>根据自己传送的数据类型，设置一下<code>contentType</code>，如<code>xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);</code></li></ol><p>后台：</p><ol><li><code>Access-Control-Allow-Origin</code>：设置允许访问资源的源，经常被设置为<code>&quot;*&quot;</code>，注意如果携带了认证信息，该字段值不能设置为<code>&quot;*&quot;</code>，需要设置为相应的uri。</li><li>如果携带认证信息(包括cookie)，设置<code>Access-Control-Allow-Credentials</code>的值为<code>true</code>。非简单请求一般情况下也将该字段设置为<code>true</code>。</li><li><code>Access-Control-Allow-Headers</code>：设置请求头中除一些标准的字段，额外允许携带的字段。比如<code>Content-Type</code>。多个字段用逗号隔开，如：<code>&#39;Content-Type, Content-Length, Authorization, Accept&#39;</code></li><li><code>Access-Control-Allow-Methods</code>：设置前端可以使用哪些方法进行请求。可以设置为：<code>&#39;PUT, POST, GET, DELETE, OPTIONS&#39;</code><br>设置了这几个字段，基本就能实现请求的跨域了，其他字段可以根据需要另行设置。</li></ol><h3 id="与cors跨域相关的字段（仅做总结）"><a href="#与cors跨域相关的字段（仅做总结）" class="headerlink" title="与cors跨域相关的字段（仅做总结）"></a>与cors跨域相关的字段（仅做总结）</h3><h4 id="请求头的相关字段："><a href="#请求头的相关字段：" class="headerlink" title="请求头的相关字段："></a>请求头的相关字段：</h4><ul><li><code>origin</code>：发送请求的源的URI。</li><li><code>Access-Control-Request-Method</code>：仅用于预检请求。将实际请求所使用的 HTTP 方法告诉服务器。</li><li><code>Access-Control-Request-Headers</code>：仅用于预检请求。将实际请求所携带的首部字段告诉服务器。</li></ul><h4 id="响应头的相关字段："><a href="#响应头的相关字段：" class="headerlink" title="响应头的相关字段："></a>响应头的相关字段：</h4><ol><li><code>Access-Control-Allow-Origin</code>，指定可以访问该资源的URI。“*”指任何人都可以访问；也可以是具体的uri，比如：<code>https://developer.mozilla.org</code>。<ul><li>对于附带身份凭证的请求，或需要传递cookie的请求，该值不能使用<code>&quot;*&quot;</code></li></ul></li><li><code>Access-Control-Allow-Credentials</code>，表示是否可以将对请求的响应暴露给页面。<ul><li>如果前端要把cookie传递至后台，则后台必须将响应头中该字段的值设为<code>true</code></li></ul></li><li><code>Access-Control-Allow-Methods</code>，表示前端可以使用哪些方法进行请求。</li><li><code>Access-Control-Allow-Headers</code>，表示请求头中除一些标准的字段，额外允许携带的字段。</li><li><code>Access-Control-Expose-Headers</code>，扩展前端使用<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法所能获取到的响应头信息。<code>getResponseHeader()</code>默认只能获取最基本的响应头：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code></li><li><code>Access-Control-Max-Age</code>，指定预检请求可以被缓存多少秒。</li></ol><h2 id="基于上述内容做的一个跨域模拟器"><a href="#基于上述内容做的一个跨域模拟器" class="headerlink" title="基于上述内容做的一个跨域模拟器"></a>基于上述内容做的一个跨域模拟器</h2><p>项目基于nodejs koa2和vue3.0实现（基本没用什么新特性..），这个模拟器可以用来：</p><ol><li>观察跨域时的http报文..</li><li>直接看源码，了解上述跨域方法是如何使用的。</li></ol><p>嗯嗯..就这些了..这也是我第一次用这个koa框架和vue3.0..喜欢的话帮忙点个Star呗~ 欢迎pr~ 项目地址：<a href="https://github.com/Michael-Zhang-Xian-Sen/cross-domain-simulation" target="_blank" rel="noopener">https://github.com/Michael-Zhang-Xian-Sen/cross-domain-simulation</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/weixin_42672054/article/details/81985736" target="_blank" rel="noopener">30 分钟理解 CORB 是什么</a></li><li><a href="https://en.wikipedia.org/wiki/JSONP" target="_blank" rel="noopener">Jsonp 维基百科</a></li><li><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">前端常见跨域解决方案（全）</a></li><li><a href="https://web.archive.org/web/20120608162347/http://bob.ippoli.to/archives/2005/12/05/remote-json-jsonp/" target="_blank" rel="noopener">Remote JSON - JSONP</a></li><li><a href="https://segmentfault.com/a/1190000015597029" target="_blank" rel="noopener">不要再问我跨域的问题了</a></li></ol><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ol><li><a href="https://www.w3.org/wiki/CORS#Why_is_there_a_preflight_request.3F" target="_blank" rel="noopener">w3c cors标准</a></li></ol>]]></content>
    
    <summary type="html">
    
      同源策略及跨域
    
    </summary>
    
      <category term="浏览器" scheme="http://nice2meetu.site/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="跨域" scheme="http://nice2meetu.site/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>js函数防抖与节流</title>
    <link href="http://nice2meetu.site/2020/08/28/js%E5%9F%BA%E7%A1%80/js%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>http://nice2meetu.site/2020/08/28/js基础/js函数防抖与节流/</id>
    <published>2020-08-28T05:57:00.000Z</published>
    <updated>2020-09-10T07:29:23.480Z</updated>
    
    <content type="html"><![CDATA[<p>在前端开发中，很多场景会频繁地触发事件，出于效率或者业务等方面的考虑，我们不想频繁触发事件，这时候就需要用到函数的防抖和节流。</p><h2 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"content"</span> style=<span class="string">"height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        content.innerHTML = num++;</span><br><span class="line">    &#125;;</span><br><span class="line">    content.onmousemove = count;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h2><p>短时间内多次触发同一事件，只在最后一次执行目标函数，或者只在最开始的一次执行目标函数，中间的不执行。</p><p>实现方式是将目标函数传递给<code>debounce</code>函数进行处理，<code>debounce</code>函数返回一个带有防抖功能的新函数。实际上每次触发事件仍然会执行该函数，但是只有在满足某些条件时，才会执行原来的目标函数。</p><p>根据执行目标函数的时间区分，有立即执行版的函数防抖和非立即执行版的函数防抖。</p><ul><li>立即执行版本的函数防抖：触发某事件后，立刻执行该事件的目标函数，但后续触发事件都不会使目标函数执行，直到最后一次触发事件然后经过指定时间，再次触发事件才可执行目标函数。</li><li>非立即执行版本的函数防抖：触发某事件后不会立即执行目标函数，直到最后一次触发事件然后经过指定时间，才会执行目标函数。</li></ul><p>代码实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">funciton debounce(func,wait,immediate)&#123;</span><br><span class="line">    <span class="keyword">let</span> timer; <span class="comment">// 存储定时器的编号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回添加了防抖功能的函数。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>,</span><br><span class="line">            args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一定需要先清除已有的定时器。</span></span><br><span class="line">        <span class="comment">// 立即执行版的定时器，用于判断能否触发func。如果当前存在timer，说明已经执行过func，需要等待一定时间后才可再次执行该func，故一定要重新设置setTimeout。等待时间一到，此时再次触发该事件，才可执行func（设置timer=null）。</span></span><br><span class="line">        <span class="comment">// 非立即执行版的定时器，用于触发func。如果当前存在timer，需要清除该timer，并重新设置setTimeout，因为我们期望的是”用户最后一次触发事件然后经过指定时间，才可执行func“</span></span><br><span class="line">        <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(immediate)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">                func.apply(context,args);   <span class="comment">// 一段时间未触发该事件，执行func。</span></span><br><span class="line">            &#125;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;timer=<span class="literal">null</span>&#125;,wait);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context,<span class="built_in">arguments</span>);</span><br><span class="line">            &#125;,wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流(throttle)"></a>函数节流(throttle)</h2><p>指连续触发事件但是在 n 秒中只执行一次目标函数。即 2n 秒内执行 2 次、3n秒内执行3次…以此类推。会稀释函数的执行频率。</p><p>有两种不同的实现方式，根据实现方式的不同，触发目标函数的时刻也不相同。</p><ol><li>时间戳实现，在时间段开始的时候触发函数。</li><li>定时器实现，在时间段结束的时候触发函数。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 函数节流</span></span><br><span class="line"><span class="comment"> * @param func 函数</span></span><br><span class="line"><span class="comment"> * @param wait 延迟执行毫秒数</span></span><br><span class="line"><span class="comment"> * @param type 1 表时间戳版，2 表定时器版</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,wait,type</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>,</span><br><span class="line">        timeout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>,</span><br><span class="line">            args = <span class="built_in">arguments</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(type === <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> now = <span class="built_in">Date</span>.now(); <span class="comment">// 记录当前时间</span></span><br><span class="line">            <span class="keyword">if</span>(now - previous &gt; wait)&#123; <span class="comment">// 如果当前时间-上一次执行func的时间&gt;时间间隔，则可以触发func</span></span><br><span class="line">                func.apply(context,args);</span><br><span class="line">                previous = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!timeout)&#123; <span class="comment">// 如果当前没有执行过func或刚执行完毕func，则触发setTimeout，经过wait时间后调用func。</span></span><br><span class="line">                timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    timeout = <span class="literal">null</span>;</span><br><span class="line">                    func.apply(context,args);</span><br><span class="line">                &#125;,wait)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于节流-防抖函数中-context（this）-的指向解析"><a href="#关于节流-防抖函数中-context（this）-的指向解析" class="headerlink" title="关于节流/防抖函数中 context（this） 的指向解析"></a>关于节流/防抖函数中 context（this） 的指向解析</h2><h3 id="首先要明确一个问题，即节流-防抖函数执行后返回的匿名函数的this指向问题。"><a href="#首先要明确一个问题，即节流-防抖函数执行后返回的匿名函数的this指向问题。" class="headerlink" title="首先要明确一个问题，即节流/防抖函数执行后返回的匿名函数的this指向问题。"></a>首先要明确一个问题，即节流/防抖函数执行后返回的匿名函数的this指向问题。</h3><p>由于节流/防抖函数执行后返回的是一个匿名函数，如果无其他操作，该匿名函数内部的<code>this</code>应为window或其他全局对象。但是该匿名函数被赋给了<code>content.onmousemove</code>事件，形成了一个函数表达式，因此该函数内部的<code>this</code>此时指向绑定该事件的节点，即事件的<code>currentTarget</code>。</p><h3 id="其次要明确，func函数内部的this指向问题。"><a href="#其次要明确，func函数内部的this指向问题。" class="headerlink" title="其次要明确，func函数内部的this指向问题。"></a>其次要明确，func函数内部的this指向问题。</h3><p>在执行被节流/防抖的目标函数<code>func</code>时，如果直接调用(即<code>func()</code>)，其调用者为全局对象，因此<code>func</code>函数内部的<code>this</code>为<code>window</code>。如果我们需要<code>func</code>函数内部的<code>this</code>指向当前绑定该事件的元素，则需要使用<code>apply</code>方法手动改变<code>func</code>的<code>this</code>。</p><h3 id="怎么改变func函数内部的this指向调用该事件的dom节点呢？"><a href="#怎么改变func函数内部的this指向调用该事件的dom节点呢？" class="headerlink" title="怎么改变func函数内部的this指向调用该事件的dom节点呢？"></a>怎么改变func函数内部的this指向调用该事件的dom节点呢？</h3><p>我们只需需要将匿名函数中的<code>this</code>传递给<code>func</code>，因为<code>throttle</code>/<code>debounce</code>返回的匿名函数中，<code>this</code>指向的即为调用该事件的dom节点。</p><p>在<code>func</code>无<code>setTimeout</code>包裹的情况下，直接使用<code>func.apply(this,arguments)</code>；但是如果有<code>setTimeout</code>包裹呢？</p><p>这里给出两种传递方法</p><ol><li>将匿名函数的this使用变量记录下来，然后使用<code>func.apply(context,args)</code>，即本文函数防抖与节流的方法。</li><li>使用箭头函数的写法编写setTimeout的回调函数，如：<code>setTimeout(()=&gt;{func.apply(this,arguments)},delay)</code></li></ol><h4 id="方法1：将匿名函数的this使用变量记录下来，然后使用func-apply-，即本文函数防抖与节流的方法。"><a href="#方法1：将匿名函数的this使用变量记录下来，然后使用func-apply-，即本文函数防抖与节流的方法。" class="headerlink" title="方法1：将匿名函数的this使用变量记录下来，然后使用func.apply()，即本文函数防抖与节流的方法。"></a>方法1：将匿名函数的this使用变量记录下来，然后使用<code>func.apply()</code>，即本文函数防抖与节流的方法。</h4><p>为什么不直接写<code>func.apply(this,arguments)</code>呢？</p><p>《JavaScript高级程序设计》第二版中，写到：“超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined”。</p><p>因为setTimeout是一种超时调用，其回调函数的内部作用域便是全局作用域，所以不能直接写<code>func.apply(this,arguments)</code>。</p><p>我们可以利用闭包，将匿名函数的<code>this</code>用另一个变量<code>context</code>记录下来，然后在setTimeout中使用，即：<code>func.apply(context,args)</code>，便实现了改变<code>func</code>内部的<code>this</code>为匿名函数的<code>this</code>。</p><h3 id="方法2：使用箭头函数的写法编写setTimeout的回调函数，如：setTimeout-gt-delay"><a href="#方法2：使用箭头函数的写法编写setTimeout的回调函数，如：setTimeout-gt-delay" class="headerlink" title="方法2：使用箭头函数的写法编写setTimeout的回调函数，如：setTimeout(()=&gt;{},delay)"></a>方法2：使用箭头函数的写法编写setTimeout的回调函数，如：<code>setTimeout(()=&gt;{},delay)</code></h3><p>箭头函数没有自己的this。箭头函数的作用域为定义时箭头函数所在的作用域，即被绑定到创建它时的上下文环境中。</p><p>因此，如果我们使用箭头函数的写法，则<code>setTimeout</code>的回调函数的作用域为匿名函数的作用域，然后通过<code>func.apply(this,argumnets)</code>，便实现了改变<code>func</code>内部的<code>this</code>为匿名函数的<code>this</code>，而匿名函数的<code>this</code>指向调用该事件的dom节点，故实现了改变func函数内部的this指向调用该事件的dom节点。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://juejin.im/post/6844903651278848014#heading-1" target="_blank" rel="noopener">js 函数的防抖(debounce)与节流(throttle)</a></li><li><a href="https://www.cnblogs.com/hutaoer/p/3423782.html" target="_blank" rel="noopener">【javascript 技巧】谈谈setTimeout的作用域以及this的指向问题</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前端开发中，很多场景会频繁地触发事件，出于效率或者业务等方面的考虑，我们不想频繁触发事件，这时候就需要用到函数的防抖和节流。&lt;/p&gt;
&lt;h2 id=&quot;准备材料&quot;&gt;&lt;a href=&quot;#准备材料&quot; class=&quot;headerlink&quot; title=&quot;准备材料&quot;&gt;&lt;/a&gt;准备材
      
    
    </summary>
    
      <category term="前端" scheme="http://nice2meetu.site/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://nice2meetu.site/tags/js/"/>
    
      <category term="前端" scheme="http://nice2meetu.site/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>js闭包</title>
    <link href="http://nice2meetu.site/2020/08/27/js%E5%9F%BA%E7%A1%80/js%E9%97%AD%E5%8C%85/"/>
    <id>http://nice2meetu.site/2020/08/27/js基础/js闭包/</id>
    <published>2020-08-27T08:04:50.000Z</published>
    <updated>2020-09-24T14:56:21.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是闭包-closure-？"><a href="#什么是闭包-closure-？" class="headerlink" title="什么是闭包(closure)？"></a>什么是闭包(closure)？</h2><ul><li>第一种解释：函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。</li><li>第二种解释（方大佬的解释）：「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。</li></ul><h2 id="什么是词法作用域？"><a href="#什么是词法作用域？" class="headerlink" title="什么是词法作用域？"></a>什么是词法作用域？</h2><p>词法（lexical）一词指的是，词法作用域根据源代码中声明变量的位置来确定该变量在何处可用。嵌套函数可访问声明于它们外部的作用域的变量。</p><h2 id="闭包的作用："><a href="#闭包的作用：" class="headerlink" title="闭包的作用："></a>闭包的作用：</h2><ol><li>它允许将函数与其所操作的某些数据（环境）关联起来。（类似面向对象编程中，对象允许我们将某些数据与一个或者多个方法相关联。）</li><li>让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。</li><li>可用于将函数与其所操作的某些数据（环境）关联起来。</li><li>可以使用闭包来模拟私有方法，保护函数内部的变量，有利于数据隐藏和封装。可以用来实现模块模式。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/22486908" target="_blank" rel="noopener">「每日一题」JS 中的闭包是什么？</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">MDN闭包</a></li></ul>]]></content>
    
    <summary type="html">
    
      关于attribute和property的区别
    
    </summary>
    
      <category term="前端" scheme="http://nice2meetu.site/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://nice2meetu.site/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>js事件总结</title>
    <link href="http://nice2meetu.site/2020/08/27/js%E5%9F%BA%E7%A1%80/js%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://nice2meetu.site/2020/08/27/js基础/js事件总结/</id>
    <published>2020-08-27T06:11:30.000Z</published>
    <updated>2020-09-03T10:29:06.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><ul><li><code>event.target</code>：一个触发事件的对象的引用， 当事件处理程序在事件的冒泡或捕获阶段被调用时。</li><li><code>event.currentTarget</code>：currentTarget是事件绑定的元素，即当事件遍历DOM时，标识事件的当前目标。</li></ul><h2 id="事件操作"><a href="#事件操作" class="headerlink" title="事件操作"></a>事件操作</h2><h3 id="新增事件"><a href="#新增事件" class="headerlink" title="新增事件"></a>新增事件</h3><ol><li><code>target.addEventListener(type, listener, useCapture);</code></li><li>dom对象.onXxxx</li></ol><p>方法1相较于方法2，可以向同一对象的同一事件添加多个监听方法。</p><h3 id="移除事件"><a href="#移除事件" class="headerlink" title="移除事件"></a>移除事件</h3><ol><li><code>target.removeEventListener(type, listener[, useCapture]);</code>移除事件。</li></ol><h3 id="阻止事件默认行为"><a href="#阻止事件默认行为" class="headerlink" title="阻止事件默认行为"></a>阻止事件默认行为</h3><p><code>event.preventDefault();</code></p><h2 id="事件捕获及事件冒泡"><a href="#事件捕获及事件冒泡" class="headerlink" title="事件捕获及事件冒泡"></a>事件捕获及事件冒泡</h2><p>当一个事件发生在具有父元素的元素上时，现代浏览器运行两个不同的阶段 - 捕获阶段和冒泡阶段。addEventListener添加的事件，默认只会触发冒泡阶段的事件，如果需要触发捕获阶段的事件，则需要将第三个参数设置为true。</p><h3 id="捕获阶段"><a href="#捕获阶段" class="headerlink" title="捕获阶段"></a>捕获阶段</h3><p>事件触发后，从最外层祖先开始，到实际触发事件的元素，依次判断是否存在相应的事件处理程序，如果有则触发该程序。</p><h3 id="冒泡阶段"><a href="#冒泡阶段" class="headerlink" title="冒泡阶段"></a>冒泡阶段</h3><p>事件触发后，从实际触发事件的元素开始，到最外层元素，依次判断是否存在相应的事件处理程序，如果有则触发该程序。</p><h3 id="阻止捕获和冒泡阶段中当前事件的进一步传播"><a href="#阻止捕获和冒泡阶段中当前事件的进一步传播" class="headerlink" title="阻止捕获和冒泡阶段中当前事件的进一步传播"></a>阻止捕获和冒泡阶段中当前事件的进一步传播</h3><p>使用<code>e.stopPropagation()</code>。</p><p>事件捕获及事件冒泡的实例：<a href="https://jsfiddle.net/Himory/L1r4cpaf/" target="_blank" rel="noopener">https://jsfiddle.net/Himory/L1r4cpaf/</a></p><h3 id="事件委托-事件代理-Event-Delegation"><a href="#事件委托-事件代理-Event-Delegation" class="headerlink" title="事件委托/事件代理(Event Delegation)"></a>事件委托/事件代理(Event Delegation)</h3><p>利用事件冒泡的特性，将应该注册在子元素上的处理事件注册在父元素上，这样点击子元素时发现子元素没有相应事件，通过冒泡到父元素进行寻找并执行。</p><p>这样做的优势有：</p><ol><li>减少DOM操作，提高性能。</li><li>随时可以添加子元素，添加的子元素会自动有相应的处理事件。</li></ol><p>事件委托的实例：<a href="https://jsfiddle.net/Himory/r5yav9fe/" target="_blank" rel="noopener">https://jsfiddle.net/Himory/r5yav9fe/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事件对象&quot;&gt;&lt;a href=&quot;#事件对象&quot; class=&quot;headerlink&quot; title=&quot;事件对象&quot;&gt;&lt;/a&gt;事件对象&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;event.target&lt;/code&gt;：一个触发事件的对象的引用， 当事件处理程序在事件的冒泡或捕获
      
    
    </summary>
    
      <category term="前端" scheme="http://nice2meetu.site/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://nice2meetu.site/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>二叉树总结</title>
    <link href="http://nice2meetu.site/2020/08/25/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93/"/>
    <id>http://nice2meetu.site/2020/08/25/算法/二叉树总结/</id>
    <published>2020-08-25T12:15:30.000Z</published>
    <updated>2020-09-03T06:38:15.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的常见形式"><a href="#二叉树的常见形式" class="headerlink" title="二叉树的常见形式"></a>二叉树的常见形式</h2><h3 id="1-对象数组。"><a href="#1-对象数组。" class="headerlink" title="1. 对象数组。"></a>1. 对象数组。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">value,left,right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.left = left;</span><br><span class="line">    <span class="keyword">this</span>.right = right;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><ol><li>先序(根)遍历。Preorder Traversal (VLR)</li><li>中序(根)遍历。</li><li>后序(根)遍历。</li><li>按层遍历</li></ol><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>根-左-右</p><h4 id="递归实现："><a href="#递归实现：" class="headerlink" title="递归实现："></a>递归实现：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preorderTraversal</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> preorderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123; <span class="comment">// 定义一个函数，用来递归向result数组中添加先序遍历的结果。</span></span><br><span class="line">        <span class="keyword">if</span>(node)&#123; <span class="comment">// 如果当前节点存在值，则将当前节点加入至结果数组，并且遍历其左右子树。</span></span><br><span class="line">            result.push(node.value);</span><br><span class="line">            preorderTraversalNode(node.left);</span><br><span class="line">            preorderTraversalNode(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    preorderTraversalNode(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h4><ul><li>广度优先遍历</li><li>维护一个可走路径的栈。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preorderTraversal</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stack = [],</span><br><span class="line">        result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root) stack.push(root); <span class="comment">// 将根节点入栈</span></span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> curNode = stack.pop();  <span class="comment">// 取出当前遍历的节点</span></span><br><span class="line">        list.push(curNode.value);   <span class="comment">// 将当前节点值放入结果数组。</span></span><br><span class="line">        <span class="keyword">if</span>(curNode.right)&#123;          </span><br><span class="line">            stack.push(curNode.right);  <span class="comment">// 如果右子树存在，则将右子树入栈。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curNode.left)&#123;</span><br><span class="line">            stack.push(curNode.left);   <span class="comment">// 如果左子树存在，则将左子树入栈。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>左-根-右</p><h4 id="递归实现：-1"><a href="#递归实现：-1" class="headerlink" title="递归实现："></a>递归实现：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inorderTraversal</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> preorderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            preorderTraversalNode(node.left);</span><br><span class="line">            result.push(node.value);</span><br><span class="line">            preorderTraversalNode(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    preorderTraversalNode(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代实现-1"><a href="#迭代实现-1" class="headerlink" title="迭代实现"></a>迭代实现</h4><p>整体思路：</p><ul><li>深度优先遍历，仍然需要一个栈来存储路径。</li><li>走过的路径入栈，遇到无路可走时出栈，不断地尝试，直到栈为空（循环，出口为栈为空）。</li><li>不急于走（不先将当前节点入栈），先试探（尝试）当前节点是否能走，如果能走则走当前节点（入栈），然后根据优先级判断下面可以走的节点，然后继续试探（进入下个循环）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inorderTraversal</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [],</span><br><span class="line">        stack = [],</span><br><span class="line">        curNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取当前节点为根节点。</span></span><br><span class="line">    <span class="keyword">if</span>(root) &#123;</span><br><span class="line">        curNode = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stack.length || curNode)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curNode)&#123; <span class="comment">// 如果当前节点可以走，则加入路径（入栈）。</span></span><br><span class="line">            stack.push(curNode);</span><br><span class="line">            curNode = curNode.left; <span class="comment">// 下一步往左走。</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curNode = stack.pop();</span><br><span class="line">            result.push(curNode.value);</span><br><span class="line">            curNode = curNode.right; <span class="comment">// 下一个节点为当前节点的右子树。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>左-右-根</p><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postorderTraversal</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">var</span> postorderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            postorderTraversalNode(node.left);</span><br><span class="line">            postorderTraversalNode(node.right);</span><br><span class="line">            result.push(node.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    postorderTraversalNode(root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代实现-2"><a href="#迭代实现-2" class="headerlink" title="迭代实现"></a>迭代实现</h4><p>将原序列从反顺序遍历。根节点在结果数组中一定晚于左子树和右子树节点出现，且右子树一定晚于左子树出现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postorderTraversal</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [],</span><br><span class="line">        stack = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        stack.push(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">        node.left &amp;&amp; stack.push(node.left);</span><br><span class="line">        node.right &amp;&amp; stack.push(node.right);</span><br><span class="line">        result.unshift(node.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按层遍历"><a href="#按层遍历" class="headerlink" title="按层遍历"></a>按层遍历</h3><p>从上到下，从左到右，依次遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">levelTraversal</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [],</span><br><span class="line">        queue = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root) queue.push(root);</span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">        result.push(node.value);</span><br><span class="line">        node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">        node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode102：二叉树的层序遍历"><a href="#LeetCode102：二叉树的层序遍历" class="headerlink" title="LeetCode102：二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">LeetCode102：二叉树的层序遍历</a></h4><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">二叉树：[3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>题解：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [],</span><br><span class="line">        pathQueue = [],</span><br><span class="line">        depthQueue = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        pathQueue.push(root);</span><br><span class="line">        depthQueue.push(<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">while</span>(pathQueue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = pathQueue.shift(),</span><br><span class="line">            depth = depthQueue.shift();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!result[depth])&#123;</span><br><span class="line">            result[depth] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        result[depth].push(node.val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.left)&#123;</span><br><span class="line">            pathQueue.push(node.left);</span><br><span class="line">            depthQueue.push(depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right)&#123;</span><br><span class="line">            pathQueue.push(node.right);</span><br><span class="line">            depthQueue.push(depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树的常见形式&quot;&gt;&lt;a href=&quot;#二叉树的常见形式&quot; class=&quot;headerlink&quot; title=&quot;二叉树的常见形式&quot;&gt;&lt;/a&gt;二叉树的常见形式&lt;/h2&gt;&lt;h3 id=&quot;1-对象数组。&quot;&gt;&lt;a href=&quot;#1-对象数组。&quot; class=&quot;header
      
    
    </summary>
    
      <category term="算法" scheme="http://nice2meetu.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://nice2meetu.site/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>js出现舍入误差的原因及应对方案</title>
    <link href="http://nice2meetu.site/2020/08/25/js%E5%9F%BA%E7%A1%80/js%E8%88%8D%E5%85%A5%E8%AF%AF%E5%B7%AE%E5%8F%8A%E5%85%B6%E6%B6%88%E9%99%A4%E6%96%B9%E6%A1%88/"/>
    <id>http://nice2meetu.site/2020/08/25/js基础/js舍入误差及其消除方案/</id>
    <published>2020-08-25T02:34:30.000Z</published>
    <updated>2020-08-25T09:11:52.943Z</updated>
    
    <content type="html"><![CDATA[<h3 id="舍入误差"><a href="#舍入误差" class="headerlink" title="舍入误差"></a>舍入误差</h3><p>Number类型使用IEEE 754 双精度 64 位浮点数格式来表示整数和浮点值。</p><ul><li>符号位，第63位（共1位），用来区分正负数。</li><li>指数，第52-62位（共11位），即2的指数。</li><li>第0到51是尾数位（共52位）。<br>因此，2^(-53)到2^53之间的整数都可以精确表示，但是对于计算机而言，两个数字在相加时是以二进制形式进行的，在呈现结果时才转换成十进制，所以浮点数不一定能精确表示。</li></ul><h4 id="十进制小数转二进制小数"><a href="#十进制小数转二进制小数" class="headerlink" title="十进制小数转二进制小数"></a>十进制小数转二进制小数</h4><p>用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，此时0或1为二进制的最后一位。或者达到所要求的精度为止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如：0.1 =（0.0 0011 0011 0011...(0011无限循环下去)）B</span><br><span class="line">0.1*2=0.2========取出整数部分0</span><br><span class="line">0.2*2=0.4========取出整数部分0</span><br><span class="line">0.4*2=0.8========取出整数部分0</span><br><span class="line">0.8*2=1.6========取出整数部分1</span><br><span class="line">0.6*2=1.2========取出整数部分1</span><br><span class="line">0.2*2=0.4========取出整数部分0</span><br><span class="line">0.4*2=0.8========取出整数部分0</span><br><span class="line">0.8*2=1.6========取出整数部分1</span><br><span class="line">0.6*2=1.2========取出整数部分1</span><br><span class="line">0.2*2=0.4========取出整数部分0</span><br></pre></td></tr></table></figure><p>0.1和0.2的表示如下所示：</p><ul><li>0.1：e = -4; m =1.1001100110011001100110011001100110011001100110011010 (52位)</li><li>0.2：e = -3; m =1.1001100110011001100110011001100110011001100110011010 (52位)</li></ul><h4 id="二进制的舍入规则"><a href="#二进制的舍入规则" class="headerlink" title="二进制的舍入规则"></a>二进制的舍入规则</h4><p>舍入的目标即尽可能使舍入后的结果与真实值误差最小（尽可能减小舍入处理的影响）。如果以形式1.RR..RDD..D表示浮点数（R表示有效位，或保留位，而D表示舍去位），舍入规则就是：</p><ul><li>如果DD..D &lt; 10..0，则向下舍入。如：<code>1.001011</code>，保留四位有效数字，由于舍去位<code>011 &lt; 100</code>，故保留位最后一位不进位，结果为：<code>1.001</code>。</li><li>如果DD..D &gt; 10..0，则向上舍入。如：<code>1.001101</code>，保留四位有效数字，由于舍去位<code>101 &gt; 100</code>，故保留位最后一位进位1，结果为：<code>1.010</code>。</li><li>如要DD..D = 10..0，则向最近偶数舍入，细则如下 ：<ul><li>如果RR..R = XX..0 （最低有效位是0），则向下舍入。如：<code>1.100100</code>，保留四位有效数字，由于最低有效位是0，故不进位，结果为：<code>1.100</code>。</li><li>如果RR..R = XX..1（最低有效位是1），则向上舍入。如：<code>1.001100</code>，保留四位有效数字，由于最低有效位是1，故进位1，结果为：<code>1.010</code>。</li></ul></li></ul><h4 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1 + 0.2 !== 0.3"></a>0.1 + 0.2 !== 0.3</h4><p>0.1与0.2二进制相加，步骤如下：</p><ol><li>对齐二进制位。由于0.1与0.2的指数不一致，需要对齐。<ul><li>0.1：e = -3; m = 0.1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101</li></ul><ul><li>0.2：e = -3; m = 1.1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010</li></ul></li><li>对应位数相加<ul><li>相加后得到的结果：e = -3; m = 10.0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0111</li></ul></li><li>超出的精度需要舍入。由于最后的舍去位是<code>1</code>，且最低有效位是<code>1</code>，故向上舍入，保留位最后一位进1.<ul><li>最终结果：e = -2; m = 1.0011001100110011001100110011001100110011001100110100(52位)</li><li>最终结果的二进制形式：0.010011001100110011001100110011001100110011001100110100</li><li>最终结果的十进制形式：0.30000000000000004</li></ul></li></ol><p>解决js中（或者说遵循IEEE 754规范）的语言中，两浮点数相加结果不正确的问题，可以设置一个误差范围值，即“机器精度”。对于Javascript来说，这个值通常是2^-52。</p><p>ES6中新增属性<code>Number.EMPSILON</code>，表示 1 与Number可表示的大于 1 的最小的浮点数之间的差值。可以使用<code>Number.EMPSILON</code>作为机器精度。</p><p>一个用于判断两数是否相等，并且消除了浮点数相加时舍入误差带来的影响：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a-b) &lt; <span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>深入探讨浮点数舍入问题：<a href="https://blog.csdn.net/qq_42372980/article/details/80554247?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight" target="_blank" rel="noopener">https://blog.csdn.net/qq_42372980/article/details/80554247?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight</a></li><li>Javascript中的Number类型和BigInt类型：<a href="https://blog.csdn.net/RaeZhang/article/details/107624193" target="_blank" rel="noopener">https://blog.csdn.net/RaeZhang/article/details/107624193</a></li><li>MDN中有关Number.EPSILON的介绍：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;舍入误差&quot;&gt;&lt;a href=&quot;#舍入误差&quot; class=&quot;headerlink&quot; title=&quot;舍入误差&quot;&gt;&lt;/a&gt;舍入误差&lt;/h3&gt;&lt;p&gt;Number类型使用IEEE 754 双精度 64 位浮点数格式来表示整数和浮点值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号位，第6
      
    
    </summary>
    
      <category term="前端" scheme="http://nice2meetu.site/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://nice2meetu.site/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>字节前端 一面</title>
    <link href="http://nice2meetu.site/2020/08/24/%E7%A7%8B%E6%8B%9B%E5%8E%86%E7%A8%8B/%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2/"/>
    <id>http://nice2meetu.site/2020/08/24/秋招历程/字节一面/</id>
    <published>2020-08-24T09:00:30.000Z</published>
    <updated>2020-09-03T10:24:25.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1-算法题"><a href="#1-算法题" class="headerlink" title="1. 算法题"></a>1. 算法题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从左侧视角打印一棵二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             1</span></span><br><span class="line"><span class="comment">//     2        3</span></span><br><span class="line"><span class="comment">// 4       5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"><span class="comment">// [1, 2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printTree</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 补全代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; val, left, right &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printTree</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [],</span><br><span class="line">        pathQueue = [],</span><br><span class="line">        depthQueue = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        pathQueue.push(root);</span><br><span class="line">        depthQueue.push(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pathQueue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = pathQueue.shift(),</span><br><span class="line">            depth = depthQueue.shift();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(result[depth] === <span class="literal">undefined</span>)&#123;</span><br><span class="line">            result.push(node.value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.left)&#123;</span><br><span class="line">            pathQueue.push(node.left);</span><br><span class="line">            depthQueue.push(depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right)&#123;</span><br><span class="line">            pathQueue.push(node.right);</span><br><span class="line">            depthQueue.push(depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-算法题"><a href="#2-算法题" class="headerlink" title="2. 算法题"></a>2. 算法题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求一个数组A中所有长度为N的组合</span></span><br><span class="line"><span class="comment">// A = [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// N = 3</span></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"><span class="comment">// [[1, 2, 3], [1, 2, 4], [1, 2, 5], ....]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">group</span>(<span class="params">A, N</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 补全代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个思路，使用标记数组，有事先不写了…</p><h3 id="3-什么是CORS"><a href="#3-什么是CORS" class="headerlink" title="3. 什么是CORS?"></a>3. 什么是CORS?</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）</p><h3 id="4-TCP协议队头阻塞"><a href="#4-TCP协议队头阻塞" class="headerlink" title="4. TCP协议队头阻塞"></a>4. TCP协议队头阻塞</h3><ol><li>TCP队头阻塞<br>TCP数据包是有序传输，中间一个数据包丢失，会等待该数据包重传，造成后面的数据包的阻塞。</li><li>HTTP队头阻塞<br>http队头阻塞和TCP队头阻塞完全不是一回事。</li></ol><p>http1.x采用长连接(Connection:keep-alive)，可以在一个TCP请求上，发送多个http请求。</p><p>有非管道化和管道化，两种方式。</p><p>非管道化，完全串行执行，请求-&gt;响应-&gt;请求-&gt;响应…，后一个请求必须在前一个响应之后发送。</p><p>管道化，请求可以并行发出，但是响应必须串行返回。后一个响应必须在前一个响应之后。原因是，没有序号标明顺序，只能串行接收。</p><p>管道化请求的致命弱点:</p><ol><li>会造成队头阻塞，前一个响应未及时返回，后面的响应被阻塞</li><li>请求必须是幂等请求，不能修改资源。因为，意外中断时候，客户端需要把未收到响应的请求重发，非幂等请求，会造成资源破坏。</li></ol><p>由于这个原因，目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式。</p><p>无论是非管道化还是管道化，都会造成队头阻塞(请求阻塞)。</p><p>解决http队头阻塞的方法：</p><ol><li>并发TCP连接（浏览器一个域名采用6-8个TCP连接，并发HTTP请求）</li><li><p>域名分片（多个域名，可以建立更多的TCP连接，从而提高HTTP请求的并发）</p></li><li><p>HTTP2方式</p></li></ol><p>http2使用一个域名单一TCP连接发送请求，请求包被二进制分帧，不同请求可以互相穿插，避免了http层面的请求队头阻塞。但是不能避免TCP层面的队头阻塞。</p><p>抄自：<a href="https://www.cnblogs.com/mengff/p/12724641.html" target="_blank" rel="noopener">https://www.cnblogs.com/mengff/p/12724641.html</a></p><h3 id="5-进程间通信的方式有哪些"><a href="#5-进程间通信的方式有哪些" class="headerlink" title="5. 进程间通信的方式有哪些"></a>5. 进程间通信的方式有哪些</h3><p>进程间通信方式有bai管道、信du号量、信号、消息队列、共享内存、套接字六种。<br>（1）管道分为有名管道和无名管道，其中无名管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用，一般用于两个不同进程之间的通信。有名管道也是一种半双工的通信方式，但它允许无亲缘关系进程间的通信。<br>（2）信号量是一个计数器，可以用来控制多个线程对共享资源的访问，它不是用于交换大批数据，而用于多线程之间的同步。他常作为一种锁机制。因此，主要作为进程间以及同一个进程内不同线程之间的同步手段。<br>（3）信号是一种比较复杂的通信方式，用于通知接收进程某个时间已经发生。<br>（4）消息队列是消息的链表，存放在内核中并由消息队列标识符标识，消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。<br>（5）共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。他往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。<br>（6）套接字可用于不同及其间的进程通信。</p><h3 id="6-数据库的事务是指什么。"><a href="#6-数据库的事务是指什么。" class="headerlink" title="6. 数据库的事务是指什么。"></a>6. 数据库的事务是指什么。</h3><p>数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。ACID特性。</p><p>1、原子性(Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么全部不执行。<br>2、一致性(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序 串行执行的结果相一致。<br>3、隔离性(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。<br>4、持久性(Durability):对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。</p><h3 id="7-怎么用css实现一个正方形，要求宽度是屏幕宽度的一半。"><a href="#7-怎么用css实现一个正方形，要求宽度是屏幕宽度的一半。" class="headerlink" title="7. 怎么用css实现一个正方形，要求宽度是屏幕宽度的一半。"></a>7. 怎么用css实现一个正方形，要求宽度是屏幕宽度的一半。</h3><p>vw单位。1vw等于视口宽度的1%。</p><h3 id="8-编写isEqual-a-b-，使得逾期返回true。"><a href="#8-编写isEqual-a-b-，使得逾期返回true。" class="headerlink" title="8. 编写isEqual(a, b)，使得逾期返回true。"></a>8. 编写isEqual(a, b)，使得逾期返回true。</h3><p>已总结博客。见：js出现舍入误差的原因及应对方案</p><ol><li>什么是CORS?</li><li>TCP协议队头阻塞？</li><li>进程间通信的方式有哪些</li></ol><h3 id="9-事件的target和currentTarget分别是什么"><a href="#9-事件的target和currentTarget分别是什么" class="headerlink" title="9. 事件的target和currentTarget分别是什么"></a>9. 事件的target和currentTarget分别是什么</h3><p>target指触发事件的元素。<br>currentTarget指由于冒泡/捕获遍历元素的事件程序时，当前遍历到的元素。<br>已总结博客，见“js事件总结“</p><h3 id="10-for…in-和-Object-keys-的区别"><a href="#10-for…in-和-Object-keys-的区别" class="headerlink" title="10. for…in 和 Object.keys 的区别"></a>10. for…in 和 Object.keys 的区别</h3><p>两者之间最主要的区别就是Object.keys( )不会走原型链，而for in 会走原型链….</p><h3 id="11-form元素的target属性作用是什么：target-action"><a href="#11-form元素的target属性作用是什么：target-action" class="headerlink" title="11. form元素的target属性作用是什么：target=? action"></a>11. form元素的target属性作用是什么：target=? action</h3><p>target属性定在何处打开actionURL。共有五个属性值：</p><ol><li>_blank，在新窗口打开。</li><li>_self，默认，在相同的框架打开。</li><li>_parent，在父框架集中打开。</li><li>_top，在整个窗口中打开。</li><li>framename，在指定的框架打开。</li></ol><p>action属性，用来处理表单提交的URL。该属性可能会被覆盖。</p><h3 id="12-VUE父子组件怎么通信？"><a href="#12-VUE父子组件怎么通信？" class="headerlink" title="12. VUE父子组件怎么通信？"></a>12. VUE父子组件怎么通信？</h3><ol><li>props、emit</li><li>eventBus（不推荐）</li><li>vuex（不推荐）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;h3 id=&quot;1-算法题&quot;&gt;&lt;a href=&quot;#1-算法题&quot; class=&quot;headerlink&quot; title=&quot;1. 算法题&quot;&gt;&lt;/a&gt;1. 
      
    
    </summary>
    
      <category term="秋招" scheme="http://nice2meetu.site/categories/%E7%A7%8B%E6%8B%9B/"/>
    
    
      <category term="秋招" scheme="http://nice2meetu.site/tags/%E7%A7%8B%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="http://nice2meetu.site/2020/08/24/%E7%BD%91%E7%BB%9C/http/http%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://nice2meetu.site/2020/08/24/网络/http/http状态码/</id>
    <published>2020-08-24T06:14:00.000Z</published>
    <updated>2020-09-23T02:56:50.323Z</updated>
    
    <content type="html"><![CDATA[<ol><li><code>1xx</code>消息（Informational）</li><li><code>2xx</code>成功（Success）</li><li><code>3xx</code>重定向（Redirection）</li><li><code>4xx</code>客户端错误（Client error）：客户端请求出错，服务器无法处理请求</li><li><code>5xx</code>服务器错误（Server Error）：服务器处理请求出错。</li></ol><h3 id="1-消息"><a href="#1-消息" class="headerlink" title="1. 消息"></a>1. 消息</h3><p>接收的请求正在处理。</p><h3 id="2-成功"><a href="#2-成功" class="headerlink" title="2. 成功"></a>2. 成功</h3><p>请求正常处理完毕。</p><ul><li><code>200 OK</code>，表示从客户端发送给服务器的请求被正常处理并返回。</li><li><code>204 No Content</code>，请求处理成功，但没有任何资源可以返回给客户端，一般在只需要从客户端往服务器发送信息，而服务器不需要向客户端发送新信息内容的情况下使用。</li><li><code>206 Partial Content</code>，是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</li></ul><h3 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3. 重定向"></a>3. 重定向</h3><p>需要进行附加操作以完成请求。</p><ul><li><code>301 Moved Permanently</code>，永久性重定向。请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。</li><li><code>302 Found</code>，临时性重定向。和301相似，但302代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。</li><li><code>303 See Other</code>，该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。</li><li><code>304 Not Modified</code>，资源已找到，但未符合条件请求。该状态码表示客户端发送附带条件的请求时（采用GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部）服务端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304。</li><li><code>307 Temporary Redirect</code>，临时重定向。与302有相同的含义。</li></ul><h4 id="301永久重定向与302临时重定向的区别"><a href="#301永久重定向与302临时重定向的区别" class="headerlink" title="301永久重定向与302临时重定向的区别"></a>301永久重定向与302临时重定向的区别</h4><ul><li>301永久重定向，新网址完全继承旧网址，旧网址的排名等完全清零</li><li>302临时重定向，搜索引擎会抓取新的内容而保留旧的网址，</li></ul><h3 id="CNAME（Canonical-Name）与HTTP重定向的区别"><a href="#CNAME（Canonical-Name）与HTTP重定向的区别" class="headerlink" title="CNAME（Canonical Name）与HTTP重定向的区别"></a>CNAME（Canonical Name）与HTTP重定向的区别</h3><p>CNAME记录只是域名的别名，多用于CDN加速，而HTTP重定向是接收到重定向报文后，将请求重新发送给重定向所指出的URL。</p><h3 id="4-客户端错误"><a href="#4-客户端错误" class="headerlink" title="4. 客户端错误"></a>4. 客户端错误</h3><ul><li><code>400 Bad Request</code>，服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。</li><li><code>401 Unauthorized</code>，该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。</li><li><code>403 Forbidden</code>，不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。</li><li><code>404 Not Found</code>，服务器上没有请求的资源。路径错误等。</li></ul><h3 id="5-服务器本身发生错误"><a href="#5-服务器本身发生错误" class="headerlink" title="5. 服务器本身发生错误"></a>5. 服务器本身发生错误</h3><ul><li><code>500 Internal Server Error</code>，该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。</li><li><code>503 Service Unavailable</code>，该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。</li></ul>]]></content>
    
    <summary type="html">
    
      HTTP状态码
    
    </summary>
    
      <category term="HTTP" scheme="http://nice2meetu.site/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://nice2meetu.site/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>js对象</title>
    <link href="http://nice2meetu.site/2020/08/23/js%E5%9F%BA%E7%A1%80/js%E5%AF%B9%E8%B1%A1/"/>
    <id>http://nice2meetu.site/2020/08/23/js基础/js对象/</id>
    <published>2020-08-23T15:39:00.000Z</published>
    <updated>2020-08-27T08:07:10.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h2><ol><li>数据属性<ul><li><code>configurable</code>：能否通过delete删除属性从而重新定义属性、能否修改属性的特性、能否把属性修改为访问器属性。对于直接在对象上定义的属性，默认为true。</li><li><code>enumerable</code>：表示能否通过for-in循环返回属性。默认为true。</li><li><code>writable</code>：表示能否修改属性的值。默认为true。</li><li><code>value</code>：包含这个属性的数据值。默认为undefined。</li></ul></li><li>访问器属性<ul><li><code>configurable</code>：表示能否通过delete删除属性从而重新定义属性、能否修改属性的特性、能否把属性修改为数据属性。对于直接在对象上定义的属性，默认为true。</li><li><code>enumerable</code>：表示能否通过for-in循环返回属性。默认为true。</li><li><code>get</code>：在读取属性时调用的函数，默认值为undefined。</li><li><code>set</code>：在写入属性时调用的函数，默认值为undefined。</li></ul></li><li>其他属性<ul><li><code>constructor</code>：对象的构造函数。</li></ul></li><li>相关方法<ul><li>定义属性描述符的方法1：<code>Object.defineProperty(对象, 属性名, 描述符对象)</code></li><li>定义属性描述符的方法2：<code>Object.defineProperties(对象, 描述符对象)</code></li><li>读取属性描述符的方法：<code>Object.getOwnPropertyDescriptor(对象, 属性名)</code></li></ul></li></ol><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1. 工厂模式"></a>1. 工厂模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure><h3 id="2-构造函数模式"><a href="#2-构造函数模式" class="headerlink" title="2. 构造函数模式"></a>2. 构造函数模式</h3><p>创建实例时实际经历的步骤：</p><ol><li>创建一个对象。</li><li>将构造函数的作用域赋给新对象</li><li>执行构造函数中的代码。</li><li>返回新对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Enigneer"</span>);</span><br></pre></td></tr></table></figure></li></ol><p>注意：</p><ol><li>构造函数始终应该以大写字母开头。</li><li>构造出的不同对象的方法并不共用同一片内存。</li></ol><h3 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3. 原型模式"></a>3. 原型模式</h3><p>创建新函数时，会为该函数创建一个prototype属性，该属性指向该函数的原型对象。默认情况下，所有的原型对象都会具有一个<code>constructor</code>属性，这个属性是一个指向<code>prototype</code>属性所在函数的指针，如下所示<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> NewFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">NewFunction.prototype.constructor === NewFunction <span class="comment">// true.</span></span><br></pre></td></tr></table></figure></p><h4 id="读取一个对象的属性，发生了什么？"><a href="#读取一个对象的属性，发生了什么？" class="headerlink" title="读取一个对象的属性，发生了什么？"></a>读取一个对象的属性，发生了什么？</h4><ol><li>首先搜索对象实例本身。如果在实例中找到了具有给定名字的属性，则返回该属性的值。</li><li>若第一步没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。</li></ol><h4 id="原型添加属性和方法"><a href="#原型添加属性和方法" class="headerlink" title="原型添加属性和方法"></a>原型添加属性和方法</h4><ol><li>通过<code>prototype</code>属性。如:<code>NewFunction.prototype.a = 1</code></li><li><p>通过对象字面量的方法，此时原型的constructor不再指向原函数，但是<code>instanceof</code>操作符仍然会返回true。可以通过显示地向对象添加constructor属性，以保证原型的constructor指向原函数。另外需要注意，使用对象字面量的方法，可能会重写原型链。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NewFunction</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">NewFunction.prototype = &#123;</span><br><span class="line">    a:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">NewFunction.prototype.constructor === NewFunction; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> newFunctionObj = <span class="keyword">new</span> NewFunction();</span><br><span class="line">newFunctionObj <span class="keyword">instanceof</span> NewFunction <span class="comment">// true</span></span><br><span class="line">NewFunction.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>:NewFunction,</span><br><span class="line">    a:1,</span><br><span class="line">&#125;</span><br><span class="line">NewFunction.prototype.<span class="keyword">constructor</span> === NewFunction; // true</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Object.defineProperty()</code>。</p></li></ol><h4 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h4><p>对原型对象所做的任何修改，都能立刻从实例上反映出来。</p><h4 id="原型相关的方法"><a href="#原型相关的方法" class="headerlink" title="原型相关的方法"></a>原型相关的方法</h4><ol><li><code>prototypeObject.prototype.isPrototypeOf(被测对象)</code> 用于prototypeObject是否存在于被测对象的原型链上。</li><li><code>Object.getPrototypeOf()</code>，用于获取指定对象的原型</li><li><code>obj.hasOwnProperty(属性名)</code>，方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性。不包括原型中的属性。</li><li><code>&quot;属性名&quot; in obj</code>，<code>in</code>操作符可检测对象是否有相应属性，不论属性在实例中还是在原型中。</li><li><code>Object.keys(obj)</code>,获取obj对象上的所有可枚举的实例属性。</li><li><code>Object.getOwnPropertyNames(obj)</code>，获取obj对象上的所有实例属性，无论是否可枚举。</li></ol><h3 id="4-组合使用构造函数模式和原型模式"><a href="#4-组合使用构造函数模式和原型模式" class="headerlink" title="4. 组合使用构造函数模式和原型模式"></a>4. 组合使用构造函数模式和原型模式</h3><p>使用构造函数模式定义实例属性，使用原型模式定义方法和共享的属性。</p><h3 id="5-动态原型模式"><a href="#5-动态原型模式" class="headerlink" title="5. 动态原型模式"></a>5. 动态原型模式</h3><p>将实例属性、原型方法和原型属性都定义在构造函数中。如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="comment">// 仅需检测一个原型中可能存在的属性或方法即可。若该属性/方法在原型中不存在，则将原型上应存在的所有属性和方法添加至原型。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName !== <span class="string">"function"</span>)&#123;</span><br><span class="line">        <span class="comment">// 也可使用instanceof，如：</span></span><br><span class="line">        <span class="comment">// if(this.sayName instanceof Function)</span></span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, nice to meet you <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-寄生构造函数模式"><a href="#6-寄生构造函数模式" class="headerlink" title="6. 寄生构造函数模式"></a>6. 寄生构造函数模式</h3><p>创建一个函数，该函数仅封装创建对象的代码，然后再返回新创建的对象。主要用来为现有的引用类型增加其他的功能，且不污染现有的引用类型。</p><p>与工厂模式有两个区别：</p><ol><li>命名上，不再采用createXxxx。</li><li>在实例化时，通过<code>new</code>运算符进行实例化，而不是仅调用方法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    values.push.apply(values,<span class="built_in">arguments</span>);</span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>);</span><br><span class="line">alert(colors.toPipedString());</span><br><span class="line">colors <span class="keyword">instanceof</span> SpecialArray <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ol><p>注意：寄生构造函数返回的对象与构造函数及构造函数的原型之间没有任何关系。</p><h3 id="7-稳妥构造函数模式"><a href="#7-稳妥构造函数模式" class="headerlink" title="7. 稳妥构造函数模式"></a>7. 稳妥构造函数模式</h3><p>稳妥对象：没有公共属性，而且其方法也不引用this。</p><p>稳妥构造函数模式不适用<code>new</code>操作符调用构造函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此处定义私有变量</span></span><br><span class="line"></span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法，是js语言实现继承的主要方法。</p><h3 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h3><ol><li>方法1：使用<code>instanceof</code></li><li>方法2：使用<code>isPrototypeOf</code>，如<code>Object.prototype.isPrototypeOf(instance)</code>;</li></ol><h3 id="原型链存在的问题"><a href="#原型链存在的问题" class="headerlink" title="原型链存在的问题"></a>原型链存在的问题</h3><ol><li>原型上引用类型值的属性，会被所有实例共享。</li><li>在不影响所有对象实例的情况下，无法给超类型的构造函数提供参数。</li></ol><h3 id="1-借用构造函数"><a href="#1-借用构造函数" class="headerlink" title="1. 借用构造函数"></a>1. 借用构造函数</h3><p>在子类型构造函数的内部调用超类型构造函数,便可以实现向超类型传递参数。</p><p>存在的问题：无法实现函数复用（因为超类型的原型中定义的方法，对于子类型而言是不可见的。）</p><h3 id="2-组合继承"><a href="#2-组合继承" class="headerlink" title="2. 组合继承"></a>2. 组合继承</h3><p>一种继承模式，将原型链和借用构造函数的技术组合到一起。主要思路为使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。</p><p>组合继承模式有两个关键步骤。在调用子类的构造函数实例化对象前，一定要先将超类挂载至子类的原型上，然后将子类原型的构造方法手动设置为子类的构造方法（因为在挂载原型时，构造方法会被覆盖）。</p><h3 id="3-原型式继承"><a href="#3-原型式继承" class="headerlink" title="3. 原型式继承"></a>3. 原型式继承</h3><p>借助原型，基于已有的对象创建新对象，同时也不必创建自定义类型。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ES6的<code>Object.craete(用作新对象原型的对象, 为新对象定义额外属性的对象)</code>api实现了原型式继承。</p><h3 id="4-寄生式继承"><a href="#4-寄生式继承" class="headerlink" title="4. 寄生式继承"></a>4. 寄生式继承</h3><p>创建一个仅用于封装继承过程的函数，使用该函数实现继承。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对象的属性&quot;&gt;&lt;a href=&quot;#对象的属性&quot; class=&quot;headerlink&quot; title=&quot;对象的属性&quot;&gt;&lt;/a&gt;对象的属性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;数据属性&lt;ul&gt;
&lt;li&gt;&lt;code&gt;configurable&lt;/code&gt;：能否通过delete删除属
      
    
    </summary>
    
      <category term="前端" scheme="http://nice2meetu.site/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://nice2meetu.site/tags/js/"/>
    
      <category term="前端" scheme="http://nice2meetu.site/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS入门</title>
    <link href="http://nice2meetu.site/2020/08/23/Node/node%E5%85%A5%E9%97%A8/"/>
    <id>http://nice2meetu.site/2020/08/23/Node/node入门/</id>
    <published>2020-08-23T07:11:50.000Z</published>
    <updated>2020-08-24T05:46:32.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建nodeJS环境。"><a href="#搭建nodeJS环境。" class="headerlink" title="搭建nodeJS环境。"></a>搭建nodeJS环境。</h1><ol><li>官网下载相应版本的NodeJS，直接安装即可。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;搭建nodeJS环境。&quot;&gt;&lt;a href=&quot;#搭建nodeJS环境。&quot; class=&quot;headerlink&quot; title=&quot;搭建nodeJS环境。&quot;&gt;&lt;/a&gt;搭建nodeJS环境。&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;官网下载相应版本的NodeJS，直接安装即可。&lt;/li&gt;
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://nice2meetu.site/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://nice2meetu.site/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>chrome浏览器的渲染过程及回流与重绘</title>
    <link href="http://nice2meetu.site/2020/08/17/%E6%B5%8F%E8%A7%88%E5%99%A8/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
    <id>http://nice2meetu.site/2020/08/17/浏览器/Chrome浏览器的渲染过程/</id>
    <published>2020-08-17T07:04:50.000Z</published>
    <updated>2020-09-02T08:57:18.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器的渲染过程分为以下几步："><a href="#浏览器的渲染过程分为以下几步：" class="headerlink" title="浏览器的渲染过程分为以下几步："></a>浏览器的渲染过程分为以下几步：</h2><p>1.解析HTML，构建DOM树<br>2.解析CSS样式表，构建CSSOM(CSS Object Model)<br>3.将DOM和CSSOM进行合并生成Render Tree(渲染树)<br>4.根据Render Tree计算布局<br>5.依据Render Tree进行渲染</p><h2 id="关于回流和重绘"><a href="#关于回流和重绘" class="headerlink" title="关于回流和重绘"></a>关于回流和重绘</h2><ol><li>回流(reflow/layout)：当Render Tree中的一部分(或所有)因为其中元素的规模尺寸、布局(计算确切位置)、隐藏等改变而需要重新构建Render Tree。即结构发生变化了。</li><li>重绘(repaint/painting)：当Render Tree中的一些元素需要更新属性，但这些属性只会影响元素的外观，风格，而不会影响布局，无需重新构建render tree。即样式发生变化了。</li></ol><p>导致回流的具体情况：</p><ul><li>添加或删除可见的DOM元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li><li>页面一开始渲染的时候（这肯定避免不了）</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li></ul><p>回流一定会触发重绘，但是重绘不一定触发回流。</p><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><ul><li>利用cssTest属性和修改class更改元素样式，避免直接修改元素样式，最小化重绘。</li><li>让DOM脱离文档流，进行修改完毕后，再回到文档流。脱离文档流后的改动不会引起回流。</li><li>现代浏览器大部分有一个队列，用于优化重排过程。而类似offsetTop的方法会强制队列刷新。所以需要避免在修改样式时直接引用以上属性，即避免触发同步布局事件。</li><li>复杂动画最好能脱离文档流。</li><li>css3硬件加速。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>谷歌开发者web基础：<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn</a></li><li>你真的了解重流和重绘吗：<a href="https://segmentfault.com/a/1190000017329980" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017329980</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浏览器的渲染过程分为以下几步：&quot;&gt;&lt;a href=&quot;#浏览器的渲染过程分为以下几步：&quot; class=&quot;headerlink&quot; title=&quot;浏览器的渲染过程分为以下几步：&quot;&gt;&lt;/a&gt;浏览器的渲染过程分为以下几步：&lt;/h2&gt;&lt;p&gt;1.解析HTML，构建DOM树&lt;br
      
    
    </summary>
    
      <category term="前端" scheme="http://nice2meetu.site/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="浏览器原理" scheme="http://nice2meetu.site/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>浏览器存储总结</title>
    <link href="http://nice2meetu.site/2020/08/17/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://nice2meetu.site/2020/08/17/浏览器/浏览器存储总结/</id>
    <published>2020-08-17T07:04:50.000Z</published>
    <updated>2020-09-03T06:36:18.771Z</updated>
    
    <content type="html"><![CDATA[<p>存储方式：</p><ol><li>localStorage</li><li>sessionStorage</li><li>cookie</li></ol><p>浏览器的存储根据上下文环境不同，涉及到几个层级关系。</p><ol><li>浏览器。firefox or chome or …</li><li>浏览器窗口。一个窗口包含一堆标签页。</li><li>浏览器标签页。<ul><li>引申：标签页之间是否同源。</li><li>引申：点击链接，进行跳转<ul><li>跳转到新的标签页。</li><li>在本标签页内跳转，不生成新页面。</li></ul></li></ul></li><li>内嵌iframe</li></ol><h2 id="1-localStorage"><a href="#1-localStorage" class="headerlink" title="1. localStorage"></a>1. localStorage</h2><p>HTML5新增。可以长期存储,只要你不清理数据就会长期存在，所以主要是存储长期的数据。</p><ul><li>生命周期：用于将数据长久保存在网站中，保存的数据没有过期时间，直到手动删除。</li><li>使用范围：同一个浏览器下的不同浏览器窗口的同源标签页之间，可以共享。</li><li>大小：因浏览器而异，大致在2.5MB到10MB之间。</li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><code>localStorage</code>对象的对象原型为<code>Storage</code>。</p><ul><li>设置localStorage：<code>localStorage.setItem(&#39;test&#39;,&#39;设置localStorage&#39;)</code></li><li>获取localStorage<ul><li>获取指定记录：<code>localStorage.getItem(&#39;test&#39;)</code></li><li>获取全部记录：<code>window.localStorage</code></li></ul></li><li>移除localStorage<ul><li>移除指定记录：<code>localStorage.removeItem(&#39;test&#39;)</code></li><li>移除全部记录：<code>localStorage.clear()</code></li></ul></li><li>获取localStorage的长度：<code>localStorage.length</code></li><li>获取某条localStorage记录的名称：<code>localStorage.key(idx)</code></li></ul><h2 id="2-sessionStorage"><a href="#2-sessionStorage" class="headerlink" title="2. sessionStorage"></a>2. sessionStorage</h2><p>HTML5新增。主要用来保存当前会话的数据。</p><ul><li>生命周期：当前窗口/标签页，刷新时不会被清空。</li><li>使用范围：当前标签页。当前标签页内跳转可以共享sessionStorage，但是通过打开新标签页跳转时不能共享。</li></ul><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p><code>sessionStorage</code>的对象原型也为<code>Storage</code>。api和localStorage几乎可以说是一模一样。</p><ul><li>设置sessionStorage：<code>sessionStorage.setItem(&#39;test&#39;,&quot;设置sessionStorage)</code></li><li>获取sessionStorage<ul><li>获取指定记录：<code>sessionStorage.getItem(&#39;test&#39;)</code></li><li>获取全部记录：<code>window.sessionStorage</code></li></ul></li><li>移除sessionStorage<ul><li>移除指定记录：<code>sessionStorage.removeItem(&#39;test&#39;)</code></li><li>移除全部记录：<code>sessionStorage.clear()</code></li></ul></li><li>获取sessionStorage的长度：<code>sessionStorage.length</code></li><li>获取某条sessionStorage记录的名称：<code>sessionStorage.key(idx)</code></li></ul><h2 id="3-cookie"><a href="#3-cookie" class="headerlink" title="3. cookie"></a>3. cookie</h2><p>cookie经常与session搭配使用。由于http协议是无状态的，而服务器如果要识别当前通信的客户，此时需要一个“通行证”，由服务器颁发给客户端，客户端以后再与后台通信时，仅需要将通行证和要传递的内容一起发给后台，后台看到通行证就会明白自己在与谁通信，然后就可以将需要的数据返回给前端。cookie和session的作用，就是此处的通行证。</p><p>生命周期：Cookie存储于电脑上的文本文件中，如果不进行清除或未打到过期时间，永远不会消失。<br>适用范围：同一个浏览器下可以共享。<br>使用场景：可以帮助我们实现记录用户个人信息的功能。Cookie经常被用于存储用户的信息，来实现记住用户名、记住密码等功能。</p><h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>设置cookie：<code>document.cookie=&quot;键值对;过期时间;cookie路径&quot;</code>，如：<code>document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;;</code></li><li>获取cookie：获取字符串格式的cookie：<code>document.cookie</code></li><li>删除cookie：为该记录设置一个已经过去的时间或者当前时间<code>document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;;</code><br>由于cookie的相关api较少，操作不方便，故使用时最好能够封装一些cookie的基本操作。</li></ul><h2 id="4-indexedDB"><a href="#4-indexedDB" class="headerlink" title="4. indexedDB"></a>4. indexedDB</h2><p>浏览器内置的大量数据存储技术。</p><p>相关教程：<a href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/indexeddb.html</a></p><h2 id="localStorage和sessionStorage的区别"><a href="#localStorage和sessionStorage的区别" class="headerlink" title="localStorage和sessionStorage的区别"></a>localStorage和sessionStorage的区别</h2><p>时效性。localStorage会一直存储在浏览器中，除非手动删除。而sessionStorage会在关闭窗口或标签页后清除，仅仅用于临时保存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;存储方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;localStorage&lt;/li&gt;
&lt;li&gt;sessionStorage&lt;/li&gt;
&lt;li&gt;cookie&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;浏览器的存储根据上下文环境不同，涉及到几个层级关系。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;浏览器。firefox
      
    
    </summary>
    
      <category term="前端" scheme="http://nice2meetu.site/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="浏览器原理" scheme="http://nice2meetu.site/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>display:none与visibility:hidden的辨析</title>
    <link href="http://nice2meetu.site/2020/08/17/css%E5%9F%BA%E7%A1%80/dispaly:none%E4%B8%8Evisibility%E7%9A%84%E8%BE%A8%E6%9E%90/"/>
    <id>http://nice2meetu.site/2020/08/17/css基础/dispaly:none与visibility的辨析/</id>
    <published>2020-08-17T03:09:30.000Z</published>
    <updated>2020-08-24T05:46:32.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>都能把网页上某个元素隐藏起来。</li></ol><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol><li>display:none隐藏的元素不占据物理空间（设置该属性的元素会产生回流，不会加入到render tree），visibility:hidden隐藏的元素占据物理空间（不会产生回流，会加入到render tree）。</li><li>display:none会跳过ol的计数器，而visibility不会跳过。</li><li>css3的transition支持visibility属性，不支持display属性。</li><li>visibility:hidden具有继承性，子元素也会继承visibility:hidden属性。display:none没有继承性。</li></ol>]]></content>
    
    <summary type="html">
    
      css的那些坑
    
    </summary>
    
      <category term="css" scheme="http://nice2meetu.site/categories/css/"/>
    
    
      <category term="css" scheme="http://nice2meetu.site/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>版本管理工具：svn小记</title>
    <link href="http://nice2meetu.site/2020/08/03/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9Asvn%E5%B0%8F%E8%AE%B0/"/>
    <id>http://nice2meetu.site/2020/08/03/版本管理工具/版本管理工具：svn小记/</id>
    <published>2020-08-03T13:35:30.000Z</published>
    <updated>2020-08-24T05:46:32.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mac使用svn-Subvision"><a href="#mac使用svn-Subvision" class="headerlink" title="mac使用svn(Subvision)"></a>mac使用svn(Subvision)</h2><p>mac自带svn，在控制台可直接使用，无需下载。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>下载项目：<code>svn checkout url(svn项目全路径) project_dir(本地项目全路径) --username=用户名 --password=密码</code></li><li>查看最近5条svn log日志：<code>svn log -l 5</code><br>该项目已遗失 (被非 svn 命令所删除) 或是不完整</li><li>svn status：执行SVN up和svn merge等命令出现在首位置的各字母含义如下：<ul><li>“ ” 无修改</li><li>“A” 新增</li><li>“C” 冲突</li><li>“D” 删除</li><li>“G” 合并</li><li>“I” 忽略</li><li>“M” 改变</li><li>“R” 替换</li><li>“X” 未纳入版本控制，但被外部定义所用</li><li>“?” 未纳入版本控制</li><li>“!” 该项目已遗失 (被非 svn 命令所删除) 或是不完整</li><li>“~” 版本控制下的项目与其它类型的项目重名</li><li>L abc.c # svn已经在.svn目录锁定了abc.c</li></ul></li></ul><h3 id="svn-update"><a href="#svn-update" class="headerlink" title="svn update"></a>svn update</h3><ul><li>A  已添加</li><li>D  已删除</li><li>U  已更新</li><li>C  合并冲突</li><li>G  合并成功</li><li>E  已存在</li></ul><h2 id="设置忽略文件"><a href="#设置忽略文件" class="headerlink" title="设置忽略文件"></a>设置忽略文件</h2><h3 id="全局设置忽略文件"><a href="#全局设置忽略文件" class="headerlink" title="全局设置忽略文件"></a>全局设置忽略文件</h3><p>找到svn的全局配置文件：<code>~/.subversion/config</code>，将<code>[miscellany]</code>段中<code>global-ignores</code>前的注释符号去掉即可。还可增加一些自己想要忽略的文件类型。</p><p>此处推荐添加的一些额外忽略文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Editor directories and files</span><br><span class="line">.idea .vscode *.iml *.suo</span><br><span class="line">*.ntvs* *.njsproj *.sln *.sw?</span><br></pre></td></tr></table></figure></p><h3 id="工程目录下设置忽略文件和目录"><a href="#工程目录下设置忽略文件和目录" class="headerlink" title="工程目录下设置忽略文件和目录"></a>工程目录下设置忽略文件和目录</h3><p>使用<code>svn propedit svn:ignore &lt;dir&gt;</code>命令。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li>官网文档：<a href="https://subversion.apache.org/docs/" target="_blank" rel="noopener">https://subversion.apache.org/docs/</a></li><li>svnbook：<a href="http://svnbook.red-bean.com/" target="_blank" rel="noopener">http://svnbook.red-bean.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      svn小记
    
    </summary>
    
      <category term="工具" scheme="http://nice2meetu.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="svn" scheme="http://nice2meetu.site/tags/svn/"/>
    
      <category term="版本管理工具" scheme="http://nice2meetu.site/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>js 命名规范</title>
    <link href="http://nice2meetu.site/2020/08/02/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%EF%BC%9Ajs/"/>
    <id>http://nice2meetu.site/2020/08/02/命名规范及最佳实践/命名规范：js/</id>
    <published>2020-08-02T01:40:30.000Z</published>
    <updated>2020-08-24T05:46:32.924Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量名："><a href="#变量名：" class="headerlink" title="变量名："></a>变量名：</h3><ul><li>变量名应为名词如car或person。</li></ul><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>语法规范：<br>任何合法的javascript标识符都可以作为函数的名称。<br>约定俗成的内容：(非ECMAScript语法，但是为了便于开发者理解和识别，约定的函数命名规范。)<br>命名方法： 小驼峰式命名法</p><ul><li>命名规范： 前缀应该为动词，常用前缀如下：<ul><li>can     判断是否可执行某个动作</li><li>has     判断是否含有某个值</li><li>is     判断是否为某个值</li><li>get     获取某个值</li><li>set     设置某个值</li><li>load     加载某些数据</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;变量名：&quot;&gt;&lt;a href=&quot;#变量名：&quot; class=&quot;headerlink&quot; title=&quot;变量名：&quot;&gt;&lt;/a&gt;变量名：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;变量名应为名词如car或person。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;函数名&quot;&gt;&lt;a href=&quot;#函数
      
    
    </summary>
    
      <category term="js" scheme="http://nice2meetu.site/categories/js/"/>
    
    
      <category term="js" scheme="http://nice2meetu.site/tags/js/"/>
    
      <category term="命名规范" scheme="http://nice2meetu.site/tags/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令小记</title>
    <link href="http://nice2meetu.site/2020/08/01/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9Agit%E5%B0%8F%E8%AE%B0/"/>
    <id>http://nice2meetu.site/2020/08/01/版本管理工具/版本管理工具：git小记/</id>
    <published>2020-08-01T13:35:30.000Z</published>
    <updated>2020-09-03T08:33:46.104Z</updated>
    
    <content type="html"><![CDATA[<p>git的常用操作及相关问题的解决方案。</p><a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>遇到git命令参数的问题，可通过查看文档解决：</p><ol><li>输入<code>git</code>后回车可以显示常用的git命令。</li><li>输入<code>git 某个命令 -h</code> 可以查看该命令具体的参数信息。</li></ol><h3 id="1-分支操作"><a href="#1-分支操作" class="headerlink" title="1. 分支操作"></a>1. 分支操作</h3><ol><li>将当前内容全部复制到一个新分支：<code>git checkout -b 新分支名称</code></li><li>删除分支：<code>git branch -d</code></li></ol><h2 id="具体问题的解决方案"><a href="#具体问题的解决方案" class="headerlink" title="具体问题的解决方案"></a>具体问题的解决方案</h2><h3 id="1-fork得到的仓库的代码如何更新使得其与原仓库的代码一致。"><a href="#1-fork得到的仓库的代码如何更新使得其与原仓库的代码一致。" class="headerlink" title="1. fork得到的仓库的代码如何更新使得其与原仓库的代码一致。"></a>1. fork得到的仓库的代码如何更新使得其与原仓库的代码一致。</h3><ol><li>配置原仓库的路径：<code>git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</code></li><li>查看远程仓库的路径，确保正确添加上游仓库：<code>git remote -v</code></li><li>抓取原仓库的修改：<code>git fetch upstream</code></li><li>其他内容：删除某个远程仓库<code>git remote remove &lt;name&gt;</code></li></ol><h3 id="2-修改commit的注释"><a href="#2-修改commit的注释" class="headerlink" title="2. 修改commit的注释"></a>2. 修改commit的注释</h3><p><code>git commit --amend</code>amend为修正的意思。</p><h3 id="3-撤销git-add"><a href="#3-撤销git-add" class="headerlink" title="3. 撤销git add"></a>3. 撤销git add</h3><p><code>git reset 文件名</code></p>]]></content>
    
    <summary type="html">
    
      git常用命令
    
    </summary>
    
      <category term="工具" scheme="http://nice2meetu.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="版本管理工具" scheme="http://nice2meetu.site/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="http://nice2meetu.site/tags/git/"/>
    
  </entry>
  
</feed>
