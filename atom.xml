<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XD</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-17T08:01:04.140Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Michael Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浏览器存储总结</title>
    <link href="http://yoursite.com/2020/08/17/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/08/17/浏览器/浏览器存储总结/</id>
    <published>2020-08-17T07:04:50.000Z</published>
    <updated>2020-08-17T08:01:04.140Z</updated>
    
    <content type="html"><![CDATA[<p>存储方式：</p><ol><li>localStorage</li><li>sessionStorage</li><li>cookie</li></ol><p>浏览器的存储根据上下文环境不同，涉及到几个层级关系。</p><ol><li>浏览器。firefox or chome or …</li><li>浏览器窗口。一个窗口包含一堆标签页。</li><li>浏览器标签页。<ul><li>引申：标签页之间是否同源。</li><li>引申：点击链接，进行跳转<ul><li>跳转到新的标签页。</li><li>在本标签页内跳转，不生成新页面。</li></ul></li></ul></li><li>内嵌iframe</li></ol><h2 id="1-localStorage"><a href="#1-localStorage" class="headerlink" title="1. localStorage"></a>1. localStorage</h2><p>HTML5新增。</p><ul><li>生命周期：用于将数据长久保存在网站中，保存的数据没有过期时间，直到手动删除。关闭浏览器呢？</li><li>使用范围：同一个浏览器下的不同浏览器窗口的同源标签页之间，可以共享。</li><li>大小：因浏览器而异，大致在2.5MB到10MB之间。</li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><code>localStorage</code>对象的对象原型为<code>Storage</code>。</p><ul><li>设置localStorage：<code>localStorage.setItem(&#39;test&#39;,&#39;设置localStorage&#39;)</code></li><li>获取localStorage<ul><li>获取指定记录：<code>localStorage.getItem(&#39;test&#39;)</code></li><li>获取全部记录：<code>window.localStorage</code></li></ul></li><li>移除localStorage<ul><li>移除指定记录：<code>localStorage.removeItem(&#39;test&#39;)</code></li><li>移除全部记录：<code>localStorage.clear()</code></li></ul></li><li>获取localStorage的长度：<code>localStorage.length</code></li><li>获取某条localStorage记录的名称：<code>localStorage.key(idx)</code></li></ul><h2 id="2-sessionStorage"><a href="#2-sessionStorage" class="headerlink" title="2. sessionStorage"></a>2. sessionStorage</h2><p>HTML5新增。</p><ul><li>生命周期：当前窗口/标签页，刷新时不会被清空。</li><li>使用范围：当前标签页。当前标签页内跳转可以共享sessionStorage，但是通过打开新标签页跳转时不能共享。</li></ul><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p><code>sessionStorage</code>的对象原型也为<code>Storage</code>。api和localStorage几乎可以说是一模一样。</p><ul><li>设置sessionStorage：<code>sessionStorage.setItem(&#39;test&#39;,&quot;设置sessionStorage)</code></li><li>获取sessionStorage<ul><li>获取指定记录：<code>sessionStorage.getItem(&#39;test&#39;)</code></li><li>获取全部记录：<code>window.sessionStorage</code></li></ul></li><li>移除sessionStorage<ul><li>移除指定记录：<code>sessionStorage.removeItem(&#39;test&#39;)</code></li><li>移除全部记录：<code>sessionStorage.clear()</code></li></ul></li><li>获取sessionStorage的长度：<code>sessionStorage.length</code></li><li>获取某条sessionStorage记录的名称：<code>sessionStorage.key(idx)</code></li></ul><h2 id="3-cookie"><a href="#3-cookie" class="headerlink" title="3. cookie"></a>3. cookie</h2><p>cookie经常与session搭配使用。由于http协议是无状态的，而服务器如果要识别当前通信的客户，此时需要一个“通行证”，由服务器颁发给客户端，客户端以后再与后台通信时，仅需要将通行证和要传递的内容一起发给后台，后台看到通行证就会明白自己在与谁通信，然后就可以将需要的数据返回给前端。cookie和session的作用，就是此处的通行证。</p><p>生命周期：Cookie存储于电脑上的文本文件中，如果不进行清除或未打到过期时间，永远不会消失。<br>适用范围：同一个浏览器下可以共享。<br>使用场景：可以帮助我们实现记录用户个人信息的功能。Cookie经常被用于存储用户的信息，来实现记住用户名、记住密码等功能。</p><h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>设置cookie：<code>document.cookie=&quot;键值对;过期时间;cookie路径&quot;</code>，如：<code>document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;;</code></li><li>获取cookie：获取字符串格式的cookie：<code>document.cookie</code></li><li>删除cookie：为该记录设置一个已经过去的时间或者当前时间<code>document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;;</code><br>由于cookie的相关api较少，操作不方便，故使用时最好能够封装一些cookie的基本操作。</li></ul><h2 id="4-indexedDB"><a href="#4-indexedDB" class="headerlink" title="4. indexedDB"></a>4. indexedDB</h2><p>浏览器内置的大量数据存储技术。</p><p>相关教程：<a href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/indexeddb.html</a></p><h2 id="localStorage和sessionStorage的区别"><a href="#localStorage和sessionStorage的区别" class="headerlink" title="localStorage和sessionStorage的区别"></a>localStorage和sessionStorage的区别</h2><p>时效性。localStorage会一直存储在浏览器中，除非手动删除。而sessionStorage会在关闭窗口或标签页后清除，仅仅用于临时保存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;存储方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;localStorage&lt;/li&gt;
&lt;li&gt;sessionStorage&lt;/li&gt;
&lt;li&gt;cookie&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;浏览器的存储根据上下文环境不同，涉及到几个层级关系。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;浏览器。firefox
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="浏览器原理" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>版本管理工具：svn小记</title>
    <link href="http://yoursite.com/2020/08/03/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9Asvn%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/08/03/版本管理工具/版本管理工具：svn小记/</id>
    <published>2020-08-03T13:35:30.000Z</published>
    <updated>2020-08-17T09:19:48.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mac使用svn-Subvision"><a href="#mac使用svn-Subvision" class="headerlink" title="mac使用svn(Subvision)"></a>mac使用svn(Subvision)</h2><p>mac自带svn，在控制台可直接使用，无需下载。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>下载项目：<code>svn checkout url(svn项目全路径) project_dir(本地项目全路径) --username=用户名 --password=密码</code></li><li>查看最近5条svn log日志：<code>svn log -l 5</code><br>该项目已遗失 (被非 svn 命令所删除) 或是不完整</li><li>svn status：执行SVN up和svn merge等命令出现在首位置的各字母含义如下：<ul><li>“ ” 无修改</li><li>“A” 新增</li><li>“C” 冲突</li><li>“D” 删除</li><li>“G” 合并</li><li>“I” 忽略</li><li>“M” 改变</li><li>“R” 替换</li><li>“X” 未纳入版本控制，但被外部定义所用</li><li>“?” 未纳入版本控制</li><li>“!” 该项目已遗失 (被非 svn 命令所删除) 或是不完整</li><li>“~” 版本控制下的项目与其它类型的项目重名</li><li>L abc.c # svn已经在.svn目录锁定了abc.c</li></ul></li></ul><h3 id="svn-update"><a href="#svn-update" class="headerlink" title="svn update"></a>svn update</h3><ul><li>A  已添加</li><li>D  已删除</li><li>U  已更新</li><li>C  合并冲突</li><li>G  合并成功</li><li>E  已存在</li></ul><h2 id="设置忽略文件"><a href="#设置忽略文件" class="headerlink" title="设置忽略文件"></a>设置忽略文件</h2><h3 id="全局设置忽略文件"><a href="#全局设置忽略文件" class="headerlink" title="全局设置忽略文件"></a>全局设置忽略文件</h3><p>找到svn的全局配置文件：<code>~/.subversion/config</code>，将<code>[miscellany]</code>段中<code>global-ignores</code>前的注释符号去掉即可。还可增加一些自己想要忽略的文件类型。</p><p>此处推荐添加的一些额外忽略文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Editor directories and files</span><br><span class="line">.idea .vscode *.iml *.suo</span><br><span class="line">*.ntvs* *.njsproj *.sln *.sw?</span><br></pre></td></tr></table></figure></p><h3 id="工程目录下设置忽略文件和目录"><a href="#工程目录下设置忽略文件和目录" class="headerlink" title="工程目录下设置忽略文件和目录"></a>工程目录下设置忽略文件和目录</h3><p>使用<code>svn propedit svn:ignore &lt;dir&gt;</code>命令。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li>官网文档：<a href="https://subversion.apache.org/docs/" target="_blank" rel="noopener">https://subversion.apache.org/docs/</a></li><li>svnbook：<a href="http://svnbook.red-bean.com/" target="_blank" rel="noopener">http://svnbook.red-bean.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      svn小记
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="版本管理工具" scheme="http://yoursite.com/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
      <category term="svn" scheme="http://yoursite.com/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>js 命名规范</title>
    <link href="http://yoursite.com/2020/08/02/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%EF%BC%9Ajs/"/>
    <id>http://yoursite.com/2020/08/02/命名规范及最佳实践/命名规范：js/</id>
    <published>2020-08-02T01:40:30.000Z</published>
    <updated>2020-08-17T08:12:50.782Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量名："><a href="#变量名：" class="headerlink" title="变量名："></a>变量名：</h3><ul><li>变量名应为名词如car或person。</li></ul><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>语法规范：<br>任何合法的javascript标识符都可以作为函数的名称。<br>约定俗成的内容：(非ECMAScript语法，但是为了便于开发者理解和识别，约定的函数命名规范。)<br>命名方法： 小驼峰式命名法</p><ul><li>命名规范： 前缀应该为动词，常用前缀如下：<ul><li>can     判断是否可执行某个动作</li><li>has     判断是否含有某个值</li><li>is     判断是否为某个值</li><li>get     获取某个值</li><li>set     设置某个值</li><li>load     加载某些数据</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;变量名：&quot;&gt;&lt;a href=&quot;#变量名：&quot; class=&quot;headerlink&quot; title=&quot;变量名：&quot;&gt;&lt;/a&gt;变量名：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;变量名应为名词如car或person。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;函数名&quot;&gt;&lt;a href=&quot;#函数
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="命名规范" scheme="http://yoursite.com/tags/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令小记</title>
    <link href="http://yoursite.com/2020/08/01/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9Agit%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/08/01/版本管理工具/版本管理工具：git小记/</id>
    <published>2020-08-01T13:35:30.000Z</published>
    <updated>2020-08-17T09:19:58.106Z</updated>
    
    <content type="html"><![CDATA[<p>git的常用操作及相关问题的解决方案。</p><a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>遇到git命令参数的问题，可通过查看文档解决：</p><ol><li>输入<code>git</code>后回车可以显示常用的git命令。</li><li>输入<code>git 某个命令 -h</code> 可以查看该命令具体的参数信息。</li></ol><h3 id="1-分支操作"><a href="#1-分支操作" class="headerlink" title="1. 分支操作"></a>1. 分支操作</h3><ol><li>将当前内容全部复制到一个新分支：<code>git checkout -b 新分支名称</code></li><li>删除分支：<code>git branch -d</code></li></ol><h2 id="具体问题的解决方案"><a href="#具体问题的解决方案" class="headerlink" title="具体问题的解决方案"></a>具体问题的解决方案</h2><h3 id="1-fork得到的仓库的代码如何更新使得其与原仓库的代码一致。"><a href="#1-fork得到的仓库的代码如何更新使得其与原仓库的代码一致。" class="headerlink" title="1. fork得到的仓库的代码如何更新使得其与原仓库的代码一致。"></a>1. fork得到的仓库的代码如何更新使得其与原仓库的代码一致。</h3><ol><li>配置原仓库的路径：<code>git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</code></li><li>查看远程仓库的路径，确保正确添加上游仓库：<code>git remote -v</code></li><li>抓取原仓库的修改：<code>git fetch upstream</code></li><li>其他内容：删除某个远程仓库<code>git remote remove &lt;name&gt;</code></li></ol><h3 id="2-修改commit的注释"><a href="#2-修改commit的注释" class="headerlink" title="2. 修改commit的注释"></a>2. 修改commit的注释</h3><p><code>git commit --amend</code>amend为修正的意思。</p><h3 id="3-撤销git-add"><a href="#3-撤销git-add" class="headerlink" title="3. 撤销git add"></a>3. 撤销git add</h3><p><code>git reset 文件名</code></p>]]></content>
    
    <summary type="html">
    
      git常用命令
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="版本管理工具" scheme="http://yoursite.com/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>js对象判空</title>
    <link href="http://yoursite.com/2020/08/01/js%E5%9F%BA%E7%A1%80/js%E5%AF%B9%E8%B1%A1%E5%88%A4%E7%A9%BA/"/>
    <id>http://yoursite.com/2020/08/01/js基础/js对象判空/</id>
    <published>2020-08-01T03:35:30.000Z</published>
    <updated>2020-08-17T09:16:00.077Z</updated>
    
    <content type="html"><![CDATA[<p>js判断一个对象为空的方法：</p><ol><li>使用JSON.stringify()。</li><li>使用<code>for in</code>。</li><li>使用Object.keys()。</li></ol><h3 id="1-使用JSON-stringify"><a href="#1-使用JSON-stringify" class="headerlink" title="1. 使用JSON.stringify()"></a>1. 使用JSON.stringify()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isObjEmpty(obj)&#123;</span><br><span class="line">    return JSON.stringify(obj) === &quot;&#123;&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用for-in"><a href="#2-使用for-in" class="headerlink" title="2. 使用for in"></a>2. 使用<code>for in</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function isObjEmpty(obj)&#123;</span><br><span class="line">    for(let attr in obj)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用Object-keys"><a href="#3-使用Object-keys" class="headerlink" title="3. 使用Object.keys()"></a>3. 使用Object.keys()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isObjEmpty(obj)&#123;</span><br><span class="line">    return Object.keys(obj).length === 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;js判断一个对象为空的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用JSON.stringify()。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;for in&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;使用Object.keys()。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;1-使用JSON-str
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>打造舒适的Mac工作环境：CLI配置</title>
    <link href="http://yoursite.com/2020/07/02/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Mac%20bash%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/07/02/环境搭建/Mac bash配置/</id>
    <published>2020-07-02T13:47:50.000Z</published>
    <updated>2020-08-17T09:18:12.042Z</updated>
    
    <content type="html"><![CDATA[<p>mac环境下的CLI终端工具及bash配置推荐。</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>CLI终端推荐：iTerm2</li><li>bash推荐：oh-my-zsh</li><li>bsah相关的命令</li></ol><h2 id="1-CLI终端推荐：iTerm2"><a href="#1-CLI终端推荐：iTerm2" class="headerlink" title="1. CLI终端推荐：iTerm2"></a>1. CLI终端推荐：iTerm2</h2><ol><li>下载地址：<a href="https://www.iterm2.com/" target="_blank" rel="noopener">https://www.iterm2.com/</a></li></ol><h3 id="实用小技巧"><a href="#实用小技巧" class="headerlink" title="实用小技巧"></a>实用小技巧</h3><ul><li>分屏：<code>command+d</code>。</li></ul><h2 id="2-bash推荐：oh-my-zsh"><a href="#2-bash推荐：oh-my-zsh" class="headerlink" title="2. bash推荐：oh-my-zsh"></a>2. bash推荐：oh-my-zsh</h2><p>oh-my-zsh是一款傻瓜化的zsh配置工具。优点：省心，功能强大。</p><ol><li>安装oh-my-zsh：<code>sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></li></ol><h3 id="2-1-插件"><a href="#2-1-插件" class="headerlink" title="2.1 插件"></a>2.1 插件</h3><p>如何安装插件？</p><ol><li>在<code>oh-my-zsh安装位置/.oh-my-zsh/custom/plugins</code>文件夹下，使用插件名创建文件夹<code>mkdir 插件名</code></li><li>将下载好的插件放入该文件夹中。</li><li>打开oh-my-zsh配置文件：<code>vim ~/.zshrc</code></li><li>在配置文件结束添加如下内容：<code>source $ZSH/custom/plugins/插件名文件夹/插件名</code>（vim中<code>shit+G</code>可以快速跳转到最后一行）</li><li>更新配置<code>source ~/.zshrc</code></li></ol><h4 id="2-1-1-git-plugin（自带插件）"><a href="#2-1-1-git-plugin（自带插件）" class="headerlink" title="2.1.1 git plugin（自带插件）"></a>2.1.1 git plugin（自带插件）</h4><p>这款插件默认开启。该插件为大量的git的命令设置了别名，</p><p>文档地址：<a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git/" target="_blank" rel="noopener">https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git/</a></p><h4 id="2-1-2-extract-plugin（自带插件）"><a href="#2-1-2-extract-plugin（自带插件）" class="headerlink" title="2.1.2 extract plugin（自带插件）"></a>2.1.2 extract plugin（自带插件）</h4><p>一款功能强大的解压软件。仅通过一个命令<code>extract</code>即可解压大部分的压缩文件，包括rar、zip、tar等。</p><p>文档地址：<a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/extract" target="_blank" rel="noopener">https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/extract</a></p><h4 id="2-1-3-自动补全插件"><a href="#2-1-3-自动补全插件" class="headerlink" title="2.1.3 自动补全插件"></a>2.1.3 自动补全插件</h4><p>这款插件可以在用户输入命令时，在光标下方提示可以使用的命令、文件等信息，再也不用为记不住linux命令名、不停地输入ls而苦恼。</p><p>插件下载地址：<a href="http://mimosa-pudica.net/src/incr-0.2.zsh" target="_blank" rel="noopener">http://mimosa-pudica.net/src/incr-0.2.zsh</a></p><h2 id="2-bash相关的命令"><a href="#2-bash相关的命令" class="headerlink" title="2. bash相关的命令"></a>2. bash相关的命令</h2><ul><li>查看当前终端使用的bash：<code>echo $SHELL</code></li><li>查看当前安装的所有bash：<code>cat /etc/shells</code></li></ul>]]></content>
    
    <summary type="html">
    
      mac工具
    
    </summary>
    
      <category term="mac" scheme="http://yoursite.com/categories/mac/"/>
    
    
      <category term="mac" scheme="http://yoursite.com/tags/mac/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>使用idea开发springboot项目生成文件的含义详解</title>
    <link href="http://yoursite.com/2020/07/01/IDE/%E4%BD%BF%E7%94%A8idea%E5%BC%80%E5%8F%91spring%20boot%E9%A1%B9%E7%9B%AE%E7%94%9F%E6%88%90%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/07/01/IDE/使用idea开发spring boot项目生成的一些文件/</id>
    <published>2020-07-01T15:35:30.000Z</published>
    <updated>2020-08-17T09:20:57.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用idea开发spring-boot项目生成的一些文件"><a href="#使用idea开发spring-boot项目生成的一些文件" class="headerlink" title="使用idea开发spring boot项目生成的一些文件"></a>使用idea开发spring boot项目生成的一些文件</h1><ul><li>.iml：idea的工程配置文件。包含当前project的一些配置信息，如模块开发的相关信息，比如java组件，maven组件，插件组件等，还可能会存储一些模块路径信息，依赖信息以及一些别的信息。</li><li>mvnw：一个执行脚本，用于命令行环境。mvnw是一个maven wrapper script,它可以让你在没有安装maven或者maven版本不兼容的条件下运行maven的命令.</li><li>mvnw.cmd：作用与mvnw相同，只是用于win环境。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用idea开发spring-boot项目生成的一些文件&quot;&gt;&lt;a href=&quot;#使用idea开发spring-boot项目生成的一些文件&quot; class=&quot;headerlink&quot; title=&quot;使用idea开发spring boot项目生成的一些文件&quot;&gt;&lt;/a&gt;使用
      
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>关于箭头函数</title>
    <link href="http://yoursite.com/2020/07/01/js%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
    <id>http://yoursite.com/2020/07/01/js基础/关于箭头函数需要注意的地方/</id>
    <published>2020-07-01T15:35:30.000Z</published>
    <updated>2020-08-17T08:08:05.619Z</updated>
    
    <content type="html"><![CDATA[<ol><li>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。</li><li>箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。&lt;/li&gt;
&lt;li&gt;箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记（二）：字符串的扩展</title>
    <link href="http://yoursite.com/2020/04/29/es6/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89:%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2020/04/29/es6/ES6学习笔记（二）:字符串的扩展/</id>
    <published>2020-04-29T06:03:50.000Z</published>
    <updated>2020-08-17T09:14:59.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="normalize-方法"><a href="#normalize-方法" class="headerlink" title="normalize()方法"></a>normalize()方法</h2><p>参数如下，注意参数必须大写！</p><ul><li>NFC(default)。标准等价合成（Normalization Form Canonical Composition）。先规范分解，然后进行规范组合。</li><li>NFD。标准等价分解（Normalization Form Canonical Decomposition）。规范分解。</li><li>NFKC。兼容等价合成（Normalization Form Compatibility Composition）。先兼容性分解，然后进行规范组合。</li><li>NFKD。兼容等价分解（Normalization Form Compatibility Decomposition）。兼容性分解。</li></ul><p>个人理解，针对字母后跟音标符号的组合，如<code>\u004F\u030C</code>，与一个标有音标符合的字符<code>\u01D1</code>，属于<strong>规范等价</strong>，因此可以用NFC和NFD。<br>兼容等价（NFKC和NFKD）包含了规范等价，但比规范等价额外包含了<strong>兼容</strong>的部分，是规范等价的超集。若两个字符完全相同的组合，如<code>\u0066\u0066</code>，与他们的单个字符表现形式<code>\uFB00</code>，他们的语义相同，则二者为兼容等价。可以使用规范化将二者变为同一形式。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><ol><li><p>NFC和NFD比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">'\u01D1'</span> <span class="comment">// Ǒ</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'\u004F\u030C'</span> <span class="comment">// Ǒ</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`str1的原始值（即赋予str1的值）为<span class="subst">$&#123;<span class="built_in">String</span>.raw<span class="string">`\u01D1`</span>&#125;</span>，显示的值为<span class="subst">$&#123;str1&#125;</span>,长度为<span class="subst">$&#123;str1.length&#125;</span>`</span>);  <span class="comment">// Ǒ</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`str2的原始值（即赋予str2的值）为<span class="subst">$&#123;<span class="built_in">String</span>.raw<span class="string">`\u004F\u030C`</span>&#125;</span>，显示的值为<span class="subst">$&#123;str2&#125;</span>,长度为<span class="subst">$&#123;str2.length&#125;</span>`</span>);  <span class="comment">// Ǒ</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`str1与str2是否相等？<span class="subst">$&#123;str1 === str2&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> params = [&#123;</span><br><span class="line">    param:<span class="string">'NFD'</span>,</span><br><span class="line">    beNorm:<span class="string">'str1'</span>,</span><br><span class="line">    beNormStr:str1,</span><br><span class="line">    beCompared:<span class="string">'str2'</span>,</span><br><span class="line">    beComparedStr:str2</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    param:<span class="string">'NFC'</span>,</span><br><span class="line">    beNorm:<span class="string">'str2'</span>,</span><br><span class="line">    beNormStr:str2,</span><br><span class="line">    beCompared:<span class="string">'str1'</span>,</span><br><span class="line">    beComparedStr:str1</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    param:<span class="string">'NFKD'</span>,</span><br><span class="line">    beNorm:<span class="string">'str1'</span>,</span><br><span class="line">    beNormStr:str1,</span><br><span class="line">    beCompared:<span class="string">'str2'</span>,</span><br><span class="line">    beComparedStr:str2</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    param:<span class="string">'NFKC'</span>,</span><br><span class="line">    beNorm:<span class="string">'str2'</span>,</span><br><span class="line">    beNormStr:str2,</span><br><span class="line">    beCompared:<span class="string">'str1'</span>,</span><br><span class="line">    beComparedStr:str1</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">params.forEach(<span class="function">(<span class="params">cur,idx</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;idx+<span class="number">1</span>&#125;</span>. 对<span class="subst">$&#123;cur.beNorm&#125;</span>进行<span class="subst">$&#123;cur.param&#125;</span>规范化`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`规范化后的<span class="subst">$&#123;cur.beNorm&#125;</span>与<span class="subst">$&#123;cur.beCompared&#125;</span>是否相等？<span class="subst">$&#123;cur.beNormStr.normalize(cur.param) === cur.beComparedStr&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`规范化前后<span class="subst">$&#123;cur.beNorm&#125;</span>的值分别为：<span class="subst">$&#123;cur.beNormStr&#125;</span>,<span class="subst">$&#123;cur.beNormStr.normalize(cur.param)&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`规范化前后<span class="subst">$&#123;cur.beNorm&#125;</span>的长度分别为：<span class="subst">$&#123;cur.beNormStr.length&#125;</span>,<span class="subst">$&#123;cur.beNormStr.normalize(cur.param).length&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>NFKC和NFKD比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">'\uFB00'</span> <span class="comment">// Ǒ</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'\u0066\u0066'</span> <span class="comment">// Ǒ</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`str1的原始值（即赋予str1的值）为<span class="subst">$&#123;<span class="built_in">String</span>.raw<span class="string">`\u01D1`</span>&#125;</span>，显示的值为<span class="subst">$&#123;str1&#125;</span>,长度为<span class="subst">$&#123;str1.length&#125;</span>`</span>);  <span class="comment">// Ǒ</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`str2的原始值（即赋予str2的值）为<span class="subst">$&#123;<span class="built_in">String</span>.raw<span class="string">`\u004F\u030C`</span>&#125;</span>，显示的值为<span class="subst">$&#123;str2&#125;</span>,长度为<span class="subst">$&#123;str2.length&#125;</span>`</span>);  <span class="comment">// Ǒ</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`str1与str2是否相等？<span class="subst">$&#123;str1 === str2&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> params = [&#123;</span><br><span class="line">    param:<span class="string">'NFD'</span>,</span><br><span class="line">    beNorm:<span class="string">'str1'</span>,</span><br><span class="line">    beNormStr:str1,</span><br><span class="line">    beCompared:<span class="string">'str2'</span>,</span><br><span class="line">    beComparedStr:str2</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    param:<span class="string">'NFC'</span>,</span><br><span class="line">    beNorm:<span class="string">'str2'</span>,</span><br><span class="line">    beNormStr:str2,</span><br><span class="line">    beCompared:<span class="string">'str1'</span>,</span><br><span class="line">    beComparedStr:str1</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    param:<span class="string">'NFKD'</span>,</span><br><span class="line">    beNorm:<span class="string">'str1'</span>,</span><br><span class="line">    beNormStr:str1,</span><br><span class="line">    beCompared:<span class="string">'str2'</span>,</span><br><span class="line">    beComparedStr:str2</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    param:<span class="string">'NFKC'</span>,</span><br><span class="line">    beNorm:<span class="string">'str2'</span>,</span><br><span class="line">    beNormStr:str2,</span><br><span class="line">    beCompared:<span class="string">'str1'</span>,</span><br><span class="line">    beComparedStr:str1</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    param:<span class="string">'NFKC'</span>,</span><br><span class="line">    beNorm:<span class="string">'str1'</span>,</span><br><span class="line">    beNormStr:str1,</span><br><span class="line">    beCompared:<span class="string">'str2'</span>,</span><br><span class="line">    beComparedStr:str2</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">params.forEach(<span class="function">(<span class="params">cur,idx</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;idx+<span class="number">1</span>&#125;</span>. 对<span class="subst">$&#123;cur.beNorm&#125;</span>进行<span class="subst">$&#123;cur.param&#125;</span>规范化`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`规范化后的<span class="subst">$&#123;cur.beNorm&#125;</span>与<span class="subst">$&#123;cur.beCompared&#125;</span>是否相等？<span class="subst">$&#123;cur.beNormStr.normalize(cur.param) === cur.beComparedStr&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`规范化前后<span class="subst">$&#123;cur.beNorm&#125;</span>的值分别为：<span class="subst">$&#123;cur.beNormStr&#125;</span>,<span class="subst">$&#123;cur.beNormStr.normalize(cur.param)&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`规范化前后<span class="subst">$&#123;cur.beNorm&#125;</span>的长度分别为：<span class="subst">$&#123;cur.beNormStr.length&#125;</span>,<span class="subst">$&#123;cur.beNormStr.normalize(cur.param).length&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>第四次比较中为什么str2没有进行组合？暂时还未解决该疑惑。</p>]]></content>
    
    <summary type="html">
    
      es6：字符串扩展内容的总结。
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>vuex学习笔记</title>
    <link href="http://yoursite.com/2020/04/24/vue/vuex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/24/vue/vuex学习笔记/</id>
    <published>2020-04-24T03:23:50.000Z</published>
    <updated>2020-08-17T09:23:43.018Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mapState辅助函数"><a href="#mapState辅助函数" class="headerlink" title="mapState辅助函数"></a>mapState辅助函数</h3><p>第一个可选参数不太懂。<br>第二个参数可以为对象或者数组。<br>数组，适用于计算属性的名称和state的名称相同时。<br>对象，key为computed的key，value如果是字符串，直接返回该字符串对应的State。如果是函数，则函数的第一个参数为state。<br>辅助函数常与扩展运算符一起用。</p><h3 id="使用常量替代-Mutation-事件类型"><a href="#使用常量替代-Mutation-事件类型" class="headerlink" title="使用常量替代 Mutation 事件类型"></a>使用常量替代 Mutation 事件类型</h3><h4 id="具体实践："><a href="#具体实践：" class="headerlink" title="具体实践："></a>具体实践：</h4><ol><li>将mutation的名称全部作为常量提取到另一个文件<code>mutations-type.js</code>，并将全部常量export。</li><li>定义mutation时，导入<code>mutations-type.js</code>文件中的常量。并且在创建vuex的mutations中全部用常量作为类型名。</li><li>触发mutation，即调用commit时，需要将调用的类型名从<code>mutations-type.js</code>中引入，并使用常量作为commit方法的类型名。</li></ol><p>优点：</p><ol><li>如果需要修改mutation的类型名，只需将常量的值进行修改即可，无需改动其他内容。降低改动成本。</li><li>可以让合作者对整个应用的mutation一目了然。即mutation是如何定义的、何处调用的commit会更加清晰。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mapState辅助函数&quot;&gt;&lt;a href=&quot;#mapState辅助函数&quot; class=&quot;headerlink&quot; title=&quot;mapState辅助函数&quot;&gt;&lt;/a&gt;mapState辅助函数&lt;/h3&gt;&lt;p&gt;第一个可选参数不太懂。&lt;br&gt;第二个参数可以为对象或者数组。
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue学习笔记：可复用性&amp;组合</title>
    <link href="http://yoursite.com/2020/04/24/vue/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0:%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7&amp;%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2020/04/24/vue/vue学习笔记:可复用性&amp;组合/</id>
    <published>2020-04-24T03:23:50.000Z</published>
    <updated>2020-08-17T09:17:20.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#1">混入（mixin）</a></li><li><a href="#2">自定义指令</a></li><li><a href="#3">渲染函数&amp;JSX</a></li><li><a href="#4">插件</a></li><li><a href="#5">过滤器</a></li></ol><h2 id="1-混入"><a href="#1-混入" class="headerlink" title="1. 混入"></a><div id="1">1. 混入</div></h2><p>Vue中使用全局变量的方案。顾名思义，混入功能可以将vue组件的一些选项如data、created、methods，置入到每一个组件中，从而被每个组件使用。混入的内容将涉及所有组件——十分混乱；混入的内容可注入到每个组件中——十分深入。</p><ul><li>选项合并：解决混入时的同名选项冲突问题。<ul><li>数据对象：递归合并，组件优先。</li><li>生命周期钩子：合并为数组，mixin中的钩子先调用。</li><li>值为对象的选项：合并为同一个对象，键名冲突时组件优先（如methods中的同名方法）。</li></ul></li><li>全局混入：即全局注册，混入的主要使用场景。</li><li>自定义选项合并策略（不太清楚这一块的作用。）</li></ul><h3 id="全局混入用法实践"><a href="#全局混入用法实践" class="headerlink" title="全局混入用法实践"></a>全局混入用法实践</h3><ul><li><p>将混入内容单独写到一个文件中，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mixin = &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg:<span class="string">"Hello~"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> mixin</span><br></pre></td></tr></table></figure></li><li><p>在main.js文件中引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mixin <span class="keyword">from</span> <span class="string">'路径/mixin.js'</span></span><br><span class="line">Vue.mixin(mixin)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-自定义指令"><a href="#2-自定义指令" class="headerlink" title="2. 自定义指令"></a>2. <div id="2">自定义指令</div></h2><p>通过自定义指令可以更方便地控制dom的样式及行为，而不仅仅局限于v-bind、v-model、v-show等。</p><ul><li>钩子函数：类似组件的生命周期。这就是钩子函数就是自定义指令的生命周期。</li><li>钩子函数参数：所绑定元素的DOM、包含指令属性的对象、vnode、上一个vnode。</li><li>对象字面量：指令函数能够接收所有合法js语句。</li></ul><h2 id="3-渲染函数"><a href="#3-渲染函数" class="headerlink" title="3. 渲染函数"></a>3. <div id="3">渲染函数</div></h2><p>通过render函数，可以使用js编写模版。有时直接使用template编写模版重复度会较高，而使用js编写可以简洁很多。<br>这一部分内容比较多，理解难度比较大，暂时没有完全吃透。</p><h2 id="4-插件"><a href="#4-插件" class="headerlink" title="4. 插件"></a>4. <div id="4">插件</div></h2><p>可以通过插件封装经常使用的重复代码，在一定程度上减少了冗余代码。</p><h2 id="5-过滤器"><a href="#5-过滤器" class="headerlink" title="5. 过滤器"></a>5. <div id="5">过滤器</div></h2><p>主要用来格式化数据。除了可以在组件内部使用filers属性定义局部过滤器之外，还可以使用Vue.filter()定义全局过滤器。<br>过滤器的声明和使用方法：<a href="https://www.cnblogs.com/yan7/p/8133897.html" target="_blank" rel="noopener">https://www.cnblogs.com/yan7/p/8133897.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;混入（mixin）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2&quot;&gt;自定义指令&lt;/a&gt;&lt;/li&gt;

      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>js学习：js遍历方法总结</title>
    <link href="http://yoursite.com/2020/04/23/js%E5%9F%BA%E7%A1%80/js%E5%AD%A6%E4%B9%A0%EF%BC%9Ajs%E9%81%8D%E5%8E%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/04/23/js基础/js学习：js遍历总结/</id>
    <published>2020-04-23T15:50:50.000Z</published>
    <updated>2020-08-17T08:03:08.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#1">遍历语句</a><ol><li><a href="#1.1">for</a></li><li><a href="#1.2">for … of</a></li><li><a href="#1.3">for … in</a></li></ol></li><li><a href="#2">数组遍历方法</a></li><li><a href="#3">其他注意事项</a><ol><li><a href="#3.1">map</a></li><li><a href="#3.2">reduce</a></li></ol></li><li><a href="#4">一些思考</a></li></ol><h2 id="1-遍历语句"><a href="#1-遍历语句" class="headerlink" title="1.遍历语句"></a><div id="1">1.遍历语句</div></h2><h2 id="1-for"><a href="#1-for" class="headerlink" title="1.for"></a><div id="1.1">1.for</div></h2><p>极其简单，极其强大，但是书写麻烦，不予赘述。</p><h2 id="2-for-…-of"><a href="#2-for-…-of" class="headerlink" title="2. for … of"></a><div id="1.2">2. for … of</div></h2><p>主要用来对可迭代对象进行迭代，注意一下不同迭代对象的迭代形式。</p><h2 id="3-for-…-in"><a href="#3-for-…-in" class="headerlink" title="3. for … in"></a><div id="1.3">3. for … in</div></h2><p><strong>以任意顺序遍历一个对象的除Symbol以外的可枚举属性</strong>，主要用来迭代对象属性以及debug。</p><h2 id="2-数组遍历方法"><a href="#2-数组遍历方法" class="headerlink" title="2. 数组遍历方法"></a><div id="2">2. 数组遍历方法</div></h2><p>注意点：</p><ol><li>遍历方法的作用。</li><li>遍历方法的参数。</li><li>表达式的返回值是什么？</li><li>能否跳出遍历？</li><li>遍历方法的推荐使用场景。</li><li>遍历过程中数组是否实时更新。换句话说：被遍历的数组在遍历时的内容是否以调用该遍历方法时为准？</li><li>遍历时传入回调函数中的元素是数组中相应项的深拷贝吗？</li></ol><table><thead><tr><th>方法名</th><th>作用</th><th>参数</th><th>返回值</th><th>能否跳出遍历</th><th>常见使用场景</th></tr></thead><tbody><tr><td>map</td><td>对数组中的每一项使用回调方法进行处理，返回处理后的元素形成的新数组</td><td>回调函数（当前处理的元素、索引、原数组），this参数</td><td>处理后的元素组成的新数组。</td><td>否</td><td>需要对一个数组进行遍历，并且需要使用遍历产生的新数组</td></tr><tr><td>filter</td><td>过滤数组，生成新数组</td><td>回调函数（当前处理的元素、索引、原数组），this参数</td><td>回调函数返回值为true的元素组成的新数组</td><td>否</td><td>个人用的较多的情况便是过滤数组</td></tr><tr><td>every</td><td>判断数组中的每一项是否能通过测试</td><td>回调函数（当前处理的元素、索引、原数组），this参数</td><td>布尔值true/false</td><td>是</td><td>个人觉得最正规的用途可能就是检测数组中的元素是否符合某个特点，符合正规用途的使用场景较窄。但是作为唯一一个可以中途跳出遍历的循环，也可以用作for循环的更简便的替代方案——但是不推荐这种用法，还是针对不同场景使用更加符合语义的遍历方式吧</td></tr><tr><td>some</td><td>判断数组中是否有一项使得回调函数的返回值为true</td><td>回调函数（当前处理的元素、索引、原数组），this参数</td><td>布尔值true/false</td><td>是</td><td>针对某个数据在数组中是否“存在”的判断</td></tr><tr><td>reduce</td><td>对数组中的元素进行遍历，同时在遍历过程中能够进行累加，最后返回累加器最后的值</td><td>回调函数（即reducer函数，包括四个参数：累加器acc，当前值cur，索引idx，被调用的数组src），累加器的初始值</td><td>reduce函数返回累加器最后的值。reducer函数的返回值由使用者定义，该返回值将被分配给累加器</td><td>否</td><td>对数字进行操、使用字符串连接函数等处理字符串，用途十分广泛</td></tr><tr><td>reduceRight</td><td>同reduce，但遍历顺序为降序，即从数组的尾部向前遍历</td><td>同reduce</td><td>同reduce</td><td>否</td><td>同reduce</td></tr><tr><td>find</td><td>返回数组中满足提供的测试函数的第一个元素的值。</td><td>回调函数（当前处理的元素、索引、原数组），this参数</td><td>数组中满足回调函数的元素的值，未命中返回<code>undefined</code></td><td>是</td><td>寻找数组中的某一项</td></tr><tr><td>findIndex</td><td>大致与find相同，只是返回的为满足测试函数的元素的索引</td><td>同find</td><td>回调函数返回值为true的元素的索引，未命中返回-1</td><td>是</td><td>同find</td></tr><tr><td>forEach</td><td>对数组的每个元素执行一次给定的函数</td><td>调函数（当前处理的元素、索引、原数组），this参数</td><td>undefined</td><td>否。可以先使用filter，再使用forEach</td><td>可以替代for循环，更简洁一些。由于该方法会跳过数组中的空数组单元，用来处理系数数组的效果较好</td></tr></tbody></table><h3 id="遍历过程中数组是否实时更新。换句话说：被遍历的数组在遍历时的内容是否为调用遍历方法时为准？"><a href="#遍历过程中数组是否实时更新。换句话说：被遍历的数组在遍历时的内容是否为调用遍历方法时为准？" class="headerlink" title="遍历过程中数组是否实时更新。换句话说：被遍历的数组在遍历时的内容是否为调用遍历方法时为准？"></a>遍历过程中数组是否实时更新。换句话说：被遍历的数组在遍历时的内容是否为调用遍历方法时为准？</h3><h4 id="map、filter、every、some、find、findIndex等"><a href="#map、filter、every、some、find、findIndex等" class="headerlink" title="map、filter、every、some、find、findIndex等"></a>map、filter、every、some、find、findIndex等</h4><p>分情况，“修改”、“删除”、“新增”的情况不同，“修改”情况又分为修改前遍历该元素和修改后遍历到该元素。</p><ul><li>遍历中修改某个元素：在遍历到某个元素之前发生变化，遍历到该元素时得到的为变化后的值。若遍历后发生修改，则修改是会反映到原数组中的，但是不会影响之前的遍历。</li><li>遍历中删除某个元素：该元素变为underfined（empty?），但仍然占据在数组中的原位置。如果方法返回的是一个新数组，同时会影响新生成的数组的该索引的元素（根据修改规则判断是否影响）。生成的数组长度不变，原数组长度也不变。</li><li>遍历中新增某个元素：在遍历时不会对其进行遍历。</li></ul><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>规则有点不同。如果数组在迭代时被修改了，则其他元素会被跳过。</p><h3 id="上述方法，遍历时传入回调函数中的元素是数组中相应项的深拷贝吗？"><a href="#上述方法，遍历时传入回调函数中的元素是数组中相应项的深拷贝吗？" class="headerlink" title="上述方法，遍历时传入回调函数中的元素是数组中相应项的深拷贝吗？"></a>上述方法，遍历时传入回调函数中的元素是数组中相应项的深拷贝吗？</h3><p>不是。</p><h2 id="3-其他注意事项"><a href="#3-其他注意事项" class="headerlink" title="3. 其他注意事项"></a><div id="3">3. 其他注意事项</div></h2><h3 id="3-1-map"><a href="#3-1-map" class="headerlink" title="3.1 map"></a><div id="3.1">3.1 map</div></h3><p>在遍历过程中一定记得写明返回值！直接更改当前遍历的内容而不反回，不会反映到遍历结束生成的数组中！比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = arr.map(<span class="function"><span class="params">i</span>=&gt;</span>&#123;i.text = <span class="string">"测试"</span>;i.value=<span class="string">"测试"</span>&#125;);       <span class="comment">// 此时b数组中所有项的值皆undefined</span></span><br><span class="line"><span class="keyword">var</span> b = arr.map(<span class="function"><span class="params">i</span>=&gt;</span>&#123;<span class="keyword">return</span> &#123;<span class="attr">text</span>:<span class="string">"测试"</span>,<span class="attr">value</span>:<span class="string">"测试"</span>&#125;&#125;)     <span class="comment">// 此时b数组所有项的值才为一个包含text和value属性的对象</span></span><br></pre></td></tr></table></figure></p><h3 id="3-2-reduce"><a href="#3-2-reduce" class="headerlink" title="3.2 reduce"></a><div id="3.2">3.2 reduce</div></h3><p>注意一下reduce函数中累加器的初始值设置。</p><h2 id="4-一些思考"><a href="#4-一些思考" class="headerlink" title="4. 一些思考"></a><div id="4">4. 一些思考</div></h2><p>for循环功能很强大，但总不能处处都用for循环。在项目中只用for可能会徒增不必要的代码，使得代码写的复杂、晦涩，存在大量重复等。代码在保证运行效率的情况下，应该足够简洁，编写的代码才会更易懂、易维护，应该针对不同的场景使用合适的遍历方法。</p>]]></content>
    
    <summary type="html">
    
      js遍历方法的汇总
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>后台代码质量检查工具：SonarQube</title>
    <link href="http://yoursite.com/2020/04/09/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%A3%80%E6%9F%A5/%E4%BD%BF%E7%94%A8SonarQube%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%A3%80%E6%9F%A5/"/>
    <id>http://yoursite.com/2020/04/09/代码质量检查/使用SonarQube进行代码质量检查/</id>
    <published>2020-04-09T03:35:30.000Z</published>
    <updated>2020-08-17T08:05:19.946Z</updated>
    
    <content type="html"><![CDATA[<p>SonarQube的安装、插件配置及个人的一些感受</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#1">安装SonarQube</a></li><li><a href="#2">配置相关插件</a><ol><li><a href="#2.1">汉化插件</a></li><li><a href="#2.2">导出代码质量检测报告插件</a></li></ol></li><li><a href="#3">其他SonarQube相关操作</a><ol><li><a href="#3.1">查看当前SonarQube版本</a></li></ol></li></ol><h2 id="1-安装SonarQube"><a href="#1-安装SonarQube" class="headerlink" title="1. 安装SonarQube"></a><span id="1">1. 安装SonarQube</span></h2><ol><li>前往SonarQube官网进行下载（推荐下载Community版本，免费，功能够用）：<a href="https://www.sonarqube.org/downloads/" target="_blank" rel="noopener">https://www.sonarqube.org/downloads/</a></li><li>下载完成后解压该文件，此处最好不要使用root用户进行解压。该步骤在官网文档的说明十分详细：<a href="https://docs.sonarqube.org/latest/setup/get-started-2-minutes/" target="_blank" rel="noopener">https://docs.sonarqube.org/latest/setup/get-started-2-minutes/</a> </li><li><p>解压后在命令行下进入解压后的文件夹，然后进入<code>bin</code>目录，该文件夹包含了不同平台下的脚本文件。如：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jsw-licensemacosx-universal-64</span><br><span class="line">linux-x86-64windows-x86-64</span><br></pre></td></tr></table></figure></li><li><p>根据自己的平台cd到相应文件夹下（博主是macos），然后输入<code>sonar.sh start</code>运行SonarQube。</p></li><li>进入SonarQube客户端界面：<a href="http://localhost:9000" target="_blank" rel="noopener">http://localhost:9000</a> </li></ol><h2 id="2-配置相关插件"><a href="#2-配置相关插件" class="headerlink" title="2. 配置相关插件"></a><span id="2">2. 配置相关插件</span></h2><h3 id="2-1-汉化插件"><a href="#2-1-汉化插件" class="headerlink" title="2.1 汉化插件"></a><span id="2.1">2.1 汉化插件</span></h3><ol><li>下载汉化插件。一定要下载相应版本，否则可能会无法启动SonarQube：<a href="https://github.com/SonarQubeCommunity/sonar-l10n-zh" target="_blank" rel="noopener">https://github.com/SonarQubeCommunity/sonar-l10n-zh</a></li><li>将下载后的插件移动到<code>sonarQube根目录/extensions/plugins</code></li><li>重启SonarQube</li></ol><h3 id="导出代码质量检测报告插件"><a href="#导出代码质量检测报告插件" class="headerlink" title="导出代码质量检测报告插件"></a><span id="2.2">导出代码质量检测报告插件</span></h3><ol><li>使用该仓库的python程序导出：<a href="https://github.com/ximone/Sonar_Report_Generator" target="_blank" rel="noopener">https://github.com/ximone/Sonar_Report_Generator</a></li></ol><h2 id="3-其他SonarQube相关操作"><a href="#3-其他SonarQube相关操作" class="headerlink" title="3. 其他SonarQube相关操作"></a><span id="3">3. 其他SonarQube相关操作</span></h2><h3 id="1-查看当前SonarQube的版本"><a href="#1-查看当前SonarQube的版本" class="headerlink" title="1. 查看当前SonarQube的版本"></a><span id="3.1">1. 查看当前SonarQube的版本</span></h3><p>在SonarQube的客户端界面选择Administration-&gt;System</p><h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><p>使用不多，课程要求才进行了初步尝试。<br>个人感觉该软件对一个软件开发团队而言意义更大一些。</p><ol><li>可以更好地帮助一个软件开发团队维护代码，使得代码编写符合内部的编码规范。</li><li>可以方便地review代码。</li></ol>]]></content>
    
    <summary type="html">
    
      使用SonarQube进行代码质量检查
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="代码质量检查" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%A3%80%E6%9F%A5/"/>
    
      <category term="SonarQube" scheme="http://yoursite.com/tags/SonarQube/"/>
    
  </entry>
  
  <entry>
    <title>js设计模式：发布订阅模式</title>
    <link href="http://yoursite.com/2020/04/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/04/08/设计模式/js设计模式：发布订阅模式/</id>
    <published>2020-04-08T13:35:30.000Z</published>
    <updated>2020-08-17T07:51:15.984Z</updated>
    
    <content type="html"><![CDATA[<p>通用实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 发布者。</span><br><span class="line">var publisherModel = &#123;</span><br><span class="line">    subscriber:&#123;&#125;,</span><br><span class="line">    listen:function(key,fn)&#123;</span><br><span class="line">        if(!this.subscriber[key])&#123;</span><br><span class="line">            this.subscriber[key] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        this.subscriber[key].push(fn);</span><br><span class="line">    &#125;,</span><br><span class="line">    publish:function()&#123;</span><br><span class="line">        let key = Array.prototype.shift.call(arguments),</span><br><span class="line">            fns = this.subscriber[key];</span><br><span class="line">        if(!fns || fns.length === 0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for(var i=0,fn;fn = fns[i++];)&#123;</span><br><span class="line">            fn.apply(this,arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 生成发布者</span><br><span class="line">var installPublisher = function(obj)&#123;</span><br><span class="line">    for(var i in publisherModel)&#123;</span><br><span class="line">        obj[i] = publisherModel[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      js设计模式
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CSS的那些坑</title>
    <link href="http://yoursite.com/2020/03/27/css%E5%9F%BA%E7%A1%80/CSS%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://yoursite.com/2020/03/27/css基础/CSS的那些坑/</id>
    <published>2020-03-27T14:05:30.000Z</published>
    <updated>2020-08-17T09:14:03.578Z</updated>
    
    <content type="html"><![CDATA[<p>css中的坑不少啊。</p><a id="more"></a><h3 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h3><ol><li>webkit内核的浏览器中，该属性不支持小于<code>12px</code>的值。若要将字体设置的更小，可以使用css3中的<code>transform:scale()</code>。</li></ol>]]></content>
    
    <summary type="html">
    
      css的那些坑
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记（一）：let和const关键字的总结</title>
    <link href="http://yoursite.com/2020/03/23/es6/ES6%EF%BC%9Alet%E5%92%8Cconst%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/03/23/es6/ES6：let和const关键字的总结/</id>
    <published>2020-03-23T06:03:50.000Z</published>
    <updated>2020-08-17T09:15:03.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="let总结"><a href="#let总结" class="headerlink" title="let总结"></a>let总结</h2><p>let关键字：其所声明的变量，只在let命令所在的代码块内有效。</p><ol><li>暂时性死区（TDZ,Temporal Dead Zone），避免了使用var时出现的变量提升现象。</li><li>不允许重复声明。</li><li>在一些场景下取代了匿名立即执行函数（IIFE）。</li><li>结合块级作用域的用法。<ul><li>块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</li><li>使用let声明的变量，块外无法引用。</li><li>块内声明定义的函数，块外无法使用。（浏览器的实现有偏差）（应该避免在块级作用域内声明函数。在一定要声明函数的情况下，采用块级作用域的形式）</li></ul></li><li>声明的全局变量，不属于顶层对象的属性</li></ol><h2 id="const总结"><a href="#const总结" class="headerlink" title="const总结"></a>const总结</h2><p>const关键字：声明只读常量。一旦声明，常量的值就不能改变。</p><p>本质：变量指向的那个内存地址所保存的数据不得改动。</p><ol><li>声明时必须初始化。</li><li>只在声明所在的块级作用域中有效。</li><li>存在暂时性死区现象。</li><li>不可重复声明。</li><li>声明的全局变量，不属于顶层对象的属性。</li></ol>]]></content>
    
    <summary type="html">
    
      es6：let关键字的总结
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="let" scheme="http://yoursite.com/tags/let/"/>
    
  </entry>
  
  <entry>
    <title>MySQL小记</title>
    <link href="http://yoursite.com/2020/03/15/mysql/Mysql%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/15/mysql/Mysql小记/</id>
    <published>2020-03-15T01:40:30.000Z</published>
    <updated>2020-08-17T09:21:23.069Z</updated>
    
    <content type="html"><![CDATA[<p>记录使用mysql时常用的语法、函数和语句。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="case-when语句"><a href="#case-when语句" class="headerlink" title="case when语句"></a>case when语句</h3><ul><li>用于计算条件列表并返回多个可能结果表达式之一。</li><li>有两种形式，<strong>简单case函数</strong>和<strong>case搜索函数</strong></li></ul><h4 id="1-简单case函数"><a href="#1-简单case函数" class="headerlink" title="1. 简单case函数"></a>1. 简单case函数</h4><p>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE input_expression</span><br><span class="line">    WHEN when_expression THEN result_expression</span><br><span class="line">        [ ...n ]</span><br><span class="line">    [</span><br><span class="line">        ELSE else_result_expression</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></p><h4 id="2-case搜索函数"><a href="#2-case搜索函数" class="headerlink" title="2. case搜索函数"></a>2. case搜索函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE   </span><br><span class="line">WHEN Boolean_expression THEN result_expression</span><br><span class="line">        [ ...n ]</span><br><span class="line">    [</span><br><span class="line">        ELSE else_result_expression</span><br><span class="line">    END</span><br></pre></td></tr></table></figure><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="1-convert"><a href="#1-convert" class="headerlink" title="1. convert()"></a>1. convert()</h3><p>把字段转换成指定类型。</p><h3 id="2-concat"><a href="#2-concat" class="headerlink" title="2. concat()"></a>2. concat()</h3><ul><li>作用：拼接字符串。</li><li>语法：concat(str1,str2)</li></ul><h3 id="3-dayofweek"><a href="#3-dayofweek" class="headerlink" title="3. dayofweek()"></a>3. dayofweek()</h3><ul><li>作用：返回指定日期的工作日索引（即指定日期是一周中的第几天）。其中1是周日，2是周一，以此类推…7是周六。</li><li>语法：dayofweek(date)</li></ul><h3 id="4-dayofmonth"><a href="#4-dayofmonth" class="headerlink" title="4. dayofmonth()"></a>4. dayofmonth()</h3><ul><li>作用：返回指定日期所在月的天数的索引（即指定日期是一个月中的第几天）。范围为1到31。</li><li>语法：dayofmonth(date)</li></ul><h3 id="5-dayofyear"><a href="#5-dayofyear" class="headerlink" title="5. dayofyear()"></a>5. dayofyear()</h3><ul><li>作用：返回指定日期date所在年的天数的索引（即指定日期是一年中的第几天）。范围为1到366。</li><li>语法：dayofyear(date)</li></ul><h3 id="6-weekofyear"><a href="#6-weekofyear" class="headerlink" title="6. weekofyear()"></a>6. weekofyear()</h3><ul><li>作用：返回指定日期所在的星期是这一年的第几个星期。范围为1到53.</li><li>语法：weekofyear(date)</li></ul><h3 id="7-adddate-date-INTERVAL-expr-unit"><a href="#7-adddate-date-INTERVAL-expr-unit" class="headerlink" title="7. adddate(date,INTERVAL expr unit)"></a>7. adddate(date,INTERVAL expr unit)</h3><ul><li>作用：修改时间。向指定的日期添加指定的时间。</li><li>语法：adddate(date,INTERVAL expr unit)</li></ul><h3 id="8-curdate"><a href="#8-curdate" class="headerlink" title="8. curdate()"></a>8. curdate()</h3><ul><li>作用：返回当前的日期。</li><li>语法：curdate()</li></ul><h3 id="9-year"><a href="#9-year" class="headerlink" title="9. year()"></a>9. year()</h3><ul><li>作用：返回指定日期的年份。</li><li>语法：year(date)</li></ul><h3 id="10-month"><a href="#10-month" class="headerlink" title="10. month()"></a>10. month()</h3><ul><li>作用：返回指定日期的月份。</li><li>语法：month(date)</li></ul><h3 id="11-quarter"><a href="#11-quarter" class="headerlink" title="11. quarter()"></a>11. quarter()</h3><ul><li>作用：返回指定日期在一年中的季度。</li><li>语法：quarter(date)</li></ul><h3 id="12-sign"><a href="#12-sign" class="headerlink" title="12. sign()"></a>12. sign()</h3><ul><li>作用：根据X是负数、零或正数，将参数的符号返回为-1、0、或1</li><li>语法：sign(x)</li></ul><h3 id="13-find-in-set"><a href="#13-find-in-set" class="headerlink" title="13. find_in_set()"></a>13. find_in_set()</h3><p>FIND_IN_SET(str,strlist)</p><p>str 要查询的字符串<br>strlist 字段名 参数以”,”分隔 如 (1,2,6,8)<br>查询字段(strlist)中包含(str)的结果，返回结果为null或记录</p><p>假如字符串str在由N个子链组成的字符串列表strlist 中，则返回值的范围在 1 到 N 之间。 一个字符串列表就是一个由一些被 ‘,’ 符号分开的子链组成的字符串。如果第一个参数是一个常数字符串，而第二个是type SET列，则FIND_IN_SET() 函数被优化，使用比特计算。 如果str不在strlist 或strlist 为空字符串，则返回值为 0 。如任意一个参数为NULL，则返回值为 NULL。这个函数在第一个参数包含一个逗号(‘,’)时将无法正常运行。</p><h2 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h2><ol><li>修改自增字段的起始值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER table table_name</span><br><span class="line">AUTO_INCREMENT=起始值</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      记录使用mysql时常用的语法、函数和语句。
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>搭建mysql环境（mac版本）</title>
    <link href="http://yoursite.com/2020/03/15/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/mac%E6%90%AD%E5%BB%BAmysql%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2020/03/15/环境搭建/mac搭建mysql环境/</id>
    <published>2020-03-15T01:24:30.000Z</published>
    <updated>2020-08-17T07:55:51.721Z</updated>
    
    <content type="html"><![CDATA[<p>简要地记录了mac系统搭建mysql数据库的过程。</p><a id="more"></a><h2 id="从官网下载安装包并进行安装"><a href="#从官网下载安装包并进行安装" class="headerlink" title="从官网下载安装包并进行安装"></a>从官网下载安装包并进行安装</h2><ol><li><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">官网</a>根据期望安装的版本号下载mysql。建议下载dmg包。</li><li>下载完成后，根据提示步骤安装。<ul><li>注意：mysql可能会生成默认密码，生成时有相应提示，请把默认密码记录下来。</li></ul></li><li>安装完毕，重启mac，可以发现系统偏好设置中添加了mysql的图标。</li><li>启动mysql服务后，在控制台输入<code>ps aux | grep mysql</code>，查找到mysql的运行路径。</li><li>根据运行路径找到mysql文件夹，并找到mysql程序的<code>bin</code>目录（即可运行的二进制文件目录）。笔者的路径为：<code>/usr/local/mysql/bin</code>。</li><li><p>添加mysql的路径至环境变量：<code>vim ~/.bash_profile</code>，添加如下内容：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MYSQL_HOME=/usr/local/mysql</span><br><span class="line">export PATH=$PATH:$MAVEN_HOME/bin:$MYSQL_HOME/bin</span><br></pre></td></tr></table></figure><p> 其中 <code>export MYSQL_HOME=/usr/local/mysql</code>和<code>export PATH=$PATH:$MYSQL_HOME/bin</code>是重点。<code>$MAVEN_HOME/bin:</code>可以忽略，这个仅仅是笔者电脑中又添加了MAVEN的环境变量。</p></li><li>运行<code>mysql -u root -p</code>，输入密码，登陆mysql，大功告成。</li></ol><h2 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a>推荐工具</h2><h3 id="图形化客户端"><a href="#图形化客户端" class="headerlink" title="图形化客户端"></a>图形化客户端</h3><p>Navicat Premium for Mac</p>]]></content>
    
    <summary type="html">
    
      搭建mysql环境（mac版本）
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="环境搭建" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>前端代码检测工具：eslint</title>
    <link href="http://yoursite.com/2020/03/11/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%A3%80%E6%9F%A5/%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7eslint%E5%88%9D%E5%8D%B0%E8%B1%A1/"/>
    <id>http://yoursite.com/2020/03/11/代码质量检查/代码检测工具eslint初印象/</id>
    <published>2020-03-11T07:04:50.000Z</published>
    <updated>2020-08-17T08:05:26.943Z</updated>
    
    <content type="html"><![CDATA[<p>eslint配置简单、功能强大，官网文档丰富、实用。</p><p>一款难得的好工具。</p><a id="more"></a><h1 id="vue项目中使用eslint（vue-cli搭建）"><a href="#vue项目中使用eslint（vue-cli搭建）" class="headerlink" title="vue项目中使用eslint（vue-cli搭建）"></a>vue项目中使用eslint（vue-cli搭建）</h1><h2 id="1-安装eslint"><a href="#1-安装eslint" class="headerlink" title="1. 安装eslint"></a>1. 安装eslint</h2><ul><li>vue-cli安装eslint：在使用vue-cli搭建vue项目时，可选择安装eslint。</li><li>手动安装eslint至当前项目：<code>npm i eslint --save-dev</code></li><li>全局安装eslint命令行工具：<code>npm i eslint -g</code></li></ul><h2 id="2-配置eslint"><a href="#2-配置eslint" class="headerlink" title="2. 配置eslint"></a>2. 配置eslint</h2><h3 id="使用vue-cli安装eslint时的配置文件"><a href="#使用vue-cli安装eslint时的配置文件" class="headerlink" title="使用vue-cli安装eslint时的配置文件"></a>使用vue-cli安装eslint时的配置文件</h3><p>vue-cli安装eslint，有两种可能的配置文件方式</p><ol><li>配置文件集成在<code>package.json</code>文件中</li><li>配置文件为<code>.eslintrc.js</code><br>二者可同时生效</li></ol><h2 id="3-配置文件内容解读"><a href="#3-配置文件内容解读" class="headerlink" title="3. 配置文件内容解读"></a>3. 配置文件内容解读</h2><p>以我使用vue-cli搭建的项目的eslint配置文件为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* eslint配置 */</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    root: <span class="literal">true</span>,     <span class="comment">// 只在项目目录中寻找eslint配置文件，禁止向父级目录寻找配置文件。</span></span><br><span class="line">    env: &#123;          <span class="comment">// 在env中指定脚本的运行环境</span></span><br><span class="line">        node: <span class="literal">true</span>  <span class="comment">// 使用 Node.js 全局变量和 Node.js 作用域。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    extends: [                  <span class="comment">// 扩展配置</span></span><br><span class="line">        <span class="string">"plugin:vue/essential"</span>, <span class="comment">// 启用esline-plugin-vue的essential配置</span></span><br><span class="line">        <span class="string">"eslint:recommended"</span>    <span class="comment">// 启用eslint推荐的规则</span></span><br><span class="line">    ],</span><br><span class="line">    parserOptions: &#123;            <span class="comment">// 解析器选项</span></span><br><span class="line">        parser: <span class="string">"babel-eslint"</span>  <span class="comment">// 一个对Babel解析器的包装，使其能够与 ESLint 兼容。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [  <span class="comment">// 插件</span></span><br><span class="line">        <span class="string">'vue'</span>,  <span class="comment">// eslint-plugin-vue插件</span></span><br><span class="line">        <span class="string">'html'</span>  <span class="comment">// eslint-plugin-html插件</span></span><br><span class="line">    ],</span><br><span class="line">    rules: &#123;    <span class="comment">// 规则</span></span><br><span class="line">        <span class="string">"no-multiple-empty-lines"</span>: [<span class="number">2</span>, &#123; <span class="string">"max"</span>: <span class="number">3</span> &#125;],   <span class="comment">// 空行不得连续超过三行。</span></span><br><span class="line">        <span class="string">"no-extra-boolean-cast"</span>: <span class="number">2</span>,  <span class="comment">// 禁止不必要的布尔类型转换</span></span><br><span class="line">        <span class="string">"no-extra-semi"</span>: <span class="number">2</span>,          <span class="comment">// 禁止使用额外的分号，禁止情况如：";;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-规则的级别"><a href="#4-规则的级别" class="headerlink" title="4. 规则的级别"></a>4. 规则的级别</h2><ol><li>“off” or 0 - 关闭规则</li><li>“warn” or 1 - 将规则视为一个警告（不会影响退出码）</li><li>“error” or 2 - 将规则视为一个错误 (退出码为1)</li></ol><blockquote><p>这三个错误级别可以允许你细粒度的控制 ESLint 是如何应用规则。（摘自官方文档）</p></blockquote><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li>eslint官方文档：<a href="https://eslint.bootcss.com/" target="_blank" rel="noopener">https://eslint.bootcss.com/</a></li><li>plugin-vue-eslint官方文档：<a href="https://eslint.vuejs.org/" target="_blank" rel="noopener">https://eslint.vuejs.org/</a></li></ul>]]></content>
    
    <summary type="html">
    
      eslint
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="代码质量检查" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%A3%80%E6%9F%A5/"/>
    
      <category term="eslint" scheme="http://yoursite.com/tags/eslint/"/>
    
  </entry>
  
  <entry>
    <title>关于异步（二）：async function</title>
    <link href="http://yoursite.com/2020/03/10/js%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8E%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/03/10/js基础/关于异步方法二/</id>
    <published>2020-03-10T07:09:00.000Z</published>
    <updated>2020-08-17T08:08:32.121Z</updated>
    
    <content type="html"><![CDATA[<p>只需要两个关键字：async、await，辅助Promise的一些方法，即可优雅地将异步请求进行串行处理。</p><p>本文主要展示async的用法。顺带将async与Promise进行比较，同时指出了setTimeout函数的一些注意事项。</p><a id="more"></a><h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2><h3 id="使用async和await将异步请求串行传里的方法"><a href="#使用async和await将异步请求串行传里的方法" class="headerlink" title="使用async和await将异步请求串行传里的方法"></a>使用async和await将异步请求串行传里的方法</h3><ol><li>首先要将包含异步操作的函数，声明为异步函数</li><li>在异步方法前加await关键字。</li></ol><h3 id="async关键字"><a href="#async关键字" class="headerlink" title="async关键字"></a>async关键字</h3><ol><li>async关键字的功能：声明异步函数。</li></ol><h3 id="await关键字"><a href="#await关键字" class="headerlink" title="await关键字"></a>await关键字</h3><ol><li>await关键字的功能：暂停异步函数的执行，等接收到Promise的执行结果后，再继续异步函数的执行。</li><li>await关键字的返回值：返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。</li><li>await关键字的使用条件：必须在async function中才能使用。</li></ol><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"准备执行异步方法..."</span>);</span><br><span class="line">    <span class="keyword">var</span> returnVal = <span class="keyword">await</span> asyncFunction();  <span class="comment">// asyncFunciton 是一个包含异步方法的函数，如包含ajax通信或setTimeout的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法执行完毕！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体示例1：串行执行异步方法"><a href="#具体示例1：串行执行异步方法" class="headerlink" title="具体示例1：串行执行异步方法"></a>具体示例1：串行执行异步方法</h2><p>只言片语可能无法很好理解，下面是一个小的示例，比较了promise的链式语法和async function的区别。</p><p>我们期望在两秒后，对value变量设置一个值，并打印其结果。但是在实现上有些条件。</p><ol><li>需要在一个方法中调用setTimeout。</li><li>在另一个方法中调用这个方法，并设置变量的值。</li></ol><p>是不是像极了平时写项目时，在一个方法中发起ajax请求，再另一个方法中调用这个请求，并接收请求返回的内容，对内容进行下一步的处理？</p><h3 id="第一种写法：一种错误的示例"><a href="#第一种写法：一种错误的示例" class="headerlink" title="第一种写法：一种错误的示例"></a>第一种写法：一种错误的示例</h3><p>不使用Promise、不使用async function，博主在什么都不懂时便写过类似的代码，但这种写法肯定不行，无法满足要求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function setValueAfter2Seconds()&#123;</span><br><span class="line">    return setTimeout(()=&gt;&#123;</span><br><span class="line">        console.log(&quot;setTimeout 执行完毕&quot;)</span><br><span class="line">        return &quot;new value&quot;</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test()&#123;</span><br><span class="line">    var value = &quot;old value&quot;;</span><br><span class="line">    console.log(&quot;准备调用&quot;);</span><br><span class="line">    value = setValueAfter2Seconds()</span><br><span class="line">    console.log(&quot;结束调用，准备打印值&quot;);</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>错误原因：</p><ol><li>注意，setTimeout回调函数的返回值和setTimeout的返回值没有任何关系！没有任何关系！没有任何关系！所以通过在setTimeout函数中进行return没有任何作用！setTimeout的返回值是一个唯一的id，用于传入给<code>clearTimeout</code>后可取消该定时器。</li><li>setTimeout方法和其他语句是异步执行的，具体原因需要了解js中的并发模型与事件循环的机制。我们只消知道setTimeout是个异步的方法即可。</li></ol><h3 id="第二种写法：Promise的写法"><a href="#第二种写法：Promise的写法" class="headerlink" title="第二种写法：Promise的写法"></a>第二种写法：Promise的写法</h3><p>使用Promise链式语法的方案如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setValueAfter2Seconds</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`setTimeout 准备执行`</span>)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`setTimeout 执行结束`</span>)</span><br><span class="line">            resolve(<span class="string">`new value`</span>);</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">"old value"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise执行函数 准备执行"</span>);</span><br><span class="line">    setValueAfter2Seconds().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Promise执行函数 执行结束"</span>);</span><br><span class="line">        value = res;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise链外部的内容仍然会先于setTimeout执行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面对代码进行分析</p><ol><li>在<code>setValueAfter2Seconds()</code>中，返回了一个Promise对象。该对象的参数为一个函数，叫做“执行函数”。执行函数接受的第一个参数resolve，是Promise的一个方法。当执行函数中的所有内容顺利完成时，将调用resolve函数，否则会调用reject函数（此处未添加，reject是执行器函数的第二个参数）。</li><li>在<code>test()</code>中，运行了<code>setValueAfter2Seconds()</code>后，执行Promise对象的then方法（<code>then()</code>即Promise的执行函数顺利完成后执行的方法），<code>then()</code>接收的参数为一个函数，被称作“处理方法（handlers）”。所有期望在<code>setValueAfter2Seconds()</code>方法执行完毕后，继续执行的代码需要写到“处理方法(handlers)”中。”处理方法”之外的语句，与Promise链中的语句仍然是异步执行（这点注意，这是Promise与async不同的最大表现之一）。</li></ol><h3 id="第三种写法：使用async"><a href="#第三种写法：使用async" class="headerlink" title="第三种写法：使用async"></a>第三种写法：使用async</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">setValueAfter2Seconds</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`setTimeout 准备执行`</span>)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`setTimeout 执行结束`</span>)</span><br><span class="line">            resolve(<span class="string">`new value`</span>);</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">"old value"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Prmomise执行函数准备执行"</span>);</span><br><span class="line">    value = <span class="keyword">await</span> setValueAfter2Seconds();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise执行函数 执行结束"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对代码进行分析：</p><ol><li>使用<code>async</code>关键字声明<code>test()</code>是一个异步函数。</li><li>使用<code>await</code>关键字暂停异步函数的执行，等待Promise执行函数运行完毕，接收Promise对象的处理结果，即resolve函数的参数<code>new value</code>，并赋值给value变量，然后执行后续的代码。</li></ol><h3 id="具体示例2：并行执行异步方法"><a href="#具体示例2：并行执行异步方法" class="headerlink" title="具体示例2：并行执行异步方法"></a>具体示例2：并行执行异步方法</h3><h3 id="Promise写法"><a href="#Promise写法" class="headerlink" title="Promise写法"></a>Promise写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncFunction1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法1 准备执行 等待时间设置为1秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法1"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法1 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> asyncFunction2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法2 准备执行 等待时间设置为2秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法2"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法2 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> concurrentPromise = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"开始并行执行异步方法"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.all([asyncFunction1(), asyncFunction2()]).then(<span class="function">(<span class="params">messages</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(messages[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">console</span>.log(messages[<span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise.all外部的内容仍然会先于setTimeout执行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="async写法1：使用Promise-all，所有异步方法执行完毕后执行后续内容。"><a href="#async写法1：使用Promise-all，所有异步方法执行完毕后执行后续内容。" class="headerlink" title="async写法1：使用Promise.all，所有异步方法执行完毕后执行后续内容。"></a>async写法1：使用Promise.all，所有异步方法执行完毕后执行后续内容。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncFunction1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法1 准备执行 等待时间设置为1秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法1"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法1 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> asyncFunction2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法2 准备执行 等待时间设置为2秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法2"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法2 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> concurrentAsync1 = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"开始并行执行异步方法"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([asyncFunction1(), asyncFunction2()]).then(<span class="function">(<span class="params">messages</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(messages[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">console</span>.log(messages[<span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise.all外部的内容与Promise.all顺序执行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="async写法2：异步方法同时执行，其他内容串行执行，遇到await时阻塞。"><a href="#async写法2：异步方法同时执行，其他内容串行执行，遇到await时阻塞。" class="headerlink" title="async写法2：异步方法同时执行，其他内容串行执行，遇到await时阻塞。"></a>async写法2：异步方法同时执行，其他内容串行执行，遇到await时阻塞。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncFunction1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法1 准备执行 等待时间设置为1秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法1"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法1 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> asyncFunction2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法2 准备执行 等待时间设置为2秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法2"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法2 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> concurrentAsync2 = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = [<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"开始并行执行异步方法"</span>);</span><br><span class="line">    </span><br><span class="line">    message[<span class="number">0</span>] = asyncFunction1();</span><br><span class="line">    message[<span class="number">1</span>] = asyncFunction2();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> message[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> message[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async1Funvtion1、asyncFunction2的并行执行，其他内容串行执行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="async-await和Promise链式写法的区别"><a href="#async-await和Promise链式写法的区别" class="headerlink" title="async await和Promise链式写法的区别"></a>async await和Promise链式写法的区别</h2><ol><li>async写法避免了Promise的链式写法。</li><li>结合使用async和Promise能发挥更大的作用。</li></ol>]]></content>
    
    <summary type="html">
    
      js异步
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js异步" scheme="http://yoursite.com/tags/js%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
</feed>
