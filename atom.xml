<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XD</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-24T03:28:41.965Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Michael Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue学习：可复用性&amp;组合</title>
    <link href="http://yoursite.com/2020/04/24/vue%E5%AD%A6%E4%B9%A0:%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7&amp;%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2020/04/24/vue学习:可复用性&amp;组合/</id>
    <published>2020-04-24T03:23:50.000Z</published>
    <updated>2020-04-24T03:28:41.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#1">混入（mixin）</a></li><li><a href="#2">自定义指令</a></li><li><a href="#3">渲染函数&amp;JSX</a></li><li><a href="#4">插件</a></li><li><a href="#5">过滤器</a></li></ol><h2 id="1-混入"><a href="#1-混入" class="headerlink" title="1. 混入"></a><div id="1">1. 混入</div></h2><p>Vue中使用全局变量的方案。顾名思义，混入功能可以将vue组件的一些选项如data、created、methods，置入到每一个组件中，从而被每个组件使用。混入的内容将涉及所有组件——十分混乱；混入的内容可注入到每个组件中——十分深入。</p><ul><li>选项合并：解决混入时的同名选项冲突问题。<ul><li>数据对象：递归合并，组件优先。</li><li>生命周期钩子：合并为数组，mixin中的钩子先调用。</li><li>值为对象的选项：合并为同一个对象，键名冲突时组件优先（如methods中的同名方法）。</li></ul></li><li>全局混入：即全局注册，混入的主要使用场景。</li><li>自定义选项合并策略（不太清楚这一块的作用。）</li></ul><h3 id="全局混入用法实践"><a href="#全局混入用法实践" class="headerlink" title="全局混入用法实践"></a>全局混入用法实践</h3><ul><li><p>将混入内容单独写到一个文件中，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mixin = &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg:<span class="string">"Hello~"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> mixin</span><br></pre></td></tr></table></figure></li><li><p>在main.js文件中引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mixin <span class="keyword">from</span> <span class="string">'路径/mixin.js'</span></span><br><span class="line">Vue.mixin(mixin)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-自定义指令"><a href="#2-自定义指令" class="headerlink" title="2. 自定义指令"></a>2. <div id="2">自定义指令</div></h2><p>通过自定义指令可以更方便地控制dom的样式及行为，而不仅仅局限于v-bind、v-model、v-show等。</p><ul><li>钩子函数：类似组件的生命周期。这就是钩子函数就是自定义指令的生命周期。</li><li>钩子函数参数：所绑定元素的DOM、包含指令属性的对象、vnode、上一个vnode。</li><li>对象字面量：指令函数能够接收所有合法js语句。</li></ul><h2 id="3-渲染函数"><a href="#3-渲染函数" class="headerlink" title="3. 渲染函数"></a>3. <div id="3">渲染函数</div></h2><p>通过render函数，可以使用js编写模版。有时直接使用template编写模版重复度会较高，而使用js编写可以简洁很多。<br>这一部分内容比较多，理解难度比较大，暂时没有完全吃透。</p><h2 id="4-插件"><a href="#4-插件" class="headerlink" title="4. 插件"></a>4. <div id="4">插件</div></h2><p>可以通过插件封装经常使用的重复代码，在一定程度上减少了冗余代码。</p><h2 id="5-过滤器"><a href="#5-过滤器" class="headerlink" title="5. 过滤器"></a>5. <div id="5">过滤器</div></h2><p>主要用来格式化数据。除了可以在组件内部使用filers属性定义局部过滤器之外，还可以使用Vue.filter()定义全局过滤器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;混入（mixin）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2&quot;&gt;自定义指令&lt;/a&gt;&lt;/li&gt;

      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>js遍历方法总结</title>
    <link href="http://yoursite.com/2020/04/23/js%E9%81%8D%E5%8E%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/04/23/js遍历总结/</id>
    <published>2020-04-23T15:50:50.000Z</published>
    <updated>2020-04-24T01:59:13.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#1">遍历语句</a><ol><li><a href="#1.1">for</a></li><li><a href="#1.2">for … of</a></li><li><a href="#1.3">for … in</a></li></ol></li><li><a href="#2">数组遍历方法</a></li><li><a href="#3">其他注意事项</a><ol><li><a href="#3.1">map</a></li><li><a href="#3.2">reduce</a></li></ol></li><li><a href="#4">一些思考</a></li></ol><h2 id="1-遍历语句"><a href="#1-遍历语句" class="headerlink" title="1.遍历语句"></a><div id="1">1.遍历语句</div></h2><h2 id="1-for"><a href="#1-for" class="headerlink" title="1.for"></a><div id="1.1">1.for</div></h2><p>极其简单，极其强大，但是书写麻烦，不予赘述。</p><h2 id="2-for-…-of"><a href="#2-for-…-of" class="headerlink" title="2. for … of"></a><div id="1.2">2. for … of</div></h2><p>主要用来对可迭代对象进行迭代，注意一下不同迭代对象的迭代形式。</p><h2 id="3-for-…-in"><a href="#3-for-…-in" class="headerlink" title="3. for … in"></a><div id="1.3">3. for … in</div></h2><p><strong>以任意顺序遍历一个对象的除Symbol以外的可枚举属性</strong>，主要用来迭代对象属性以及debug。</p><h2 id="2-数组遍历方法"><a href="#2-数组遍历方法" class="headerlink" title="2. 数组遍历方法"></a><div id="2">2. 数组遍历方法</div></h2><p>注意点：</p><ol><li>遍历方法的作用。</li><li>遍历方法的参数。</li><li>表达式的返回值是什么？</li><li>能否跳出遍历？</li><li>遍历方法的推荐使用场景。</li><li>遍历过程中数组是否实时更新。换句话说：被遍历的数组在遍历时的内容是否以调用该遍历方法时为准？</li><li>遍历时传入回调函数中的元素是数组中相应项的深拷贝吗？</li></ol><table><thead><tr><th>方法名</th><th>作用</th><th>参数</th><th>返回值</th><th>能否跳出遍历</th><th>常见使用场景</th></tr></thead><tbody><tr><td>map</td><td>对数组中的每一项使用回调方法进行处理，返回处理后的元素形成的新数组</td><td>回调函数（当前处理的元素、索引、原数组），this参数</td><td>处理后的元素组成的新数组。</td><td>否</td><td>需要对一个数组进行遍历，并且需要使用遍历产生的新数组</td></tr><tr><td>filter</td><td>过滤数组，生成新数组</td><td>回调函数（当前处理的元素、索引、原数组），this参数</td><td>回调函数返回值为true的元素组成的新数组</td><td>否</td><td>个人用的较多的情况便是过滤数组</td></tr><tr><td>every</td><td>判断数组中的每一项是否能通过测试</td><td>回调函数（当前处理的元素、索引、原数组），this参数</td><td>布尔值true/false</td><td>是</td><td>个人觉得最正规的用途可能就是检测数组中的元素是否符合某个特点，符合正规用途的使用场景较窄。但是作为唯一一个可以中途跳出遍历的循环，也可以用作for循环的更简便的替代方案——但是不推荐这种用法，还是针对不同场景使用更加符合语义的遍历方式吧</td></tr><tr><td>some</td><td>判断数组中是否有一项使得回调函数的返回值为true</td><td>回调函数（当前处理的元素、索引、原数组），this参数</td><td>布尔值true/false</td><td>是</td><td>针对某个数据在数组中是否“存在”的判断</td></tr><tr><td>reduce</td><td>对数组中的元素进行遍历，同时在遍历过程中能够进行累加，最后返回累加器最后的值</td><td>回调函数（即reducer函数，包括四个参数：累加器acc，当前值cur，索引idx，被调用的数组src），累加器的初始值</td><td>reduce函数返回累加器最后的值。reducer函数的返回值由使用者定义，该返回值将被分配给累加器</td><td>否</td><td>对数字进行操、使用字符串连接函数等处理字符串，用途十分广泛</td></tr><tr><td>reduceRight</td><td>同reduce，但遍历顺序为降序，即从数组的尾部向前遍历</td><td>同reduce</td><td>同reduce</td><td>否</td><td>同reduce</td></tr><tr><td>find</td><td>返回数组中满足提供的测试函数的第一个元素的值。若无元素满足否则返回<code>undefined</code></td><td>回调函数（当前处理的元素、索引、原数组），this参数</td><td>数组中满足回调函数的元素的值</td><td>是</td><td>寻找数组中的某一项</td></tr><tr><td>findIndex</td><td>大致与find相同，只是返回的为满足测试函数的元素的索引</td><td>同find</td><td>同find</td><td>是</td><td>同find</td></tr><tr><td>forEach</td><td>对数组的每个元素执行一次给定的函数</td><td>调函数（当前处理的元素、索引、原数组），this参数</td><td>undefined</td><td>否。可以先使用filter，再使用forEach</td><td>可以替代for循环，更简洁一些。由于该方法会跳过数组中的空数组单元，用来处理系数数组的效果较好</td></tr></tbody></table><h3 id="遍历过程中数组是否实时更新。换句话说：被遍历的数组在遍历时的内容是否为调用遍历方法时为准？"><a href="#遍历过程中数组是否实时更新。换句话说：被遍历的数组在遍历时的内容是否为调用遍历方法时为准？" class="headerlink" title="遍历过程中数组是否实时更新。换句话说：被遍历的数组在遍历时的内容是否为调用遍历方法时为准？"></a>遍历过程中数组是否实时更新。换句话说：被遍历的数组在遍历时的内容是否为调用遍历方法时为准？</h3><h4 id="map、filter、every、some、find、findIndex等"><a href="#map、filter、every、some、find、findIndex等" class="headerlink" title="map、filter、every、some、find、findIndex等"></a>map、filter、every、some、find、findIndex等</h4><p>分情况，“修改”、“删除”、“新增”的情况不同，“修改”情况又分为修改前遍历该元素和修改后遍历到该元素。</p><ul><li>遍历中修改某个元素：在遍历到某个元素之前发生变化，遍历到该元素时得到的为变化后的值。若遍历后发生修改，则修改是会反映到原数组中的，但是不会影响之前的遍历。</li><li>遍历中删除某个元素：该元素变为underfined（empty?），但仍然占据在数组中的原位置。如果方法返回的是一个新数组，同时会影响新生成的数组的该索引的元素（根据修改规则判断是否影响）。生成的数组长度不变，原数组长度也不变。</li><li>遍历中新增某个元素：在遍历时不会对其进行遍历。</li></ul><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>规则有点不同。如果数组在迭代时被修改了，则其他元素会被跳过。</p><h3 id="上述方法，遍历时传入回调函数中的元素是数组中相应项的深拷贝吗？"><a href="#上述方法，遍历时传入回调函数中的元素是数组中相应项的深拷贝吗？" class="headerlink" title="上述方法，遍历时传入回调函数中的元素是数组中相应项的深拷贝吗？"></a>上述方法，遍历时传入回调函数中的元素是数组中相应项的深拷贝吗？</h3><p>不是。</p><h2 id="3-其他注意事项"><a href="#3-其他注意事项" class="headerlink" title="3. 其他注意事项"></a><div id="3">3. 其他注意事项</div></h2><h3 id="3-1-map"><a href="#3-1-map" class="headerlink" title="3.1 map"></a><div id="3.1">3.1 map</div></h3><p>在遍历过程中一定记得写明返回值！直接更改当前遍历的内容而不反回，不会反映到遍历结束生成的数组中！比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = arr.map(<span class="function"><span class="params">i</span>=&gt;</span>&#123;i.text = <span class="string">"测试"</span>;i.value=<span class="string">"测试"</span>&#125;);       <span class="comment">// 此时b数组中所有项的值皆undefined</span></span><br><span class="line"><span class="keyword">var</span> b = arr.map(<span class="function"><span class="params">i</span>=&gt;</span>&#123;<span class="keyword">return</span> &#123;<span class="attr">text</span>:<span class="string">"测试"</span>,<span class="attr">value</span>:<span class="string">"测试"</span>&#125;&#125;)     <span class="comment">// 此时b数组所有项的值才为一个包含text和value属性的对象</span></span><br></pre></td></tr></table></figure></p><h3 id="3-2-reduce"><a href="#3-2-reduce" class="headerlink" title="3.2 reduce"></a><div id="3.2">3.2 reduce</div></h3><p>注意一下reduce函数中累加器的初始值设置。</p><h2 id="4-一些思考"><a href="#4-一些思考" class="headerlink" title="4. 一些思考"></a><div id="4">4. 一些思考</div></h2><p>for循环功能很强大，但总不能处处都用for循环。在项目中只用for可能会徒增不必要的代码，使得代码写的复杂、晦涩，存在大量重复等。代码在保证运行效率的情况下，应该足够简洁，编写的代码才会更易懂、易维护，应该针对不同的场景使用合适的遍历方法。</p>]]></content>
    
    <summary type="html">
    
      js遍历方法的汇总
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>使用SonarQube进行代码质量检查</title>
    <link href="http://yoursite.com/2020/04/09/%E4%BD%BF%E7%94%A8SonarQube%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%A3%80%E6%9F%A5/"/>
    <id>http://yoursite.com/2020/04/09/使用SonarQube进行代码质量检查/</id>
    <published>2020-04-09T03:35:30.000Z</published>
    <updated>2020-04-09T13:22:57.220Z</updated>
    
    <content type="html"><![CDATA[<p>SonarQube的安装、插件配置及个人的一些感受</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#1">安装SonarQube</a></li><li><a href="#2">配置相关插件</a><ol><li><a href="#2.1">汉化插件</a></li><li><a href="#2.2">导出代码质量检测报告插件</a></li></ol></li><li><a href="#3">其他SonarQube相关操作</a><ol><li><a href="#3.1">查看当前SonarQube版本</a></li></ol></li></ol><h2 id="1-安装SonarQube"><a href="#1-安装SonarQube" class="headerlink" title="1. 安装SonarQube"></a><span id="1">1. 安装SonarQube</span></h2><ol><li>前往SonarQube官网进行下载（推荐下载Community版本，免费，功能够用）：<a href="https://www.sonarqube.org/downloads/" target="_blank" rel="noopener">https://www.sonarqube.org/downloads/</a></li><li>下载完成后解压该文件，此处最好不要使用root用户进行解压。该步骤在官网文档的说明十分详细：<a href="https://docs.sonarqube.org/latest/setup/get-started-2-minutes/" target="_blank" rel="noopener">https://docs.sonarqube.org/latest/setup/get-started-2-minutes/</a> </li><li><p>解压后在命令行下进入解压后的文件夹，然后进入<code>bin</code>目录，该文件夹包含了不同平台下的脚本文件。如：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jsw-licensemacosx-universal-64</span><br><span class="line">linux-x86-64windows-x86-64</span><br></pre></td></tr></table></figure></li><li><p>根据自己的平台cd到相应文件夹下（博主是macos），然后输入<code>sonar.sh start</code>运行SonarQube。</p></li><li>进入SonarQube客户端界面：<a href="http://localhost:9000" target="_blank" rel="noopener">http://localhost:9000</a> </li></ol><h2 id="2-配置相关插件"><a href="#2-配置相关插件" class="headerlink" title="2. 配置相关插件"></a><span id="2">2. 配置相关插件</span></h2><h3 id="2-1-汉化插件"><a href="#2-1-汉化插件" class="headerlink" title="2.1 汉化插件"></a><span id="2.1">2.1 汉化插件</span></h3><ol><li>下载汉化插件。一定要下载相应版本，否则可能会无法启动SonarQube：<a href="https://github.com/SonarQubeCommunity/sonar-l10n-zh" target="_blank" rel="noopener">https://github.com/SonarQubeCommunity/sonar-l10n-zh</a></li><li>将下载后的插件移动到<code>sonarQube根目录/extensions/plugins</code></li><li>重启SonarQube</li></ol><h3 id="导出代码质量检测报告插件"><a href="#导出代码质量检测报告插件" class="headerlink" title="导出代码质量检测报告插件"></a><span id="2.2">导出代码质量检测报告插件</span></h3><ol><li>使用该仓库的python程序导出：<a href="https://github.com/ximone/Sonar_Report_Generator" target="_blank" rel="noopener">https://github.com/ximone/Sonar_Report_Generator</a></li></ol><h2 id="3-其他SonarQube相关操作"><a href="#3-其他SonarQube相关操作" class="headerlink" title="3. 其他SonarQube相关操作"></a><span id="3">3. 其他SonarQube相关操作</span></h2><h3 id="1-查看当前SonarQube的版本"><a href="#1-查看当前SonarQube的版本" class="headerlink" title="1. 查看当前SonarQube的版本"></a><span id="3.1">1. 查看当前SonarQube的版本</span></h3><p>在SonarQube的客户端界面选择Administration-&gt;System</p><h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><p>使用不多，课程要求才进行了初步尝试。<br>个人感觉该软件对一个软件开发团队而言意义更大一些。</p><ol><li>可以更好地帮助一个软件开发团队维护代码，使得代码编写符合内部的编码规范。</li><li>可以方便地review代码。</li></ol>]]></content>
    
    <summary type="html">
    
      使用SonarQube进行代码质量检查
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="代码质量检查" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%A3%80%E6%9F%A5/"/>
    
      <category term="SonarQube" scheme="http://yoursite.com/tags/SonarQube/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令小记</title>
    <link href="http://yoursite.com/2020/04/08/git%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/08/git小记/</id>
    <published>2020-04-08T13:35:30.000Z</published>
    <updated>2020-04-22T15:46:26.189Z</updated>
    
    <content type="html"><![CDATA[<p>git的常用操作及相关问题的解决方案。</p><a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>遇到git命令参数的问题，可通过查看文档解决：</p><ol><li>输入<code>git</code>后回车可以显示常用的git命令。</li><li>输入<code>git 某个命令 -h</code> 可以查看该命令具体的参数信息。</li></ol><h3 id="1-分支操作"><a href="#1-分支操作" class="headerlink" title="1. 分支操作"></a>1. 分支操作</h3><ol><li>将当前内容全部复制到一个新分支：<code>git checkout -b 新分支名称</code></li><li>删除分支：<code>git branch -d</code></li></ol><h2 id="具体问题的解决方案"><a href="#具体问题的解决方案" class="headerlink" title="具体问题的解决方案"></a>具体问题的解决方案</h2><h3 id="1-fork得到的仓库的代码如何更新使得其与原仓库的代码一致。"><a href="#1-fork得到的仓库的代码如何更新使得其与原仓库的代码一致。" class="headerlink" title="1. fork得到的仓库的代码如何更新使得其与原仓库的代码一致。"></a>1. fork得到的仓库的代码如何更新使得其与原仓库的代码一致。</h3><ol><li>配置原仓库的路径：<code>git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</code></li><li>查看远程仓库的路径，确保正确添加上游仓库：<code>git remote -v</code></li><li>抓取原仓库的修改：<code>git fetch upstream</code></li><li>其他内容：删除某个远程仓库<code>git remote remove &lt;name&gt;</code></li></ol>]]></content>
    
    <summary type="html">
    
      git常用命令
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="版本管理工具" scheme="http://yoursite.com/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>CSS的那些坑</title>
    <link href="http://yoursite.com/2020/03/27/CSS%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://yoursite.com/2020/03/27/CSS的那些坑/</id>
    <published>2020-03-27T14:05:30.000Z</published>
    <updated>2020-04-22T15:46:08.697Z</updated>
    
    <content type="html"><![CDATA[<p>css中的坑不少啊。</p><a id="more"></a><h3 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h3><ol><li>webkit内核的浏览器中，该属性不支持小于<code>12px</code>的值。若要将字体设置的更小，可以使用css3中的<code>transform:scale()</code>。</li></ol>]]></content>
    
    <summary type="html">
    
      css的那些坑
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>ES6：let和const关键字的总结</title>
    <link href="http://yoursite.com/2020/03/23/ES6%EF%BC%9Alet%E5%92%8Cconst%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/03/23/ES6：let和const关键字的总结/</id>
    <published>2020-03-23T06:03:50.000Z</published>
    <updated>2020-04-22T15:47:02.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="let总结"><a href="#let总结" class="headerlink" title="let总结"></a>let总结</h2><p>let关键字：其所声明的变量，只在let命令所在的代码块内有效。</p><ol><li>暂时性死区（TDZ,Temporal Dead Zone），避免了使用var时出现的变量提升现象。</li><li>不允许重复声明。</li><li>在一些场景下取代了匿名立即执行函数（IIFE）。</li><li>结合块级作用域的用法。<ul><li>块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</li><li>使用let声明的变量，块外无法引用。</li><li>块内声明定义的函数，块外无法使用。（浏览器的实现有偏差）（应该避免在块级作用域内声明函数。在一定要声明函数的情况下，采用块级作用域的形式）</li></ul></li><li>声明的全局变量，不属于顶层对象的属性</li></ol><h2 id="const总结"><a href="#const总结" class="headerlink" title="const总结"></a>const总结</h2><p>const关键字：声明只读常量。一旦声明，常量的值就不能改变。</p><p>本质：变量指向的那个内存地址所保存的数据不得改动。</p><ol><li>声明时必须初始化。</li><li>只在声明所在的块级作用域中有效。</li><li>存在暂时性死区现象。</li><li>不可重复声明。</li><li>声明的全局变量，不属于顶层对象的属性。</li></ol>]]></content>
    
    <summary type="html">
    
      es6：let关键字的总结s
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="let" scheme="http://yoursite.com/tags/let/"/>
    
  </entry>
  
  <entry>
    <title>MySQL小记</title>
    <link href="http://yoursite.com/2020/03/15/Mysql%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/15/Mysql小记/</id>
    <published>2020-03-15T01:40:30.000Z</published>
    <updated>2020-04-22T15:45:28.983Z</updated>
    
    <content type="html"><![CDATA[<p>记录使用mysql时常用的语法、函数和语句。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="case-when语句"><a href="#case-when语句" class="headerlink" title="case when语句"></a>case when语句</h3><ul><li>用于计算条件列表并返回多个可能结果表达式之一。</li><li>有两种形式，<strong>简单case函数</strong>和<strong>case搜索函数</strong></li></ul><h4 id="1-简单case函数"><a href="#1-简单case函数" class="headerlink" title="1. 简单case函数"></a>1. 简单case函数</h4><p>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE input_expression</span><br><span class="line">    WHEN when_expression THEN result_expression</span><br><span class="line">        [ ...n ]</span><br><span class="line">    [</span><br><span class="line">        ELSE else_result_expression</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></p><h4 id="2-case搜索函数"><a href="#2-case搜索函数" class="headerlink" title="2. case搜索函数"></a>2. case搜索函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE   </span><br><span class="line">WHEN Boolean_expression THEN result_expression</span><br><span class="line">        [ ...n ]</span><br><span class="line">    [</span><br><span class="line">        ELSE else_result_expression</span><br><span class="line">    END</span><br></pre></td></tr></table></figure><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="1-convert"><a href="#1-convert" class="headerlink" title="1. convert()"></a>1. convert()</h3><p>把字段转换成指定类型。</p><h3 id="2-concat"><a href="#2-concat" class="headerlink" title="2. concat()"></a>2. concat()</h3><ul><li>作用：拼接字符串。</li><li>语法：concat(str1,str2)</li></ul><h3 id="3-dayofweek"><a href="#3-dayofweek" class="headerlink" title="3. dayofweek()"></a>3. dayofweek()</h3><ul><li>作用：返回指定日期的工作日索引（即指定日期是一周中的第几天）。其中1是周日，2是周一，以此类推…7是周六。</li><li>语法：dayofweek(date)</li></ul><h3 id="4-dayofmonth"><a href="#4-dayofmonth" class="headerlink" title="4. dayofmonth()"></a>4. dayofmonth()</h3><ul><li>作用：返回指定日期所在月的天数的索引（即指定日期是一个月中的第几天）。范围为1到31。</li><li>语法：dayofmonth(date)</li></ul><h3 id="5-dayofyear"><a href="#5-dayofyear" class="headerlink" title="5. dayofyear()"></a>5. dayofyear()</h3><ul><li>作用：返回指定日期date所在年的天数的索引（即指定日期是一年中的第几天）。范围为1到366。</li><li>语法：dayofyear(date)</li></ul><h3 id="6-weekofyear"><a href="#6-weekofyear" class="headerlink" title="6. weekofyear()"></a>6. weekofyear()</h3><ul><li>作用：返回指定日期所在的星期是这一年的第几个星期。范围为1到53.</li><li>语法：weekofyear(date)</li></ul><h3 id="7-adddate-date-INTERVAL-expr-unit"><a href="#7-adddate-date-INTERVAL-expr-unit" class="headerlink" title="7. adddate(date,INTERVAL expr unit)"></a>7. adddate(date,INTERVAL expr unit)</h3><ul><li>作用：修改时间。向指定的日期添加指定的时间。</li><li>语法：adddate(date,INTERVAL expr unit)</li></ul><h3 id="8-curdate"><a href="#8-curdate" class="headerlink" title="8. curdate()"></a>8. curdate()</h3><ul><li>作用：返回当前的日期。</li><li>语法：curdate()</li></ul><h3 id="9-year"><a href="#9-year" class="headerlink" title="9. year()"></a>9. year()</h3><ul><li>作用：返回指定日期的年份。</li><li>语法：year(date)</li></ul><h3 id="10-month"><a href="#10-month" class="headerlink" title="10. month()"></a>10. month()</h3><ul><li>作用：返回指定日期的月份。</li><li>语法：month(date)</li></ul><h3 id="11-quarter"><a href="#11-quarter" class="headerlink" title="11. quarter()"></a>11. quarter()</h3><ul><li>作用：返回指定日期在一年中的季度。</li><li>语法：quarter(date)</li></ul><h3 id="12-sign"><a href="#12-sign" class="headerlink" title="12. sign()"></a>12. sign()</h3><ul><li>作用：根据X是负数、零或正数，将参数的符号返回为-1、0、或1</li><li>语法：sign(x)</li></ul><h2 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h2><ol><li>修改自增字段的起始值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER table table_name</span><br><span class="line">AUTO_INCREMENT=起始值</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      记录使用mysql时常用的语法、函数和语句。
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>搭建mysql环境（mac版本）</title>
    <link href="http://yoursite.com/2020/03/15/mac%E6%90%AD%E5%BB%BAmysql%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2020/03/15/mac搭建mysql环境/</id>
    <published>2020-03-15T01:24:30.000Z</published>
    <updated>2020-03-27T14:02:14.442Z</updated>
    
    <content type="html"><![CDATA[<p>简要地记录了mac系统搭建mysql数据库的过程。</p><a id="more"></a><h2 id="从官网下载安装包并进行安装"><a href="#从官网下载安装包并进行安装" class="headerlink" title="从官网下载安装包并进行安装"></a>从官网下载安装包并进行安装</h2><ol><li><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">官网</a>根据期望安装的版本号下载mysql。建议下载dmg包。</li><li>下载完成后，根据提示步骤安装。<ul><li>注意：mysql可能会生成默认密码，生成时有相应提示，请把默认密码记录下来。</li></ul></li><li>安装完毕，重启mac，可以发现系统偏好设置中添加了mysql的图标。</li><li>启动mysql服务后，在控制台输入<code>ps aux | grep mysql</code>，查找到mysql的运行路径。</li><li>根据运行路径找到mysql文件夹，并找到mysql程序的<code>bin</code>目录（即可运行的二进制文件目录）。笔者的路径为：<code>/usr/local/mysql/bin</code>。</li><li><p>添加mysql的路径至环境变量：<code>vim ~/.bash_profile</code>，添加如下内容：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MYSQL_HOME=/usr/local/mysql</span><br><span class="line">export PATH=$PATH:$MAVEN_HOME/bin:$MYSQL_HOME/bin</span><br></pre></td></tr></table></figure><p> 其中 <code>export MYSQL_HOME=/usr/local/mysql</code>和<code>export PATH=$PATH:$MYSQL_HOME/bin</code>是重点。<code>$MAVEN_HOME/bin:</code>可以忽略，这个仅仅是笔者电脑中又添加了MAVEN的环境变量。</p></li><li>运行<code>mysql -u root -p</code>，输入密码，登陆mysql，大功告成。</li></ol><h2 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a>推荐工具</h2><h3 id="图形化客户端"><a href="#图形化客户端" class="headerlink" title="图形化客户端"></a>图形化客户端</h3><p>Navicat Premium for Mac</p>]]></content>
    
    <summary type="html">
    
      搭建mysql环境（mac版本）
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="环境搭建" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>代码检测工具：eslint 初次使用</title>
    <link href="http://yoursite.com/2020/03/11/%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7eslint%E5%88%9D%E5%8D%B0%E8%B1%A1/"/>
    <id>http://yoursite.com/2020/03/11/代码检测工具eslint初印象/</id>
    <published>2020-03-11T07:04:50.000Z</published>
    <updated>2020-03-23T06:03:50.394Z</updated>
    
    <content type="html"><![CDATA[<p>eslint配置简单、功能强大，官网文档丰富、实用。</p><p>一款难得的好工具。</p><a id="more"></a><h1 id="vue项目中使用eslint（vue-cli搭建）"><a href="#vue项目中使用eslint（vue-cli搭建）" class="headerlink" title="vue项目中使用eslint（vue-cli搭建）"></a>vue项目中使用eslint（vue-cli搭建）</h1><h2 id="1-安装eslint"><a href="#1-安装eslint" class="headerlink" title="1. 安装eslint"></a>1. 安装eslint</h2><ul><li>vue-cli安装eslint：在使用vue-cli搭建vue项目时，可选择安装eslint。</li><li>手动安装eslint至当前项目：<code>npm i eslint --save-dev</code></li><li>全局安装eslint命令行工具：<code>npm i eslint -g</code></li></ul><h2 id="2-配置eslint"><a href="#2-配置eslint" class="headerlink" title="2. 配置eslint"></a>2. 配置eslint</h2><h3 id="使用vue-cli安装eslint时的配置文件"><a href="#使用vue-cli安装eslint时的配置文件" class="headerlink" title="使用vue-cli安装eslint时的配置文件"></a>使用vue-cli安装eslint时的配置文件</h3><p>vue-cli安装eslint，有两种可能的配置文件方式</p><ol><li>配置文件集成在<code>package.json</code>文件中</li><li>配置文件为<code>.eslintrc.js</code><br>二者可同时生效</li></ol><h2 id="3-配置文件内容解读"><a href="#3-配置文件内容解读" class="headerlink" title="3. 配置文件内容解读"></a>3. 配置文件内容解读</h2><p>以我使用vue-cli搭建的项目的eslint配置文件为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* eslint配置 */</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    root: <span class="literal">true</span>,     <span class="comment">// 只在项目目录中寻找eslint配置文件，禁止向父级目录寻找配置文件。</span></span><br><span class="line">    env: &#123;          <span class="comment">// 在env中指定脚本的运行环境</span></span><br><span class="line">        node: <span class="literal">true</span>  <span class="comment">// 使用 Node.js 全局变量和 Node.js 作用域。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    extends: [                  <span class="comment">// 扩展配置</span></span><br><span class="line">        <span class="string">"plugin:vue/essential"</span>, <span class="comment">// 启用esline-plugin-vue的essential配置</span></span><br><span class="line">        <span class="string">"eslint:recommended"</span>    <span class="comment">// 启用eslint推荐的规则</span></span><br><span class="line">    ],</span><br><span class="line">    parserOptions: &#123;            <span class="comment">// 解析器选项</span></span><br><span class="line">        parser: <span class="string">"babel-eslint"</span>  <span class="comment">// 一个对Babel解析器的包装，使其能够与 ESLint 兼容。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [  <span class="comment">// 插件</span></span><br><span class="line">        <span class="string">'vue'</span>,  <span class="comment">// eslint-plugin-vue插件</span></span><br><span class="line">        <span class="string">'html'</span>  <span class="comment">// eslint-plugin-html插件</span></span><br><span class="line">    ],</span><br><span class="line">    rules: &#123;    <span class="comment">// 规则</span></span><br><span class="line">        <span class="string">"no-multiple-empty-lines"</span>: [<span class="number">2</span>, &#123; <span class="string">"max"</span>: <span class="number">3</span> &#125;],   <span class="comment">// 空行不得连续超过三行。</span></span><br><span class="line">        <span class="string">"no-extra-boolean-cast"</span>: <span class="number">2</span>,  <span class="comment">// 禁止不必要的布尔类型转换</span></span><br><span class="line">        <span class="string">"no-extra-semi"</span>: <span class="number">2</span>,          <span class="comment">// 禁止使用额外的分号，禁止情况如：";;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-规则的级别"><a href="#4-规则的级别" class="headerlink" title="4. 规则的级别"></a>4. 规则的级别</h2><ol><li>“off” or 0 - 关闭规则</li><li>“warn” or 1 - 将规则视为一个警告（不会影响退出码）</li><li>“error” or 2 - 将规则视为一个错误 (退出码为1)</li></ol><blockquote><p>这三个错误级别可以允许你细粒度的控制 ESLint 是如何应用规则。（摘自官方文档）</p></blockquote><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li>eslint官方文档：<a href="https://eslint.bootcss.com/" target="_blank" rel="noopener">https://eslint.bootcss.com/</a></li><li>plugin-vue-eslint官方文档：<a href="https://eslint.vuejs.org/" target="_blank" rel="noopener">https://eslint.vuejs.org/</a></li></ul>]]></content>
    
    <summary type="html">
    
      eslint
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="代码检测工具" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
    
      <category term="eslint" scheme="http://yoursite.com/tags/eslint/"/>
    
  </entry>
  
  <entry>
    <title>关于异步（二）：async function</title>
    <link href="http://yoursite.com/2020/03/10/%E5%85%B3%E4%BA%8E%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/03/10/关于异步方法二/</id>
    <published>2020-03-10T07:09:00.000Z</published>
    <updated>2020-03-15T04:04:22.852Z</updated>
    
    <content type="html"><![CDATA[<p>只需要两个关键字：async、await，辅助Promise的一些方法，即可优雅地将异步请求进行串行处理。</p><p>本文主要展示async的用法。顺带将async与Promise进行比较，同时指出了setTimeout函数的一些注意事项。</p><a id="more"></a><h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2><h3 id="使用async和await将异步请求串行传里的方法"><a href="#使用async和await将异步请求串行传里的方法" class="headerlink" title="使用async和await将异步请求串行传里的方法"></a>使用async和await将异步请求串行传里的方法</h3><ol><li>首先要将包含异步操作的函数，声明为异步函数</li><li>在异步方法前加await关键字。</li></ol><h3 id="async关键字"><a href="#async关键字" class="headerlink" title="async关键字"></a>async关键字</h3><ol><li>async关键字的功能：声明异步函数。</li></ol><h3 id="await关键字"><a href="#await关键字" class="headerlink" title="await关键字"></a>await关键字</h3><ol><li>await关键字的功能：暂停异步函数的执行，等接收到Promise的执行结果后，再继续异步函数的执行。</li><li>await关键字的返回值：返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。</li><li>await关键字的使用条件：必须在async function中才能使用。</li></ol><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"准备执行异步方法..."</span>);</span><br><span class="line">    <span class="keyword">var</span> returnVal = <span class="keyword">await</span> asyncFunction();  <span class="comment">// asyncFunciton 是一个包含异步方法的函数，如包含ajax通信或setTimeout的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法执行完毕！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体示例1：串行执行异步方法"><a href="#具体示例1：串行执行异步方法" class="headerlink" title="具体示例1：串行执行异步方法"></a>具体示例1：串行执行异步方法</h2><p>只言片语可能无法很好理解，下面是一个小的示例，比较了promise的链式语法和async function的区别。</p><p>我们期望在两秒后，对value变量设置一个值，并打印其结果。但是在实现上有些条件。</p><ol><li>需要在一个方法中调用setTimeout。</li><li>在另一个方法中调用这个方法，并设置变量的值。</li></ol><p>是不是像极了平时写项目时，在一个方法中发起ajax请求，再另一个方法中调用这个请求，并接收请求返回的内容，对内容进行下一步的处理？</p><h3 id="第一种写法：一种错误的示例"><a href="#第一种写法：一种错误的示例" class="headerlink" title="第一种写法：一种错误的示例"></a>第一种写法：一种错误的示例</h3><p>不使用Promise、不使用async function，博主在什么都不懂时便写过类似的代码，但这种写法肯定不行，无法满足要求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function setValueAfter2Seconds()&#123;</span><br><span class="line">    return setTimeout(()=&gt;&#123;</span><br><span class="line">        console.log(&quot;setTimeout 执行完毕&quot;)</span><br><span class="line">        return &quot;new value&quot;</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test()&#123;</span><br><span class="line">    var value = &quot;old value&quot;;</span><br><span class="line">    console.log(&quot;准备调用&quot;);</span><br><span class="line">    value = setValueAfter2Seconds()</span><br><span class="line">    console.log(&quot;结束调用，准备打印值&quot;);</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>错误原因：</p><ol><li>注意，setTimeout回调函数的返回值和setTimeout的返回值没有任何关系！没有任何关系！没有任何关系！所以通过在setTimeout函数中进行return没有任何作用！setTimeout的返回值是一个唯一的id，用于传入给<code>clearTimeout</code>后可取消该定时器。</li><li>setTimeout方法和其他语句是异步执行的，具体原因需要了解js中的并发模型与事件循环的机制。我们只消知道setTimeout是个异步的方法即可。</li></ol><h3 id="第二种写法：Promise的写法"><a href="#第二种写法：Promise的写法" class="headerlink" title="第二种写法：Promise的写法"></a>第二种写法：Promise的写法</h3><p>使用Promise链式语法的方案如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setValueAfter2Seconds</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`setTimeout 准备执行`</span>)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`setTimeout 执行结束`</span>)</span><br><span class="line">            resolve(<span class="string">`new value`</span>);</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">"old value"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise执行函数 准备执行"</span>);</span><br><span class="line">    setValueAfter2Seconds().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Promise执行函数 执行结束"</span>);</span><br><span class="line">        value = res;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise链外部的内容仍然会先于setTimeout执行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面对代码进行分析</p><ol><li>在<code>setValueAfter2Seconds()</code>中，返回了一个Promise对象。该对象的参数为一个函数，叫做“执行函数”。执行函数接受的第一个参数resolve，是Promise的一个方法。当执行函数中的所有内容顺利完成时，将调用resolve函数，否则会调用reject函数（此处未添加，reject是执行器函数的第二个参数）。</li><li>在<code>test()</code>中，运行了<code>setValueAfter2Seconds()</code>后，执行Promise对象的then方法（<code>then()</code>即Promise的执行函数顺利完成后执行的方法），<code>then()</code>接收的参数为一个函数，被称作“处理方法（handlers）”。所有期望在<code>setValueAfter2Seconds()</code>方法执行完毕后，继续执行的代码需要写到“处理方法(handlers)”中。”处理方法”之外的语句，与Promise链中的语句仍然是异步执行（这点注意，这是Promise与async不同的最大表现之一）。</li></ol><h3 id="第三种写法：使用async"><a href="#第三种写法：使用async" class="headerlink" title="第三种写法：使用async"></a>第三种写法：使用async</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">setValueAfter2Seconds</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`setTimeout 准备执行`</span>)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`setTimeout 执行结束`</span>)</span><br><span class="line">            resolve(<span class="string">`new value`</span>);</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">"old value"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Prmomise执行函数准备执行"</span>);</span><br><span class="line">    value = <span class="keyword">await</span> setValueAfter2Seconds();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise执行函数 执行结束"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对代码进行分析：</p><ol><li>使用<code>async</code>关键字声明<code>test()</code>是一个异步函数。</li><li>使用<code>await</code>关键字暂停异步函数的执行，等待Promise执行函数运行完毕，接收Promise对象的处理结果，即resolve函数的参数<code>new value</code>，并赋值给value变量，然后执行后续的代码。</li></ol><h3 id="具体示例2：并行执行异步方法"><a href="#具体示例2：并行执行异步方法" class="headerlink" title="具体示例2：并行执行异步方法"></a>具体示例2：并行执行异步方法</h3><h3 id="Promise写法"><a href="#Promise写法" class="headerlink" title="Promise写法"></a>Promise写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncFunction1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法1 准备执行 等待时间设置为1秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法1"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法1 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> asyncFunction2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法2 准备执行 等待时间设置为2秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法2"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法2 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> concurrentPromise = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"开始并行执行异步方法"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.all([asyncFunction1(), asyncFunction2()]).then(<span class="function">(<span class="params">messages</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(messages[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">console</span>.log(messages[<span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise.all外部的内容仍然会先于setTimeout执行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="async写法1：使用Promise-all，所有异步方法执行完毕后执行后续内容。"><a href="#async写法1：使用Promise-all，所有异步方法执行完毕后执行后续内容。" class="headerlink" title="async写法1：使用Promise.all，所有异步方法执行完毕后执行后续内容。"></a>async写法1：使用Promise.all，所有异步方法执行完毕后执行后续内容。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncFunction1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法1 准备执行 等待时间设置为1秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法1"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法1 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> asyncFunction2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法2 准备执行 等待时间设置为2秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法2"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法2 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> concurrentAsync1 = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"开始并行执行异步方法"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([asyncFunction1(), asyncFunction2()]).then(<span class="function">(<span class="params">messages</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(messages[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">console</span>.log(messages[<span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise.all外部的内容与Promise.all顺序执行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="async写法2：异步方法同时执行，其他内容串行执行，遇到await时阻塞。"><a href="#async写法2：异步方法同时执行，其他内容串行执行，遇到await时阻塞。" class="headerlink" title="async写法2：异步方法同时执行，其他内容串行执行，遇到await时阻塞。"></a>async写法2：异步方法同时执行，其他内容串行执行，遇到await时阻塞。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncFunction1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法1 准备执行 等待时间设置为1秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法1"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法1 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> asyncFunction2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法2 准备执行 等待时间设置为2秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法2"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法2 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> concurrentAsync2 = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = [<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"开始并行执行异步方法"</span>);</span><br><span class="line">    </span><br><span class="line">    message[<span class="number">0</span>] = asyncFunction1();</span><br><span class="line">    message[<span class="number">1</span>] = asyncFunction2();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> message[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> message[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async1Funvtion1、asyncFunction2的并行执行，其他内容串行执行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="async-await和Promise链式写法的区别"><a href="#async-await和Promise链式写法的区别" class="headerlink" title="async await和Promise链式写法的区别"></a>async await和Promise链式写法的区别</h2><ol><li>async写法避免了Promise的链式写法。</li><li>结合使用async和Promise能发挥更大的作用。</li></ol>]]></content>
    
    <summary type="html">
    
      js异步
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js异步" scheme="http://yoursite.com/tags/js%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>关于异步方法（一）：使用Promise</title>
    <link href="http://yoursite.com/2020/03/05/%E5%85%B3%E4%BA%8E%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E4%B8%80/"/>
    <id>http://yoursite.com/2020/03/05/关于异步方法一/</id>
    <published>2020-03-05T02:05:50.000Z</published>
    <updated>2020-03-15T10:49:18.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-时刻牢记：ajax请求是异步的。"><a href="#1-时刻牢记：ajax请求是异步的。" class="headerlink" title="1. 时刻牢记：ajax请求是异步的。"></a>1. 时刻牢记：ajax请求是异步的。</h2><p>比如：A方法调用ajax请求,B方法调用A方法，同时B方法调用C方法进行一些涉及到ajax返回的数据的处理工作（因某些原因该工作不能放到ajax请求的回调函数中，比如需要用到另一个ajax请求的内容）。</p><p>伪代码如下，用axios替代ajax请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 这段代码的目的：通过B函数，成功为经过ajax请求获取到的id设置name。</span><br><span class="line"></span><br><span class="line">// 全局变量</span><br><span class="line">var data = []   // 我们最终要设置的变量</span><br><span class="line">var mapRelation = [&#123;userId:123,userName:1234&#125;]  // 注意：这是通过另外一个ajax请求获得的。所以处理函数C不能或者说不方便放到A方法中。</span><br><span class="line"></span><br><span class="line">// 该方法通过异步请求，获取Id。</span><br><span class="line">function A()&#123;</span><br><span class="line">    return axios(请求参数).then(res=&gt;&#123;</span><br><span class="line">        // 对请求所返回内容的处理工作</span><br><span class="line">        // 假如res为&#123;userId:123&#125;;</span><br><span class="line">        data.push(res); </span><br><span class="line">    &#125;).catch(err=&gt;console.log(err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 该方法通过对象data的userId，为data设置userName。</span><br><span class="line">function C(data)&#123;</span><br><span class="line">    mapRelation.map(userItem=&gt;&#123;</span><br><span class="line">        if(userItem.userId === data.userId)&#123;</span><br><span class="line">            data.userName = userItem.uesrName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设计B函数，为经过ajax请求获取到的id设置name。</span><br><span class="line">// 错误的写法。</span><br><span class="line">function bWrong()&#123;</span><br><span class="line">    // 这里并不会成功地为后台传来的userId找到usernName。</span><br><span class="line">    // 因为A中axios请求的回调函数和函数C()是并行的关系。</span><br><span class="line">    A();</span><br><span class="line">    C();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 正确的写法</span><br><span class="line">function bCorrect()&#123;</span><br><span class="line">    // 由于axios().then()返回的是一个promise对象（），该对象又被A函数返回，于是可以通过.then()的方式进行串行处理请求。</span><br><span class="line">    A().then(()=&gt;&#123;</span><br><span class="line">        C();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><ol><li>Promise.then()的语法如下。其中<code>[]</code>中的内容代表可选内容。<code>Promise.then(onFulfilled[,onRejected])。</code></li><li>then()返回一个 Promise 对象。(关于Promise.then()的更多内容<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener">mdn</a>)</li><li>catch()返回一个 Promise 对象。(关于Promise.catch()的更多内容<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch" target="_blank" rel="noopener">mdn</a>)</li><li>Promise定义于ES6.</li></ol><h2 id="2-在多个异步请求执行完毕后，执行一段代码——Promise-all"><a href="#2-在多个异步请求执行完毕后，执行一段代码——Promise-all" class="headerlink" title="2. 在多个异步请求执行完毕后，执行一段代码——Promise.all()"></a>2. 在多个异步请求执行完毕后，执行一段代码——Promise.all()</h2><p>在写项目的时候经常会遇到，需要得到两个ajax请求的结果后，才能进行数据处理的场景。此时用Promise.all()便能将两个异步请求与数据处理方法进行串行化。</p><p>一般的写法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([方法1，方法2]).then(res=&gt;&#123;</span><br><span class="line">    需要串行执行的方法</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="补充：-1"><a href="#补充：-1" class="headerlink" title="补充："></a>补充：</h4><ol><li>Promise.all(iterable)方法，返回一个Promise实例。如果iterable参数的所有方法执行成功，则返回的Promise实例中的参数为iterable执行成功后的返回值。否则返回没有成功执行的原因。</li></ol><h2 id="3-不得不说：Promise真的是个好东西。"><a href="#3-不得不说：Promise真的是个好东西。" class="headerlink" title="3. 不得不说：Promise真的是个好东西。"></a>3. 不得不说：Promise真的是个好东西。</h2><ol><li>解决了异步请求进行同步执行的问题。</li><li>解决了回调地狱的问题，链式调用简介又直观还好写。</li></ol><h3 id="Promise对象的状态"><a href="#Promise对象的状态" class="headerlink" title="Promise对象的状态"></a>Promise对象的状态</h3><ul><li>pendding，指异步操作正在进行中。</li><li>fulfilled，指异步操作成功完成。</li><li>rejected，指异步操作执行失败。</li></ul><h4 id="补充：Promise相关的方法"><a href="#补充：Promise相关的方法" class="headerlink" title="补充：Promise相关的方法"></a>补充：Promise相关的方法</h4><ol><li><code>Promise.resolve()</code>：个人理解是Prmoise的一个状态，指问题成功解决、代码成功运行,设置Promise处于fulfilled状态。</li><li><code>Promise.reject()</code>：问题解决失败或代码运行失败。</li><li><code>Promise.then(succes,failed)</code>：在then中加入Promise状态为fulfilled或者reject的回调函数，链式执行。</li><li><code>Promise.catch(failed)</code>：仅在Promise状态为reject或者抛出异常时运行catch中的函数。</li><li><code>Promise.finally()</code>：仅在Promise结束时运行，无论结果是reject还是fulfilled。</li><li><code>Promise.all(iterator)</code>：执行iterator中的所有方法，方法之间是且的关系。如果全部方法的执行结果全部为fulfilled或未返回Promise的情况，回调fulfilled，否则回调reject。</li><li><code>Promise.race(iterator)</code>：执行iterator中的方法，方法之间可以理解为或的关系。回调的是最早执行的函数的状态，如果最早的函数执行结果是fulfilled，则回调fulfilled，否则回调reject。如果迭代内容iterator是空，则永远等待。</li><li><code>Promise.allSettled(iterator)</code>将iterator包装成一个Prmoise实例，再执行iterator中的方法，所有方法都完成后才返回结果，返回结果是包含iterator执行结果的数组，且返回时Promise的状态一定是fulfilled。返回结果的数组中，每一项都有status属性，对应着Prmoise的执行结果，值为<code>&#39;fulfilled&#39;</code>或<code>&#39;rejected&#39;</code>。该方法由ES2020引入。</li><li><code>Promise.any(iterator)</code>执行iterator中的方法。如果iterator中某个方法返回的Promise状态为fulfilled，则函数回调fulfilled，否则当所有方法都返回rejected时，才回调rejected方法。该方法当前处于第三阶段提案。</li><li><code>Promise.try()</code>现在仍然属于提案，可以捕获Promise执行函数中的所有同步和异步错误。与<code>Promise.catch()</code>相呼应。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>使用Promise。From mdn：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises</a></li><li>Promise对象：From mdn：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></li><li>Promise对象：From 阮一峰：<a href="https://es6.ruanyifeng.com/#docs/promise#Promise-reject" target="_blank" rel="noopener">https://es6.ruanyifeng.com/#docs/promise#Promise-reject</a></li></ul>]]></content>
    
    <summary type="html">
    
      js异步
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js异步" scheme="http://yoursite.com/tags/js%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>《你不知道的JavaScript 上册》第一部分</title>
    <link href="http://yoursite.com/2020/01/31/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%20%E4%B8%8A%E5%8D%B7%E3%80%8B%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <id>http://yoursite.com/2020/01/31/《你不知道的JavaScript 上卷》第一部分/</id>
    <published>2020-01-31T15:47:30.000Z</published>
    <updated>2020-04-22T15:48:06.039Z</updated>
    
    <content type="html"><![CDATA[<p>第一部分：作用域和闭包</p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol><li><a href="#chapter1">作用域是什么</a><br> 1.1. <a href="#1.1">编译原理</a><br> 1.2. <a href="#1.2">理解作用域</a></li><li><a href="#chapter2">词法作用域</a><br> 2.1. <a href="#2.1">词法阶段</a><br> 2.2. <a href="#2.2">欺骗词法</a></li><li><a href="#chapter3">函数作用域和块作用域</a><br> 3.1. <a href="#3.1">函数中的作用域</a><br> 3.2. <a href="#3.2">隐藏内部实现</a><br> 3.3. <a href="#3.3">块作用域</a></li><li><a href="#chapter4">提升</a></li><li><a href="#chapter5">作用域闭包</a><br> 5.2. <a href="#5.2">实质问题</a><br> 5.4. <a href="#5.4">循环和闭包</a><br> 5.5. <a href="#5.5">模块</a></li><li><a href="#appendixA">附录A</a></li><li><a href="#appendixB">附录B 块作用域的替代方案</a><br> B.1. <a href="#B.1">Traceur</a><br> B.2. <a href="#B.2">隐式和显式作用域</a><br> B.3. <a href="#B.3">性能</a></li><li><a href="#appendixC">附录C this词法</a></li></ol><hr><h2 id="第一章-作用域是什么"><a href="#第一章-作用域是什么" class="headerlink" title="第一章 作用域是什么"></a><div id="chapter1">第一章 作用域是什么</div></h2><h3 id="1-1-编译原理"><a href="#1-1-编译原理" class="headerlink" title="1.1 编译原理"></a><div id="1.1">1.1 编译原理</div></h3><ul><li>编译代码的三个步骤<ol><li>分词/词法分析：将字符串分解成(对编程语言来说)有意义的代码块，这些代码块被称为词法单元(token)。</li><li>解析/语法分析：将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。</li><li>代码生成：将 AST 转换为可执行代码的过程称被称为代码生成。<br>编译器编译完毕后，由引擎执行生成的代码。</li></ol></li></ul><h3 id="1-2-理解作用域"><a href="#1-2-理解作用域" class="headerlink" title="1.2 理解作用域"></a><div id="1.2">1.2 理解作用域</div></h3><ul><li>LHS查询：变量出现在赋值操作的左侧时进行的查询。试图找到变量的容器本身，<code>set</code>操作，当执行非法操作时，比如对一个没有声明的变量进行赋值，非严格模式下的引擎会自动声明该变量，而非严格模式会报错<code>ReferenceError</code>。</li><li>RHS查询：变量出现在赋值操作的右侧时进行的查询。retrieve his source value，取到它的值，类似<code>get</code>操作，可能会引发两种错误：1. <code>ReferenceError</code>同作用域判别失败相关 2. <code>TypeError</code>则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</li></ul><h2 id="第二章-词法作用域"><a href="#第二章-词法作用域" class="headerlink" title="第二章 词法作用域"></a><div id="chapter2">第二章 词法作用域</div></h2><p>作用域的两种工作模型：</p><ul><li>词法作用域。</li><li>动态作用域。<br>JavaScript采用的是词法作用域。</li></ul><h3 id="2-1-词法阶段"><a href="#2-1-词法阶段" class="headerlink" title="2.1 词法阶段"></a><div id="2.1">2.1 词法阶段</div></h3><ul><li>标识符查找：从当前作用域，逐级向上，找到为止。<ul><li>引申：遮蔽效应(内部的标识符“遮蔽”了外部的标识符)</li></ul></li><li>全局变量与全局对象的关系：全局变量会自动成为全局对象(比如浏览器中的 window 对象)的属性。</li></ul><h3 id="2-2-欺骗词法"><a href="#2-2-欺骗词法" class="headerlink" title="2.2 欺骗词法"></a><div id="2.2">2.2 欺骗词法</div></h3><p>欺骗词法即在运行时修改词法的作用域。</p><ul><li><p>注意：不推荐进行欺骗词法。</p><ul><li>原因1：作用域会导致性能“下降”。引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。</li><li>原因2：会被严格模式所影响(限制)。<code>with</code>被完全禁止，而在保留核心功能的前提下，间接或非安全地使用<code>eval(..)</code>也被禁止了。</li></ul></li><li><p>欺骗词法的两种方式：</p><ul><li>eval函数：eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。<ul><li>注意：在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其 中的声明无法修改所在的作用域。</li></ul></li><li>with关键字：重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。<ul><li>注意：尽管<code>with</code>块可以将一个对象处理为词法作用域，但是这个块内部正常的<code>var</code>声明并不会被限制在这个块的作用域中，而是被添加到<code>with</code>所处的函数作用域中。使用let即可避免污染函数作用域。</li></ul></li></ul></li></ul><h2 id="第三章-函数作用域和块作用域"><a href="#第三章-函数作用域和块作用域" class="headerlink" title="第三章 函数作用域和块作用域"></a><div id="chapter3">第三章 函数作用域和块作用域</div></h2><h3 id="3-1-函数中的作用域"><a href="#3-1-函数中的作用域" class="headerlink" title="3.1 函数中的作用域"></a><div id="3.1">3.1 函数中的作用域</div></h3><ul><li>函数作用域的概念：属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)。</li></ul><h3 id="3-2-隐藏内部实现"><a href="#3-2-隐藏内部实现" class="headerlink" title="3.2 隐藏内部实现"></a><div id="3.2">3.2 隐藏内部实现</div></h3><ul><li>为什么要隐藏内部实现？<ul><li>最小特权原则（最小授权原则、最小暴露原则）：软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。</li><li>规避冲突。避免命名冲突，污染全局作用域。</li></ul></li><li>隐藏内部实现的原理：将变量和函数用函数包裹起来，将其放置在函数作用域中。</li><li>隐藏内部实现的方法<ul><li>全局命名空间。在全局作用域中声明一个独特的变量，作为库的命名空间，所有需要暴露给外界的功能都是其属性。参考jquery（使用$符号），d3.js（使用d3）。</li><li>模块管理。使用依赖管理器，将库的标识符显示地导入到特定的作用域中。</li><li>IIFE，代表立即执行函数表达式 (Immediately Invoked Function Expression)。（具名函数的 IIFE 是最佳实践）</li></ul></li><li>函数表达式和函数声明的辨析<ul><li>函数表达式：函数被包含在一对 ( ) 括号内部，因此成为了一个表达式。</li><li>函数声明：第一个单词必须是function。</li><li>函数表达式可以是匿名的，而函数声明则不可以省略函数名。始终给函数表达式命名是一个最佳实践。</li></ul></li><li>IIFE的进阶用法<ul><li>把它们当作函数调用并传递参数进去。</li><li>将一个参数命名为 undefined，但是在对应的位置不传入任何值，这样就可以 保证在代码块中 undefined 标识符的值真的是 undefined。</li><li>倒置代码的运行顺序。</li></ul></li></ul><h3 id="3-3-块作用域"><a href="#3-3-块作用域" class="headerlink" title="3.3 块作用域"></a><div id="3.3">3.3 块作用域</div></h3><ul><li><p>形式上的块作用域，实际上并不是块作用域的写法，会导致变量污染到整个函数作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var foo = true;</span><br><span class="line">if (foo) &#123;</span><br><span class="line">    var bar = foo * 2;</span><br><span class="line">    bar = something( bar ); console.log( bar );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>块作用域实现的几种方法</p><ul><li>with。用 with 从对象中创建出的作用域仅在 with 声明中而非外 部作用域中有效。</li><li>try/catch。JavaScript 的 ES3 规范中规定 try/catch 的 catch 分句会创建一个块作用域，其中声明的变量（catch的实参？）仅在 catch 内部有效。如果在catch的代码块中使用var声明变量，在函数作用域中仍然能获取到声明的变量。</li><li>let。ES6引入的新关键字，实现块作用域的最好方式。</li><li>const。ES6引入的新关键字，同样可以实现块作用域，但变量的值不可以更改。</li></ul></li><li>块作用域可以将无用的变量进行垃圾回收。</li></ul><h2 id="第四章-提升"><a href="#第四章-提升" class="headerlink" title="第四章 提升"></a><div id="chapter4">第四章 提升</div></h2><p>变量声明在作用域中出现的位置不同，会导致不同的影响。</p><ul><li>提升的本质：代码的执行分为两个阶段：编译阶段和执行阶段。编译阶段编译器找到所有的声明，并用合适的作用域将它们关联起来。执行阶段引擎会直接执行代码。</li><li>提升的对象：只有声明本身会被提升（无论是变量声明还是函数声明），而赋值或其他运行逻辑会留在原地。</li><li>提升需要注意的点：<ul><li>即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用。</li><li>函数会首先被提升，然后才是变量。</li><li>函数会首先被提升，然后才是变量。</li><li>尽量避免重复声明。</li></ul></li></ul><h2 id="第五章-作用域闭包"><a href="#第五章-作用域闭包" class="headerlink" title="第五章 作用域闭包"></a><div id="chapter5">第五章 作用域闭包</div></h2><p>函数与对其状态即词法环境（lexical environment）的引用共同构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在JavaScript，函数在每次创建时生成闭包。（from mdn）</p><h3 id="5-2-实质问题"><a href="#5-2-实质问题" class="headerlink" title="5.2 实质问题"></a><div id="5.2">5.2 实质问题</div></h3><ul><li>下面的这段代码清晰地展示了什么叫闭包：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123; </span><br><span class="line">    var a = 2;</span><br><span class="line">    function bar() &#123; </span><br><span class="line">        console.log( a );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return bar; </span><br><span class="line">&#125;    </span><br><span class="line">var baz = foo();</span><br><span class="line">baz(); // 2 —— 朋友，这就是闭包的效果。</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-4-循环和闭包"><a href="#5-4-循环和闭包" class="headerlink" title="5.4 循环和闭包"></a><div id="5.4">5.4 循环和闭包</div></h3><ul><li><p>想要实现每隔一秒钟，按顺序打印出<code>1 2 3 4 5</code>。</p><ul><li><p>代码不能写成如下的形式，打印的结果会是每隔一秒钟输出一个6，原因是setTimeOut的回调函数是在循环结束了之后才执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (var i=1; i&lt;=5; i++) &#123; </span><br><span class="line">    setTimeout( function timer() &#123;</span><br><span class="line">    console.log( i ); &#125;, i*1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码可以写成如下形式：</p><ul><li><p>第一种方式，通过IIFE，创建新的作用域，并在新的作用域中记录循环时的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i=1; i&lt;=5; i++) &#123; (function(j) &#123;</span><br><span class="line">    setTimeout( function timer() &#123; console.log( j );</span><br><span class="line">        &#125;, j*1000 );</span><br><span class="line">    &#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二种方式，使用闭包的块作用域：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i=1; i&lt;=5; i++) &#123; </span><br><span class="line">    setTimeout( function timer() &#123;</span><br><span class="line">    console.log( i ); &#125;, i*1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>模块模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function CoolModule() &#123;</span><br><span class="line">    var something = &quot;cool&quot;;</span><br><span class="line">    var another = [1, 2, 3];</span><br><span class="line">    </span><br><span class="line">    function doSomething() &#123; </span><br><span class="line">        console.log( something );</span><br><span class="line">    &#125;</span><br><span class="line">    function doAnother() &#123;</span><br><span class="line">        console.log( another.join( &quot; ! &quot; ) );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">        doSomething: doSomething, </span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br><span class="line">var foo = CoolModule(); </span><br><span class="line">foo.doSomething(); // cool</span><br><span class="line">foo.doAnother(); // 1 ! 2 ! 3</span><br></pre></td></tr></table></figure></li><li><p>闭包经模块模式稍加改进后实现的单例模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var foo = (function CoolModule() &#123; var something = &quot;cool&quot;;</span><br><span class="line">    var another = [1, 2, 3];</span><br><span class="line">    function doSomething() &#123; </span><br><span class="line">        console.log( something );</span><br><span class="line">    &#125;</span><br><span class="line">    function doAnother() &#123;</span><br><span class="line">        console.log( another.join( &quot; ! &quot; ) );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">        doSomething: doSomething, </span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;)();</span><br><span class="line">foo.doSomething(); // cool </span><br><span class="line">foo.doAnother(); // 1 ! 2 ! 3</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-5-模块"><a href="#5-5-模块" class="headerlink" title="5.5 模块"></a><div id="5.5">5.5 模块</div></h3><p>模块有两个主要特征:</p><ol><li>为创建内部作用域而调用了一个包装函数;</li><li>包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</li></ol><h3 id="5-5-1-现代的模块机制"><a href="#5-5-1-现代的模块机制" class="headerlink" title="5.5.1 现代的模块机制"></a>5.5.1 现代的模块机制</h3><ul><li><p>一个模块管理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var MyModules = (function Manager() &#123;</span><br><span class="line">    var modules = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    function define(name, deps, impl) &#123;</span><br><span class="line">        for (var i=0; i&lt;deps.length; i++) &#123;</span><br><span class="line">            deps[i] = modules[deps[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        modules[name] = impl.apply( impl, deps ); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function get(name) &#123; </span><br><span class="line">        return modules[name];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">        define: define,</span><br><span class="line">        get: get </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>使用模块管理器来定义模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">MyModules.define( &quot;bar&quot;, [], function() &#123; </span><br><span class="line">    function hello(who) &#123;</span><br><span class="line">        return &quot;Let me introduce: &quot; + who; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">        hello: hello</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MyModules.define( &quot;foo&quot;, [&quot;bar&quot;], function(bar) &#123; </span><br><span class="line">    var hungry = &quot;hippo&quot;;</span><br><span class="line">    function awesome() &#123;</span><br><span class="line">        console.log( bar.hello( hungry ).toUpperCase() );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">        awesome: awesome</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var bar = MyModules.get( &quot;bar&quot; );</span><br><span class="line">var foo = MyModules.get( &quot;foo&quot; ); </span><br><span class="line">console.log( bar.hello( &quot;hippo&quot; )); // Let me introduce: hippo </span><br><span class="line">foo.awesome(); // LET ME INTRODUCE: HIPPO</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-5-2-未来的模块机制"><a href="#5-5-2-未来的模块机制" class="headerlink" title="5.5.2 未来的模块机制"></a>5.5.2 未来的模块机制</h3><ul><li><p>bar.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function hello(who) &#123;</span><br><span class="line">    return &quot;Let me introduce: &quot; + who;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export hello;</span><br></pre></td></tr></table></figure></li><li><p>foo.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 仅从 &quot;bar&quot; 模块导入 hello() import hello from &quot;bar&quot;;</span><br><span class="line">var hungry = &quot;hippo&quot;;</span><br><span class="line">function awesome() &#123; </span><br><span class="line">    sconsole.log(hello( hungry ).toUpperCase() );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export awesome;</span><br></pre></td></tr></table></figure></li><li><p>baz.js,导入完整的 “foo” 和 “bar” 模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module foo from &quot;foo&quot;; </span><br><span class="line">module bar from &quot;bar&quot;;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">    bar.hello( &quot;rhino&quot; )</span><br><span class="line">); // Let me introduce: rhino </span><br><span class="line"></span><br><span class="line">foo.awesome(); // LET ME INTRODUCE: HIPPO</span><br></pre></td></tr></table></figure></li><li><p>import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量 上(在我们的例子里是 hello)。</p></li><li>module 会将整个模块的 API 导入并绑定到一个变量上(在 我们的例子里是 foo 和 bar)。</li><li>export 会将当前模块的一个标识符(变量、函数)导出为公 共 API。</li><li>这些操作可以在模块定义中根据需要使用任意多次。</li></ul><h2 id="附录A-动态作用域"><a href="#附录A-动态作用域" class="headerlink" title="附录A 动态作用域"></a><div id="appendixA">附录A 动态作用域</div></h2><p>动态作用域和词法作用域的区别如下：</p><ul><li>词法作用域，关心函数是在何处声明以及如何声明。</li><li>词法作用域的定义过程发生在书写代码的阶段。</li><li>动态作用域，关心函数是如何调用的、从何处调用的。</li><li>动态作用域在运行时才被动态定义。</li></ul><p>书中通过举例，比较了动态作用域和静态作用域之间的区别。</p><p>动态作用域的代码调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log( a ); // 3(不是 2 !)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123; </span><br><span class="line">    var a = 3;</span><br><span class="line">    foo(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure></p><p>静态作用域的代码调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123; </span><br><span class="line">    console.log( a ); // 2</span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123; </span><br><span class="line">    var a = 3;</span><br><span class="line">    foo(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2; </span><br><span class="line">bar();</span><br></pre></td></tr></table></figure></p><h2 id="附录B-块作用域的替代方案"><a href="#附录B-块作用域的替代方案" class="headerlink" title="附录B 块作用域的替代方案"></a><div id="appendixB">附录B 块作用域的替代方案</div></h2><h3 id="B-1-Traceur"><a href="#B-1-Traceur" class="headerlink" title="B.1 Traceur"></a><div id="B.1">B.1 Traceur</div></h3><p>块作用域的替代方案：</p><ul><li>try catch。代码丑陋，但这是一种使不兼容es6的代码使用块作用域的一个手段。通常在代码中按照es6的块作用域方法去写，再由特定的工具（比如traceur）对块作用域转换为类似形式。</li></ul><h3 id="B-2-隐式和显式作用域"><a href="#B-2-隐式和显式作用域" class="headerlink" title="B.2 隐式和显式作用域"></a><div id="B.2">B.2 隐式和显式作用域</div></h3><p>在第三章曾经提到过：</p><blockquote><p>用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。在开发和修改代码的过 程中，如果没有密切关注哪些块作用域中有绑定的变量，并且习惯性地移动这些块或者将 其包含在其他的块中，就会导致代码变得混乱。</p></blockquote><p>显式作用域的好处：</p><ul><li>显式作用域，作用域更加突出，</li><li>显式作用域，在代码重构时表现得更加健壮。</li></ul><p>在第三章中提出的由隐式作用域变为显式作用域的解决方案是在隐式作用域的周围添加大括号。还有一种方案，通过let声明，也可以显式地表明一块作用域，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let (a = 2) &#123;</span><br><span class="line">    console.log( a ); // 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log( a ); // ReferenceError</span><br></pre></td></tr></table></figure></p><p>但是<strong>注意：let 声明并不包含在 ES6 中。</strong></p><p>使用es6语法的方案，方案一，仍然使用大括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*let*/ &#123; </span><br><span class="line">    let a = 2; </span><br><span class="line">    console.log( a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log( a ); // ReferenceError</span><br></pre></td></tr></table></figure></p><p>方案二，通过工具，把自己编写的let声明，转换为es6语法，即使用大括号围住显式作用域。</p><p>（感觉有点太麻烦了，还不如直接用隐式的作用域或者在不明显的地方用大括号。）</p><h3 id="B-3-性能"><a href="#B-3-性能" class="headerlink" title="B.3 性能"></a><div id="B.3">B.3 性能</div></h3><ul><li>try catch的性能很差。</li><li>什么时候使用块作用域？<ul><li>你是否想要块作用域?如果你想要，上述的内容可以帮助你。如果不想要，继续使用 var 来写代码就好了!</li></ul></li></ul><h3 id="附录C-this词法"><a href="#附录C-this词法" class="headerlink" title="附录C this词法"></a><div id="appendixC">附录C this词法</div></h3><ul><li>箭头函数不仅仅意味着少些代码。</li><li>不建议箭头函数和词法作用域混用。</li><li>建议在使用this的地方使用bind。（bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 from mdn）。</li></ul>]]></content>
    
    <summary type="html">
    
      你不知道的JavaScript
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>科学上网</title>
    <link href="http://yoursite.com/2020/01/26/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://yoursite.com/2020/01/26/科学上网/</id>
    <published>2020-01-26T14:52:50.000Z</published>
    <updated>2020-03-15T01:59:12.904Z</updated>
    
    <content type="html"><![CDATA[<p>记录博主科学上网的方法。「封面图来自：《飞行家》，2004，莱昂纳多主演」</p><a id="more"></a><ol><li><a href="#server">服务器</a></li><li><a href="#client">客户端</a></li><li><a href="#other">其他工具</a></li></ol><h3 id="1-服务器"><a href="#1-服务器" class="headerlink" title="1.服务器"></a><div id="server">1.服务器</div></h3><ul><li><a href="https://www.vultr.com/" target="_blank" rel="noopener">服务器提供商</a>。</li><li><a href="https://github.com/233boy/v2ray" target="_blank" rel="noopener">服务器运行的程序</a>。</li></ul><h3 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2.客户端"></a><div id="client">2.客户端</div></h3><ul><li>小灰机<ul><li>windows：<a href="https://github.com/shadowsocks/shadowsocks-windows" target="_blank" rel="noopener">点我</a>（打开页面后，点击”中文说明”-&gt;下载”最新版”-&gt;assets里的链接。）</li><li>安卓：<a href="https://www.apkturbo.com/apps/shadowsocks/com.github.shadowsocks/4.8.7/" target="_blank" rel="noopener">下载链接点我</a>（如果安装失败可以尝试下载其他版本。也可通过<a href="https://www.apkturbo.com/搜索com.github.shadowsocks下载其他类似软件。）" target="_blank" rel="noopener">https://www.apkturbo.com/搜索com.github.shadowsocks下载其他类似软件。）</a></li><li>mac：SsrConnectPro（需要花几块钱购买）</li><li>ios：SsrConnectPro</li></ul></li><li>v2ray<ul><li>windows：<a href="https://github.com/2dust/v2rayN/releases" target="_blank" rel="noopener">GitHub仓库点我</a></li><li>安卓：<a href="https://github.com/2dust/v2rayNG" target="_blank" rel="noopener">GitHub仓库点我</a>，<a href="https://www.apkturbo.com/apps/v2rayng/com.v2ray.ang/1.0.0/" target="_blank" rel="noopener">下载链接点我</a></li><li>mac：<a href="https://github.com/Cenmrev/V2RayX" target="_blank" rel="noopener">GitHub仓库点我</a></li><li>ios：暂未找到…</li></ul></li></ul><h3 id="3-其他工具"><a href="#3-其他工具" class="headerlink" title="3.其他工具"></a><div id="other">3.其他工具</div></h3><h4 id="上网不科学，也能谷歌play"><a href="#上网不科学，也能谷歌play" class="headerlink" title="上网不科学，也能谷歌play"></a>上网不科学，也能谷歌play</h4><ul><li><a href="https://apps.evozi.com/apk-downloader/" target="_blank" rel="noopener">https://apps.evozi.com/apk-downloader/</a></li><li><a href="https://www.apkturbo.com/" target="_blank" rel="noopener">https://www.apkturbo.com/</a></li></ul><h4 id="Google-BBR算法-优化tcp链接速度"><a href="#Google-BBR算法-优化tcp链接速度" class="headerlink" title="Google BBR算法 优化tcp链接速度"></a>Google BBR算法 优化tcp链接速度</h4><ul><li>转自Mr_Bluyee,<a href="https://www.jianshu.com/p/98c21990ed23" target="_blank" rel="noopener">原文链接</a></li><li>Linux kernel 4.9 及以上已支持 tcp_bbr</li></ul><ol><li>查看系统内核版本<code>uname -r</code>看内核版本是否大于等于4.9，否则要升级内核，或者安装bbr。</li><li>开启BBR：<ol><li><code>echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</code></li><li><code>echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</code></li></ol></li><li>保存生效：<code>sysctl -p</code></li><li>检查BBR是否启用：<ul><li><code>sysctl net.ipv4.tcp_available_congestion_control</code>返回值一般为：net.ipv4.tcp_available_congestion_control = reno cubic bbr</li><li><code>sysctl net.ipv4.tcp_congestion_control</code>返回值一般为：net.ipv4.tcp_congestion_control = bbr</li><li><code>sysctl net.core.default_qdisc</code>返回值一般为：net.core.default_qdisc = fq</li><li><code>lsmod | grep bbr</code>返回值有 tcp_bbr 模块则BBR已启动：<code>tcp_bbr 20480 10</code></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      科学上网
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="vps" scheme="http://yoursite.com/tags/vps/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式概览</title>
    <link href="http://yoursite.com/2019/12/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/12/02/设计模式/</id>
    <published>2019-12-02T03:35:30.000Z</published>
    <updated>2020-02-04T01:57:22.794Z</updated>
    
    <content type="html"><![CDATA[<p>23种设计模式，包括设计模式的UML图、定义、优缺点及java代码实现。</p><p>代码详见github：<a href="https://github.com/Michael-Zhang-Xian-Sen/design-pattern" target="_blank" rel="noopener">https://github.com/Michael-Zhang-Xian-Sen/design-pattern</a></p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol><li>创建型模式<ol><li>抽象工厂模式（Abstract Factory Pattern）</li><li>工厂方法模式（Factory Method Pattern）</li><li>简单工厂（Simple Factory Pattern）（注：不属于设计模式。）</li><li>原型模式（Prototype Pattern）</li><li>单例模式（Singleton Pattern）</li><li>建造者模式（Builder Pattern）（又名：生成器模式）</li></ol></li><li>行为型模式<ol><li>观察者模式（Observer Pattern）</li><li>模版方法模式（Template Pattern）</li><li>命令模式（Command Pattern）</li><li>状态模式（State Pattern）</li><li>职责链模式（Chain of Responsibility）</li><li>解释器模式（Interpreter Pattern）</li><li>中介者模式（Mediator Pattern）（又名：调停者模式）</li><li>访问者模式（Visitor Pattern）</li><li>策略模式（Strategy Pattern）</li><li>备忘录模式（Memento Pattern）</li><li>迭代器模式（Iterator Pattern）</li></ol></li><li>结构型模式<ol><li>适配器模式（Adapter Pattern）</li><li>桥接模式（Bridge Pattern）</li><li>组合模式（Composite Pattern）</li><li>装饰模式（Decorator Pattern）</li><li>外观模式（Facade Pattern）</li><li>享元模式（Flyweight Pattern）</li><li>代理模式（Proxy Pattern）</li></ol></li></ol><h2 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1. 创建型模式"></a>1. 创建型模式</h2><h3 id="1-1-抽象工厂模式"><a href="#1-1-抽象工厂模式" class="headerlink" title="1.1. 抽象工厂模式"></a>1.1. 抽象工厂模式</h3><h4 id="UML图："><a href="#UML图：" class="headerlink" title="UML图："></a>UML图：</h4><p><img src="http://cdn.ewinds.pw/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.jpg" alt="image"></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>抽象工厂模式（AbstractFactory）提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>抽象工厂的工厂最为强大。</li><li>易于交换产品系列。由于具体工厂类在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，只需改变具体工厂的内容便可改变不同的产品配置。符合里氏替换原则。</li><li>抽象工厂使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中。</li><li>该模式帮助我们针对抽象编程，而不是针对具体编程。</li><li>通过减少程序和具体类之间的依赖，促进松耦合。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>添加产品族很简单，只需要对每个接口添加一个类，符合开闭原则；但是添加产品比较麻烦，如果新添加了产品C，那么所有工厂都要添加产品C，违反了开闭原则。</p><h3 id="1-2-工厂方法模式"><a href="#1-2-工厂方法模式" class="headerlink" title="1.2. 工厂方法模式"></a>1.2. 工厂方法模式</h3><h4 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.jpg" alt="image"></p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。（即：工厂方法把简单工厂的逻辑判断移动到了客户端）</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>符合开闭原则。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>增加新的产品时，需要增加新的工厂类和产品类，会带来更大的开销。<br>抽象层的加入使得理解难度增大。</p><h3 id="1-3-简单工厂"><a href="#1-3-简单工厂" class="headerlink" title="1.3 简单工厂"></a>1.3 简单工厂</h3><h4 id="UML图-1"><a href="#UML图-1" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.jpg" alt="image"></p><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>将创建对象的代码进行封装。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>根据客户端的条件，动态实例化相关的类。对于客户端来说，去除了与具体产品的依赖。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>由于若要添加逻辑，需要修改工厂类，违背了开闭原则</li></ul><h3 id="1-4-原型模式"><a href="#1-4-原型模式" class="headerlink" title="1.4 原型模式"></a>1.4 原型模式</h3><h4 id="UML图-2"><a href="#UML图-2" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>用原型实例制定创建对象的种类，并且通过拷贝原型这些原型创建新的对象。<br>感觉重点就在于实现了clone方法。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>被复制的对象的所有变量都含有与原来对象相同的值。故所有的对其他对象的引用都仍然指向原来的对象。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>在浅拷贝的基础上，将引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。</p><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ol><li>向客户隐藏制造新实例的复杂性。</li><li>提供让客户能够产生未知类型对象的选项。</li><li>在某些环境下，复制对象比创建新对象更有效。</li></ol><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ol><li>对象的复制有时相当复杂。</li></ol><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol><li>在一个复杂的类层次中，当系统必须从其中的许多类型创建新对象时，可以考虑原型。</li></ol><h3 id="1-5-单例模式"><a href="#1-5-单例模式" class="headerlink" title="1.5 单例模式"></a>1.5 单例模式</h3><h4 id="UML图-3"><a href="#UML图-3" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul><li>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。</li></ul><h4 id="饿汉式单例类"><a href="#饿汉式单例类" class="headerlink" title="饿汉式单例类"></a>饿汉式单例类</h4><p>在类被加载时便将自己实例化。</p><h4 id="懒汉式单例类"><a href="#懒汉式单例类" class="headerlink" title="懒汉式单例类"></a>懒汉式单例类</h4><p>在第一次被引用时将自己实例化。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>多线程的单例，需要加锁，避免同时创建多个实例。</li></ul><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul><li>可以使用单例模式替换全局变量。</li></ul><h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><ul><li>单例模式引入了许多的其他问题，比如在创建单例对象的时候需要加锁。</li></ul><h3 id="1-6-建造者模式（生成器模式）"><a href="#1-6-建造者模式（生成器模式）" class="headerlink" title="1.6 建造者模式（生成器模式）"></a>1.6 建造者模式（生成器模式）</h3><h4 id="UML图-4"><a href="#UML图-4" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><ol><li>将一个复杂对象的创建过程封装起来</li><li>允许对象通过多个步骤来创建，并且可以改变过程。（这和只有一个步骤的工厂模式不同）</li><li>向客户隐藏产品内部的表现。</li><li>产品的实现可以被替换，因为客户只看到一个抽象的接口。</li></ol><h4 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h4><ol><li>与工厂模式相比，采用生成器模式创建对象需要具备更多的领域知识。</li></ol><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><ol><li>经常被用来创建组合结构。</li></ol><h2 id="2-行为型模式"><a href="#2-行为型模式" class="headerlink" title="2. 行为型模式"></a>2. 行为型模式</h2><h3 id="2-1-观察者模式（发布-订阅模式）"><a href="#2-1-观察者模式（发布-订阅模式）" class="headerlink" title="2.1. 观察者模式（发布-订阅模式）"></a>2.1. 观察者模式（发布-订阅模式）</h3><h4 id="UML图：-1"><a href="#UML图：-1" class="headerlink" title="UML图："></a>UML图：</h4><p><img src="http://cdn.ewinds.pw/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><h4 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h4><ol><li>让主题和观察者之间松耦合。它们之间依然可以交互，但是不太清楚彼此的细节，使互相的依赖降到了最低。</li></ol><h4 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h4><h3 id="2-2-模版方法模式"><a href="#2-2-模版方法模式" class="headerlink" title="2.2 模版方法模式"></a>2.2 模版方法模式</h3><h4 id="UML图-5"><a href="#UML图-5" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><p>（注：父类是抽象类）</p><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h4 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h4><p>模板方法模式通过把不变的行为搬移到超类，去除子类中的重复代码来体现它的优势。即当不变的行为和可变的行为在子类中混杂在一起的时候，不变的行为会在子类中重复出现，通过模板方法模式把这些行为搬移到父类或其他的地方，可以帮助子类摆脱重复的不变行为的纠缠。</p><h3 id="2-3-命令模式"><a href="#2-3-命令模式" class="headerlink" title="2.3 命令模式"></a>2.3 命令模式</h3><h4 id="UML图-6"><a href="#UML图-6" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h4><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p><h4 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h4><ol><li>能够容易地设计一个命令队列。</li><li>在需要的情况下，可以容易地将命令记入日志。</li><li>允许接受请求的一方决定是否要否决请求。</li><li>可以容易地实现对请求的撤销和重做。</li><li>由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。</li><li>把请求一个操作的对象与知道怎么执行一个操作的对象分割开。</li></ol><h3 id="2-4-状态模式"><a href="#2-4-状态模式" class="headerlink" title="2.4 状态模式"></a>2.4 状态模式</h3><h4 id="UML图-7"><a href="#UML图-7" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h4><p>当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了这个类。<br>主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况，把状态的判断逻辑转移到表示不同状态的一些列类当中，可以把复杂的判断逻辑简化。</p><h4 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h4><p>将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。</p><h3 id="2-5-职责链模式"><a href="#2-5-职责链模式" class="headerlink" title="2.5 职责链模式"></a>2.5 职责链模式</h3><h4 id="UML图-8"><a href="#UML图-8" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h4><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象可以处理它为止。</p><h4 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h4><p>经常被用在窗口系统中，处理鼠标和键盘之类的事件。</p><h4 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h4><ol><li>可以随时添加或修改处理一个请求的结构。增强了给对象指派职责的灵活性。</li><li>将请求的发送者和接收者解耦。（状态模式两个请求之间仍然存在耦合）</li><li>可以简化Client对象，因为Client对象不需要知道链的结构。</li><li>通过改变指责链内的成员或调动他们的次序，允许使用者动态地新增或删除责任。</li></ol><h4 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h4><p>并不能保证请求一定被执行。<br>不容易观察运行时的特征，有碍于debug。</p><h3 id="2-6-解释器模式"><a href="#2-6-解释器模式" class="headerlink" title="2.6 解释器模式"></a>2.6 解释器模式</h3><h4 id="UML图-9"><a href="#UML图-9" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h4><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>如果一种特定类型的问题发生频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p><h3 id="2-7-中介者模式（调停者模式）"><a href="#2-7-中介者模式（调停者模式）" class="headerlink" title="2.7 中介者模式（调停者模式）"></a>2.7 中介者模式（调停者模式）</h3><h4 id="UML图-10"><a href="#UML图-10" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h4><p>用一个中介对象来封装一系列的对象交互。中介者使各个对象之间不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><h3 id="2-8-访问者模式"><a href="#2-8-访问者模式" class="headerlink" title="2.8 访问者模式"></a>2.8 访问者模式</h3><h4 id="UML图-11"><a href="#UML图-11" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h4><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><h3 id="2-9-策略模式"><a href="#2-9-策略模式" class="headerlink" title="2.9 策略模式"></a>2.9 策略模式</h3><h4 id="UML图-12"><a href="#UML图-12" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h4><p>它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户。</p><h3 id="2-10-备忘录模式"><a href="#2-10-备忘录模式" class="headerlink" title="2.10 备忘录模式"></a>2.10 备忘录模式</h3><h4 id="UML图-13"><a href="#UML图-13" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-15"><a href="#定义-15" class="headerlink" title="定义"></a>定义</h4><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p><h3 id="2-11-迭代器模式"><a href="#2-11-迭代器模式" class="headerlink" title="2.11 迭代器模式"></a>2.11 迭代器模式</h3><h4 id="UML图-14"><a href="#UML图-14" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-16"><a href="#定义-16" class="headerlink" title="定义"></a>定义</h4><p>提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p><p>该模式已经被多种语言所实现为</p><h2 id="3-结构型模式"><a href="#3-结构型模式" class="headerlink" title="3. 结构型模式"></a>3. 结构型模式</h2><h3 id="3-1-适配器模式"><a href="#3-1-适配器模式" class="headerlink" title="3.1 适配器模式"></a>3.1 适配器模式</h3><h4 id="UML图-15"><a href="#UML图-15" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-17"><a href="#定义-17" class="headerlink" title="定义"></a>定义</h4><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><h4 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h4><h3 id="3-2-桥接模式"><a href="#3-2-桥接模式" class="headerlink" title="3.2 桥接模式"></a>3.2 桥接模式</h3><h4 id="UML图-16"><a href="#UML图-16" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-18"><a href="#定义-18" class="headerlink" title="定义"></a>定义</h4><p>Bridge，将抽象部分与它的实现部分分离，使他们都可以独立地变化。</p><ul><li>补充理解1：实现的方式有多种。桥接模式的核心意图就是把这些实现独立出来，让它们各自地变化。这就使得每种实现的变化不会影响其他实现，从而达到应对变化的目的。</li><li>补充理解2：实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。</li></ul><h3 id="3-3-组合模式"><a href="#3-3-组合模式" class="headerlink" title="3.3 组合模式"></a>3.3 组合模式</h3><h4 id="UML图-17"><a href="#UML图-17" class="headerlink" title="UML图"></a>UML图</h4><h5 id="透明模式"><a href="#透明模式" class="headerlink" title="透明模式"></a>透明模式</h5><p><img src="http://cdn.ewinds.pw/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%28%E9%80%8F%E6%98%8E%E6%A8%A1%E5%BC%8F%29.jpg" alt="image"></p><h5 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h5><p><img src="http://cdn.ewinds.pw/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%28%E5%AE%89%E5%85%A8%E6%96%B9%E5%BC%8F%29.jpg" alt="image"></p><h4 id="定义-19"><a href="#定义-19" class="headerlink" title="定义"></a>定义</h4><p>将对象组合成树形结构，以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><ul><li>透明方式：Componet中声明所有用来管理子对象的方法。</li><li>安全方式：Componet接口中不声明管理子对象的方法，而是在Composite中声明所有用来管理子对象的方法。</li></ul><h3 id="3-4-装饰模式"><a href="#3-4-装饰模式" class="headerlink" title="3.4 装饰模式"></a>3.4 装饰模式</h3><h4 id="UML图-18"><a href="#UML图-18" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-20"><a href="#定义-20" class="headerlink" title="定义"></a>定义</h4><p>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p><h3 id="3-5-外观模式"><a href="#3-5-外观模式" class="headerlink" title="3.5 外观模式"></a>3.5 外观模式</h3><h4 id="UML图-19"><a href="#UML图-19" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-21"><a href="#定义-21" class="headerlink" title="定义"></a>定义</h4><ul><li>外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li></ul><h4 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h4><ul><li>符合迪米特法则</li><li>符合依赖倒置原则</li></ul><h3 id="3-6-享元模式"><a href="#3-6-享元模式" class="headerlink" title="3.6 享元模式"></a>3.6 享元模式</h3><h4 id="UML图-20"><a href="#UML图-20" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-22"><a href="#定义-22" class="headerlink" title="定义"></a>定义</h4><ul><li>Flyweight，运用共享技术有效地支持大量细粒度的对象。</li><li>享元对象的内部状态：不会随环境改变而改变的共享部分。</li><li>享元对象的外部状态：随环境改变而改变的、不可以共享的状态。 </li></ul><h4 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h4><p>节约存储空间。</p><h4 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h4><p>需要将部分状态外部化，使得逻辑更为复杂，</p><h3 id="3-7-代理模式"><a href="#3-7-代理模式" class="headerlink" title="3.7 代理模式"></a>3.7 代理模式</h3><h4 id="UML图-21"><a href="#UML图-21" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-23"><a href="#定义-23" class="headerlink" title="定义"></a>定义</h4><p>为其他对象提供一种代理以控制这个对象的访问。</p><h4 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h4><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>远程代理</li><li>虚拟代理</li><li>安全代理</li></ul>]]></content>
    
    <summary type="html">
    
      23种设计模式，包括设计模式的UML图、定义、优缺点及java代码实现
    
    </summary>
    
      <category term="软件设计" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="软件设计" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《白日梦》 北岛</title>
    <link href="http://yoursite.com/2018/04/23/daydream/"/>
    <id>http://yoursite.com/2018/04/23/daydream/</id>
    <published>2018-04-23T15:40:50.000Z</published>
    <updated>2020-04-22T15:48:02.635Z</updated>
    
    <content type="html"><![CDATA[<p>封面图来自：爆裂鼓手</p><a id="more"></a><hr><h2 id="《白日梦》"><a href="#《白日梦》" class="headerlink" title="《白日梦》"></a><center>《白日梦》</center></h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>在秋天的暴行之后<br>这十一月被冰霜麻醉<br>展平在墙上<br>影子重重叠叠<br>那是骨骼石化的过程<br>你没有如期归来<br>我喉咙里的果核<br>变成了温暖的石头</p><p>我，行迹可疑<br>新的季节的阅兵式<br>敲打我的窗户<br>住在钟里的人们<br>带着摆动的心脏奔走<br>我俯视时间<br>不必转身<br>一年的黑暗在杯中</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>音乐释放的蓝色灵魂<br>在烟蒂上飘摇<br>出入门窗的裂缝</p><p>一个准备切开的苹果<br>–那里没有核儿<br>没有生长敌意的种子<br>远离太阳的磁场<br>玻璃房子里生长的头发<br>如海藻，避开真实的</p><p>风暴，我们是<br>迷失在航空港里的儿童<br>总想大哭一场</p><p>在宽银幕般的骚动中<br>收集烟尘的鼻子<br>碰到一起<br>说个不停，这是我<br>是我<br>我，我们</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>喃喃梦呓的<br>书，排列在一起<br>在早晨三点钟<br>等待异端的火箭</p><p>时间并不忧郁<br>我们弃绝了山林湖泊<br>集中在一起<br>为什么我们在一起<br>一只铁皮乌鸦<br>在大理石的底座下<br>那永恒的事物的焊接处<br>不会断裂</p><p>人们从石棺里醒来<br>和我坐在一起<br>我们生前与时代合影<br>挂在长桌尽头</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>你没有如期归来<br>而这正是离别的意义<br>一次爱的旅行<br>有时候就象抽烟那样<br>简单</p><p>地下室空守着你<br>内心的白银<br>水仙花在暗中灿然开放<br>你听凭所有的坏天气<br>发怒、哭喊<br>乞求你打开窗户</p><p>书页翻开<br>所有的文字四散<br>只留下一个数字<br>–我的座位号码<br>靠近窗户<br>本次列车的终点是你</p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>向日葵的帽子不翼而飞<br>石头圆滑、可靠<br>保持着本质的完整<br>在没有人居住的地方<br>山也变得年轻<br>晚钟不必解释什么<br>巨蟒在蜕皮中进化<br>–绳索打结<br>把鱼群悬挂在高处<br>一潭死水召来无数闪电<br>虎豹的斑纹渐成蓝色<br>天空已被吞噬</p><p>历史静默<br>峭壁目送着河上<br>那自源头漂流而下的孩子<br>这人类的孩子</p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>我需要广场<br>一片空旷的广场<br>放置一个碗，一把小匙<br>一只风筝孤单的影子</p><p>占据广场的人说<br>这不可能</p><p>笼中的鸟需要散步<br>梦游者需要贫血的阳光<br>道路撞击在一起<br>需要平等的对话</p><p>人的冲动压缩成<br>铀，存放在可靠的地方</p><p>在一家小店铺<br>一张纸币，一片剃刀<br>一包剧毒的杀虫剂<br>诞生了</p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>我死的那年十岁<br>那抛向空中的球再也没<br>落到地上<br>你是唯一的目击者<br>十岁，我知道<br>然后我登上<br>那辆运载野牛的火车<br>被列入过期的提货单里<br>供人们阅读</p><p>今天早上<br>一只鸟穿透我打开的报纸<br>你的脸嵌在其中<br>一种持久的热情<br>仍在你的眼睛深处闪烁<br>我将永远处于<br>你所设计的阴影中</p><h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>多少年<br>多少火种的逃亡者<br>使日月无光<br>白马展开了长长的绷带<br>木桩钉进了煤层<br>渗出殷红的血<br>毒蜘蛛弹拨它的琴弦<br>从天而降<br>开阔地，火球滚来滚去</p><p>多少年<br>多少河流干涸<br>露出那隐秘的部分<br>这是座空荡荡的博物馆<br>谁置身其中<br>谁就会自以为是展品<br>被无形的目光注视<br>如同一颗湖泊爆炸后<br>飞出的沉睡千年的小虫</p><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p>终于有一天<br>谎言般无畏的人们<br>从巨型收音机里走出来<br>赞美着灾难<br>医生举起白色的床单<br>站在病树上疾呼：<br>是自由，没有免疫的自由<br>毒害了你们</p><h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><p>手在喘息<br>流苏是呻吟<br>雕花的窗棂互相交错<br>纸灯笼穿过游廊<br>在尽头熄灭<br>一支箭敲响了大门</p><p>牌位接连倒下<br>–连锁反应的恶梦<br>子孙们<br>是威严的石狮嘴里<br>腐烂的牙齿</p><p>当年锁住春光的庭院<br>只剩下一棵树<br>他们在酒后失态<br>围着树跳舞<br>疯狂是一种例外</p><h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><p>别把你的情欲带入秋天<br>这残废者的秋天<br>打着响亮呼哨的秋天</p><p>一只女人干燥的手<br>掠过海面，却滴水未沾<br>推移礁石的晚霞<br>是你的情欲<br>焚烧我</p><p>我，心如枯井<br>对海洋的渴望使我远离海洋<br>走向我的开端–你<br>或你的尽头–我</p><p>我们终将迷失在大雾中<br>互相呼唤<br>在不同的地点<br>成为无用的路标</p><h3 id="12"><a href="#12" class="headerlink" title="12"></a>12</h3><p>白色的长袍飘向那<br>不存在的地方<br>心如夏夜里抽搐的水泵<br>无端地发泄<br>黄昏的晚宴结束了<br>山峦散去<br>蜉蝣在水上写诗<br>地平线的颂歌时断时续<br>影子并非一个人的历史<br>戴上或摘下面具<br>花朵应运而生<br>谎言与悲哀不可分离<br>如果没有面具<br>所有钟表还有什么意义</p><p>当灵魂在岩石是显出原形<br>只有鸟会认出它们</p><h3 id="13"><a href="#13" class="headerlink" title="13"></a>13</h3><p>他指银色的沼泽说<br>那里发生过战争<br>几棵冒烟的树在地平线飞奔<br>转入地下的士兵和马<br>闪着磷光，日夜<br>追随着将军的铠甲</p><p>而我们追随的是<br>思想的流弹中<br>那逃窜的自由的兽皮</p><p>昔日阵亡者的头颅<br>如残月升起<br>越过沙沙作响的灌木丛<br>以预言家的口吻说<br>你们并非幸存者<br>你们永无归宿</p><p>新的思想呼啸而过<br>击中时代的背影<br>一滴苍蝇的血让我震惊</p><h3 id="14"><a href="#14" class="headerlink" title="14"></a>14</h3><p>我注定要坐在岸边<br>在一张白纸上<br>期待着老年斑纹似的词</p><p>出现，秩序与混乱<br>蜂房酿造着不同的情欲<br>九十九座红色的山峰</p><p>上涨，空气稀薄<br>地衣居心叵测地蔓延<br>渺小，如尘世的</p><p>计谋，钢筋支撑着权利<br>石头也会晕眩<br>这毕竟是一种可怕的</p><p>高度，白纸背面<br>孩子的手在玩影子游戏<br>光源来自海底两条交尾的<br>电鳗</p><h3 id="15"><a href="#15" class="headerlink" title="15"></a>15</h3><p>蹲伏在瓦罐的夜<br>溢出清凉的<br>水，那是我们爱的源泉</p><p>回忆如伤疤<br>我的一生在你的脚下<br>这流动的沙丘<br>凝聚在你的手上<br>成为一颗眩目的钻石</p><p>没有床，房间<br>小得使我们无法分离<br>四壁薄如棉纸<br>数不清的嘴巴画在墙上<br>低声轮唱</p><p>你没有如期归来<br>我们共同啜饮的杯子<br>砰然碎裂</p><h3 id="16"><a href="#16" class="headerlink" title="16"></a>16</h3><p>矿山废弃已久<br>它的金属拉成细长的线</p><p>猫头鹰通体透明<br>胃和神经丛掠过夜空</p><p>古生物的联盟解体了<br>粘合化石的工作</p><p>仍在进行，生存<br>永远是一种集体冒险</p><p>生存永远是和春天<br>在进行战争</p><p>绿色的履带碾过<br>阴郁的文明</p><p>喷射那水银的喷泉<br>金属的头改变了地貌</p><h3 id="17"><a href="#17" class="headerlink" title="17"></a>17</h3><p>几个世纪过去了<br>一日尚未开始<br>冷空气触摸了我的手<br>螺旋楼梯般上升<br>黑与白，光线<br>在房瓦的音阶上转换<br>一棵枣树的安宁<br>男人的喉咙成熟了</p><p>动物园的困兽<br>被合进一本书<br>钢鞭飞舞<br>悸动着的斑斓色彩<br>隔着漫长的岁月<br>凄厉地叫喊<br>一张导游图把我引入<br>城中之星星狡黠而凶狠<br>象某一事物的核心</p><h3 id="18"><a href="#18" class="headerlink" title="18"></a>18</h3><p>我总是沿着那条街的<br>孤独的意志漫步<br>喔，我的城市<br>在玻璃的坚冰上滑行</p><p>我的城市我的故事<br>我的水龙头我积怨<br>我的鹦鹉我的<br>保持平衡的睡眠</p><p>罂粟花般芳香的少女<br>从超级市场飘过<br>带着折刀般表情的人们<br>共饮冬日的寒光</p><p>诗，就象阳台一样<br>无情地折磨着我<br>被烟尘粉刷的墙<br>总在意料之中</p><h3 id="19"><a href="#19" class="headerlink" title="19"></a>19</h3><p>当你转身的时候<br>花岗石崩裂成细细的流沙<br>你用陌生的语调<br>对空旷说话，不真实<br>如同你的笑容</p><p>深深植入昨天的苦根<br>是最黑暗处的闪电<br>击中了我们想象的巢穴<br>从流沙的瀑布中<br>我们听见了水晶撞击的音乐</p><p>一次小小的外科手术<br>我们挖掘燧石的雪地上<br>留下了麻雀的爪印<br>一辆冬天疯狂的马车<br>穿过夏日的火焰</p><p>我们安然无恙<br>四季的美景印在你的衣服上</p><h3 id="20"><a href="#20" class="headerlink" title="20"></a>20</h3><p>放牧是一种观点的陈述<br>热病使羊群膨胀<br>象一个个气球上升<br>卡在天蝎星座中<br>热风卷走了我的屋顶<br>在四壁之内<br>我静观无字的天空<br>文化是一种共生现象<br>包括羊的价值<br>狼的原则<br>钟罩里一无所有<br>在我们的视野里<br>只有一条干涸的河道<br>几缕笔直的烟<br>古代圣贤们<br>无限寂寞<br>垂钓着他们的鱼</p><h3 id="21"><a href="#21" class="headerlink" title="21"></a>21</h3><p>诡秘的豆荚有五只眼睛<br>它们不愿看见白昼<br>只在黑暗里倾听</p><p>一种颜色是一个孩子<br>诞生时的啼哭</p><p>宴会上桌布洁白<br>杯中有死亡的味道<br>–悼词库挥发的沉闷气息</p><p>传统是一张航空照片<br>山河缩小成桦木的纹理</p><p>总是人，俯首听命于<br>说教、仿效、争斗<br>和他们的尊严</p><p>寻找激情的旅行者<br>穿过候鸟荒凉的栖息地</p><p>石膏像打开窗户<br>艺术家从背后<br>用工具狠狠地敲碎它们</p><h3 id="22"><a href="#22" class="headerlink" title="22"></a>22</h3><p>弱音器弄哑了的小号<br>忽然响亮地哭喊<br>那伟大悲剧的导演<br>正悄悄地死去<br>两只装着滑轮的狮子<br>仍在固定的轨道上<br>东奔西撞</p><p>曙光瘫痪在大街上<br>很多地址和名字和心事<br>在邮筒在夜里避雨<br>货车场的鸭子喧哗<br>窗户打着哈欠<br>一个来苏水味的早晨<br>值班医生正填写着死亡报告</p><p>悲剧的伟大意义呵<br>日常生活的琐碎细节</p><h3 id="23"><a href="#23" class="headerlink" title="23"></a>23</h3><p>在昼与夜之间出现了裂缝</p><p>语言突然变得陈旧<br>象第一场雪<br>那些用黑布蒙面的证人<br>紧紧包围了你<br>你把一根根松枝插在地上<br>默默点燃它们</p><p>那是一种祭奠的仪式<br>从死亡的山冈上<br>我居高临下<br>你是谁<br>要和我交换什么<br>白鹤展开一张飘动的纸<br>上面写着你的回答<br>而我一无所知</p><p>你没有如期归来</p>]]></content>
    
    <summary type="html">
    
      现代诗
    
    </summary>
    
      <category term="现代诗" scheme="http://yoursite.com/categories/%E7%8E%B0%E4%BB%A3%E8%AF%97/"/>
    
    
      <category term="诗歌" scheme="http://yoursite.com/tags/%E8%AF%97%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title>vim中文乱码的解决方案</title>
    <link href="http://yoursite.com/2017/10/27/vim%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2017/10/27/vim中文乱码的解决方案/</id>
    <published>2017-10-27T07:11:50.000Z</published>
    <updated>2020-04-22T15:48:01.135Z</updated>
    
    <content type="html"><![CDATA[<p>「封面图：VIM图标」</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>出现上述现象是编码出了问题。</p><ol><li>执行<code>sudo vim ~/.vimrc</code></li><li><p>输入</p><p> set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936<br> set termencoding=utf-8<br> set encoding=utf-8</p></li></ol><h2 id="成功解决乱码。"><a href="#成功解决乱码。" class="headerlink" title="成功解决乱码。"></a>成功解决乱码。</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="为什么要改变vimrc文件"><a href="#为什么要改变vimrc文件" class="headerlink" title="为什么要改变vimrc文件"></a>为什么要改变vimrc文件</h4><p><code>vimrc</code>文件用于初始化vim。使用vim时，vim会到指定目录下寻找vimrc并用其进行初始化。更多的内容见<code>:help vimrc</code>，通过<code>version</code>，可以看到vim规定的vimrc文件路径。例如我的：</p><pre><code>system vimrc file: &quot;$VIM/vimrc&quot;user vimrc file: &quot;$HOME/.vimrc&quot;2nd user vimrc file: &quot;~/.vim/vimrc&quot;user exrc file: &quot;$HOME/.exrc&quot;fall-back for $VIM: &quot;/usr/share/vim&quot;</code></pre><h4 id="编辑内容的含义是什么？"><a href="#编辑内容的含义是什么？" class="headerlink" title="编辑内容的含义是什么？"></a>编辑内容的含义是什么？</h4><p>（1） 磁盘文件的字符编码<br>存放在磁盘上的文本文件，是按照一定的字符编码进行保存的，不同的文件可能使用了不同的字符编码。<br>这在VIM中被叫做：fileencoding。</p><p>（2） VIM缓冲区以及界面的字符编码<br>VIM运行时，其菜单、标签、以及各个缓冲区统一使用一种字符编码方式。<br>这在VIM中被叫做：encoding。</p><p>（3) 终端使用的字符编码<br>终端同一时刻只能使用一种字符编码，并按照这种编码从接收到的字节流中识别字符，并显示，终端的字符编码是可以动态调整的。<br>这在VIM中被叫做：termencoding。</p><p>可以看出，VIM涉及到的3种字符编码之间的转换：<br>读：fileencoding—–&gt; encoding<br>显：encoding ——&gt; termencoding<br>写：encoding ——-&gt; fileencoding</p><h4 id="那些字符编码"><a href="#那些字符编码" class="headerlink" title="那些字符编码"></a>那些字符编码</h4><p>UTF-8（8-bit Unicode Transformation Format）：是一种针对Unicode的可变长度字符编码，又称万国码。 支持中文。</p><p>UCS（通用字符集）：包含了用于表达所有已知语言的字符，保证了与其他字符集的双向兼容， 是所有其他字符集标准的一个超集。支持中文。Unicode规范中推荐的标记字节顺序的方法是BOM。BOM是Byte Order Mark。在UCS编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。</p><p>gb18030、gbk、gb2312肯定是支持中文的编码。</p><p>CP936其实就是GBK，IBM在发明Code Page的时候将GBK放在第936页，所以叫CP936。</p><p>参考资料： <a href="http://blog.csdn.net/smstong/article/details/51279810" target="_blank" rel="noopener">http://blog.csdn.net/smstong/article/details/51279810</a><br>参考资料： <a href="http://www.fmddlmyy.cn/text6.html" target="_blank" rel="noopener">http://www.fmddlmyy.cn/text6.html</a><br>参考资料： <a href="https://www.zhihu.com/question/35609295" target="_blank" rel="noopener">https://www.zhihu.com/question/35609295</a></p>]]></content>
    
    <summary type="html">
    
      vim中文乱码解决方案。
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>解决代码换行导致元素间出现空格间距的一些方案</title>
    <link href="http://yoursite.com/2017/10/14/%E6%8D%A2%E8%A1%8C%E9%80%A0%E6%88%90%E7%A9%BA%E6%A0%BC%E9%97%B4%E8%B7%9D%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2017/10/14/换行造成空格间距的解决方案/</id>
    <published>2017-10-14T03:35:30.000Z</published>
    <updated>2020-03-15T02:01:52.341Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写东西的时候总是碰见一些莫名奇妙的bug。</p><a id="more"></a><p>在使用<code>display:inline-block</code>属性时经常会两个元素之间莫名奇妙出现空白。</p><p>空白是因代码中的换行产生的，以下是解决方案。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>使用margin移动至合适位置</li><li>代码不进行换行</li><li>设置任意父级块的字体大小为0</li><li>视情况改为浮动布局</li><li><p>将两个标签中间的空白部分进行注释</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> /&gt;</span><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   --&gt;</span><span class="tag">&lt;<span class="name">input</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>将闭合标签<code>&gt;</code>放到下一个标签的开始处</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">   /&gt;</span><span class="tag">&lt;<span class="name">input</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      关于attribute和property的区别
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>「写给大家看的设计书」</title>
    <link href="http://yoursite.com/2017/08/07/%E3%80%8C%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E3%80%8D/"/>
    <id>http://yoursite.com/2017/08/07/「写给大家看的设计书」/</id>
    <published>2017-08-07T08:05:50.000Z</published>
    <updated>2020-04-09T12:49:21.717Z</updated>
    
    <content type="html"><![CDATA[<p>不懂设计的前端不是一个好前端 =。=！</p><a id="more"></a><h2 id="笔记部分"><a href="#笔记部分" class="headerlink" title="笔记部分"></a>笔记部分</h2><h3 id="PART1：「设计原则」"><a href="#PART1：「设计原则」" class="headerlink" title="PART1：「设计原则」"></a>PART1：「设计原则」</h3><h4 id="第一章：「引言」"><a href="#第一章：「引言」" class="headerlink" title="第一章：「引言」"></a>第一章：「引言」</h4><p>通过<strong>约书亚树</strong>作为引言。</p><p>作者试图用关于这棵树的小故事说明一个道理：如果能说出一个物品的名称，那么在日常生活中你就会经常注意到它。<strong>掌握它，拥有它，让它受你所控</strong>。</p><p>类比于学习，差不多的道理。可能效果没那么明显，因为对于一些名词，你没有理解它原理性内容，见到次数再多也不会拥有它。但知道它的名称，总归是揭下它神秘面纱的第一步。</p><ul><li>4大基本原则<ol><li>对比</li><li>重复</li><li>对齐</li><li>亲密性</li></ol></li></ul><h4 id="第二章：「亲密性」"><a href="#第二章：「亲密性」" class="headerlink" title="第二章：「亲密性」"></a>第二章：「亲密性」</h4><ul><li>物理位置的接近就意味着存在关联。</li><li>把相关的元素分在一组，使他们建立更近的亲密性。</li><li>亲密性的根本目的是实现组织性。</li></ul><h4 id="第三章：「对齐」"><a href="#第三章：「对齐」" class="headerlink" title="第三章：「对齐」"></a>第三章：「对齐」</h4><ul><li>任何元素都不能在页面上随意安放。每一项都应当与页面上的某个内容存在某种视觉联系。</li><li>采用同一种对齐方式的元素会产生一种「边界强度」，其为布局提供力度。</li><li>勇敢一些，不要畏缩！</li><li>一个页面只使用一种对齐方式。</li><li>可以有意为之打破边界，如将插图斜着插入边界，只要效果比原来更好。不必过于拘束。勇敢一些，不要畏缩！</li><li>在打破规则前必须清楚规则是什么。</li><li>对齐也会使元素之间产生视觉联系。</li><li>对齐的根本目的是使页面统一而且由条理。</li></ul><h4 id="第四章：「重复」"><a href="#第四章：「重复」" class="headerlink" title="第四章：「重复」"></a>第四章：「重复」</h4><ul><li>设计的某些方面需要在整个作品中重复。</li><li>在一系列作品中尤其需要注意重复。</li><li>重复的目的就是统一， 并增强视觉效果。</li></ul><h4 id="第五章：「对比」"><a href="#第五章：「对比」" class="headerlink" title="第五章：「对比」"></a>第五章：「对比」</h4><ul><li>页面的元素之间要有对比效果，达到吸引读者的对比效果。</li><li>对比的根本目的有两个。一个目的是增强页面的效果，如果一个页面看起来很有意思，往往更有可读性。另一个目的是有助于信息的组织。</li></ul><h4 id="第六章：「4大基本原则复习」"><a href="#第六章：「4大基本原则复习」" class="headerlink" title="第六章：「4大基本原则复习」"></a>第六章：「4大基本原则复习」</h4><ul><li><strong>不要畏畏缩缩！</strong></li></ul><h4 id="第七章：「颜色运用」"><a href="#第七章：「颜色运用」" class="headerlink" title="第七章：「颜色运用」"></a>第七章：「颜色运用」</h4><ul><li>色轮<ul><li>三原色(tricolor):红黄蓝，色轮的基础。这三种颜色无法创建。</li><li><img src="http://opqksc9nz.bkt.clouddn.com/%E4%B8%89%E5%8E%9F%E8%89%B2.jpg" alt="三原色"></li><li>三间色(secondary color):将三原色色轮上相邻颜色<strong>等量</strong>混合，形成三间色。分别为橙、绿、紫色。</li><li><img src="http://opqksc9nz.bkt.clouddn.com/%E4%B8%89%E9%97%B4%E8%89%B2.jpg" alt="三间色"></li><li>第三色(tertiary colour):再将空白两边的颜色按<strong>等量</strong>混合，形成第三色。</li><li><img src="http://opqksc9nz.bkt.clouddn.com/%E7%AC%AC%E4%B8%89%E8%89%B2.jpg" alt="第三色"></li><li>「互补色」:色轮上相对(完全对立)的颜色。通常一种作为主色，另一种用来强调。</li><li>「三色组」:色轮上彼此等距的三种颜色形成的让人愉悦的三色组。<ul><li>「基色三色组」:红黄蓝。</li><li>「间色三色组」：绿橙紫</li><li>还有两组，作者没有细分，不作累述。</li></ul></li><li>「分裂互补三色组」:从色轮的一遍选择一种颜色，再从色轮上找到其对面的互补色两侧的颜色。具有更细致的颜色边界。</li><li>「类似色」:由色轮上彼此相邻的颜色构成。</li></ul></li><li>暗色和亮色<ul><li>基本色轮只涉及纯「色调」，即纯色。还可向其添加黑色或者白色，对色轮进行扩展。</li><li>纯色就是色调。</li><li>向色调增加黑色就构成一个暗色。</li><li>向色调增加一个白色构成一个亮色。</li><li>「单色组合」:由一种色调及其相应的多种亮色和暗色组成。</li><li>「暗色组合」:由暗色和亮色进行组合，不使用色调。</li></ul></li><li>注意色质<ul><li>「色质」:某种颜色的特定明暗度、深浅度或色调。</li><li>颜色组合导致视觉抖动:色质过于接近。</li><li><strong>避免让类似色质的色调挨在一起！</strong></li></ul></li><li>暖色与冷色<ul><li>「暖色」:其中包含红色或黄色。通过对颜色加此种颜色可以对颜色”加热”。</li><li>「冷色」:其中包含蓝色。通过对颜色加此种颜色可以对颜色”降温”</li><li>冷色趋于做背景色，为后退型。</li><li>暖色为趋进型。</li><li>在冷色和暖色的搭配中，少用暖色。</li></ul></li><li>两种颜色模型<ul><li>「CMYK」:Cyan(一种蓝色)、Magenta(一种红、粉红色)、Yellow(黄色)、Key(黑色)。<ul><li>「四色处理」:这四种颜色可以打印出成千上万种颜色。</li></ul></li><li>「RGB」:Red(红色)、Green(绿色)、Blue(蓝色)<ul><li>红色混合绿色可以产生黄色。</li><li>red、yellow、blue为颜料三原色。rgb为光学三原色。</li></ul></li><li><strong>需要印刷的项目应当使用CMYK</strong></li><li><strong>需要在屏幕上看到的内容则应使用RGB</strong></li></ul></li></ul><h4 id="第八章：「创建包装或品牌」"><a href="#第八章：「创建包装或品牌」" class="headerlink" title="第八章：「创建包装或品牌」"></a>第八章：「创建包装或品牌」</h4><ul><li>创建包装或品牌<ul><li>必须有某个标识性图像或某种标识性风格。</li></ul></li><li>企业名片</li><li>信笺和信封</li><li>传单</li><li>新闻简报</li><li>宣传册</li><li>明信片</li><li>报纸广告</li><li>简历</li></ul><h3 id="PART2：「字体设计」"><a href="#PART2：「字体设计」" class="headerlink" title="PART2：「字体设计」"></a>PART2：「字体设计」</h3><h4 id="第九章：「字体的基本规则」"><a href="#第九章：「字体的基本规则」" class="headerlink" title="第九章：「字体的基本规则」"></a>第九章：「字体的基本规则」</h4><ul><li>关于英语:标点后面加一个空格。作者是以英文做的示例， 不知道对中文是否适用。 好像不是很适用。 看上去总觉得怪怪的。</li><li>引号<ul><li>印刷引号:“66和99”</li><li>打字机引号:”竖杠引号”</li><li>问号和感叹号如果属于引用的一部分就出现在引号内。</li><li>问号和感叹号如果不属于引用的一部分就出现在引号外。</li></ul></li><li>撇号<ul><li>使用印刷撇号！！！’’’</li><li>省略字母：除了所属性词语之外，撇号意味着省略一个字母如：isn’t Rock’n’Roll，注意是99不是69！</li><li>撇号是9！</li></ul></li><li>连接号<ul><li>连字符<ul><li>odd-looking-critters</li><li>在转行时放在单词的前半部之后，用于断词。</li></ul></li><li>一字线<ul><li>「如何输入」:中文的破折号由两个一字线组成，所以其为破折号的一半，在中文打字法，输入中文的模式下，按下shift+0旁边的键(即连字符)，再删除一次横线，剩下的即为一字线。</li><li>一字线意味着一个持续事件，也可用to代替，前后无空格。例如：7:30—9:30pm</li><li>「宽度」:类似大写字母N的宽度</li></ul></li><li>破折号<ul><li>表示思想的突然变化。</li><li>「宽度」:即中文的破折号，一字线的两倍。</li><li>表意强度:句号&gt;破折号&gt;逗号</li><li>两侧无空格。</li></ul></li></ul></li><li>特殊符号<ul><li>PC上的特殊符号<ul><li>ANSI编码:alt+数字键</li><li>重音符号:alt+数字键</li></ul></li><li>MAC上的特殊符号<ul><li>shift/option+字符</li></ul></li></ul></li><li>大写字母<ul><li>全部大写比全部小写难以阅读，因为大写字母没有轮廓形状变化。</li></ul></li><li>下划线<ul><li>永远不要使用。</li><li>代替：<strong>粗体字</strong>、大号字、不同的字体、颜色。</li></ul></li><li>字距调整<ul><li>「字距调整」:挪动字符间距.</li><li>通常值针对与英语，因为字符键可能存在较大缝隙。</li></ul></li><li>寡妇和孤儿<ul><li>「寡妇」:一段文字的最后一行字符数少于7个。</li><li>「孤儿」:一段的最后一行由于太长而和其他文字分开，在下一栏或下一页的最上面结束。</li></ul></li><li>其他<ul><li>跟随在有样式的文字后的标点与文字样式一样。</li><li>括号中的标点<ul><li>如果括号中的文字是整个句子的一部分，标点在闭括号外。</li><li>括号内的文字是一个完整的句子，标点在括号内。</li></ul></li><li>段落缩进或段落进空行：二者只可选其一。因为都代表“下文为新的一段”的意思。</li><li>首段:不一定需要缩进。</li><li>方框内的文字:尽量在放扩四周留够空间，不要太挤。</li><li>在列表中使用项目符号或装饰符号，而不是连字符。</li></ul></li></ul><h4 id="第十章：「字体（与人生）」"><a href="#第十章：「字体（与人生）」" class="headerlink" title="第十章：「字体（与人生）」"></a>第十章：「字体（与人生）」</h4><ul><li>协调与冲突<ul><li>「协调」:只使用一个字体系列，样式、大小、字体粗细无变化。</li><li>「冲突」:结合使用多个字体系列，很类似但并不相同。</li><li>「对比」:结合的多种字体和元素彼此之间并不相同。</li><li>协调是一个稳妥有用的概念，但冲突务必要避免。</li><li>字体对比存在6种明确的不同方式:大小、粗细、结构、形状、方向和颜色。</li></ul></li></ul><h4 id="第十一章：「字体类别」"><a href="#第十一章：「字体类别」" class="headerlink" title="第十一章：「字体类别」"></a>第十一章：「字体类别」</h4><ul><li>「OldStyle」 旧式体<ul><li>都有衬线，且小写字母衬线存在角度。</li><li>「粗细过渡」:曲线笔画存在一种从粗到细的变化。</li><li>「适合阅读」</li><li>「对角强调线」:曲线最细部分的一条线。 </li></ul></li><li>「Modern」 现代体<ul><li>都有衬线，衬线水平。</li><li>「剧烈粗细过渡」:曲线笔画存在一种剧烈的从粗到细的变化。</li><li>强调线完全垂直。</li><li>「不适合大量显示正文」</li></ul></li><li>「Slab serif」 粗衬线体<ul><li>都有衬线。</li><li>「几乎不存在粗细过渡」</li><li>适合阅读。尤其是小孩。</li></ul></li><li>「Sans serif」 无衬线体<ul><li>「Sans」:法语“没有”。</li><li>没有衬线。</li><li>「几乎不存在粗细过渡」</li><li>页面中使用或许有奇效。</li></ul></li><li>「Script」 手写体<ul><li>很漂亮。</li><li>花里胡哨。</li><li>但是要少用。</li></ul></li><li>「Decorative」 花体<ul><li>各种奇效。</li></ul></li></ul><h4 id="第十二章：「字体对比」"><a href="#第十二章：「字体对比」" class="headerlink" title="第十二章：「字体对比」"></a>第十二章：「字体对比」</h4><ul><li>对比6要素：<ol><li>大小</li><li>粗细</li><li>结构</li><li>形状</li><li>方向</li><li>颜色</li></ol></li><li>「必须选取两个不同字体类别中的字体」不要把同一个类别中的两个自体放在同一个页面上。</li></ul><h2 id="最后说说"><a href="#最后说说" class="headerlink" title="最后说说"></a>最后说说</h2><p>花了近四个小时的时间整理，要把内容回顾了一遍。</p><p>多少还是有点收获吧，虽然方法笨。</p><p>贵有恒，何必担心收获不够多。</p>]]></content>
    
    <summary type="html">
    
      本文是读书笔记兼读后感。
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>关于Attribute和property的区别</title>
    <link href="http://yoursite.com/2017/08/01/Attribute%E2%80%98n&#39;property/"/>
    <id>http://yoursite.com/2017/08/01/Attribute‘n&#39;property/</id>
    <published>2017-08-01T02:39:50.000Z</published>
    <updated>2020-04-22T15:46:03.628Z</updated>
    
    <content type="html"><![CDATA[<p>阅读提示：</p><ol><li>本篇文章中的attribute，全部翻译为“属性”。而property，全部翻译为“特性”。</li><li>点表示法指js对象通过“.”获取特性，方括号表示法指js对象通过“[]”获取特性。</li></ol><a id="more"></a><h2 id="抛砖"><a href="#抛砖" class="headerlink" title="抛砖"></a>抛砖</h2><p>前段时间，有位学长问了我一个题目：在html文档中，给一个标签添加了一个属性，但是js通过点表示法无法对其进行引用。这是为什么？</p><p>当时我是脸上是大写的“懵”字。于是乎写了段代码进行尝试，如图：<br><img src="http://opqksc9nz.bkt.clouddn.com/attribute1.png" alt="啊图片"><br><img src="http://opqksc9nz.bkt.clouddn.com/attribute2.png" alt="啊图片"><br><img src="http://opqksc9nz.bkt.clouddn.com/attribute3.png" alt="啊图片"></p><p>点击标题后，并没有返回value的值，而是undefined。结果很是出人意料。<br>再做一次实验，这回获取的是DOM对象的id，代码及结果如下</p><p><img src="http://opqksc9nz.bkt.clouddn.com/attribute4.png" alt="啊图片"><br><img src="http://opqksc9nz.bkt.clouddn.com/attribute5.png" alt="啊图片"><br><img src="http://opqksc9nz.bkt.clouddn.com/attribute6.png" alt="啊图片"></p><p>对比两次的结果，是不是感觉非常奇怪？</p><h2 id="引玉"><a href="#引玉" class="headerlink" title="引玉"></a>引玉</h2><p>关系到点表示法、括号表示法与”getAttribute”和”Attribute”与”Property”的区别了。</p><p>首先，为什么取不到value属性的值呢？</p><p>在入门的时候，我们应该都学过这两种操作方式，对一个对象用点表示法或方括号表示法，表示获取该对象的属性。对象的getAttribute方法，也可获取对象的属性。但是，此属性非彼属性，一个是Attribute，另一个是property。</p><p>那么，为什么给”&lt;\h3&gt;”标签设置的value，只添加了Attributes中value的值呢？</p><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>打开我们的神器——开发人员工具，选择</p><h3>的DOM节点后，在Elements选项卡下找到Properties，如图：<p></p><p><img src="http://opqksc9nz.bkt.clouddn.com/attribute7.png" alt="啊图片"></p><p>仔细观察上边的键值对，是不是有一个叫做attributes的键？</p><p><img src="http://opqksc9nz.bkt.clouddn.com/attribute8.png" alt="啊图片"></p><p>而我们的id、value都在里边有所显示。继续展开0:id、1:value来一探究竟。</p><p><img src="http://opqksc9nz.bkt.clouddn.com/attribute9.png" alt="啊图片"></p><p><img src="http://opqksc9nz.bkt.clouddn.com/attribute10.png" alt="啊图片"></p><p>可以发现，二者展开后都具有nodeValue字段，并且他们的值为html标签中的属性值。</p><p>但是在properties中，我们可以找到名为id的键，且其绑定值为myHeader，而无法找到名叫value的键。可见，我们在html标签中声明的id，同时存在于property和attribute中，而value只在attribute中具有。</p><p>之所以会出现“抛砖”中的现象，是因为点表示法和方括号表示法，获取到的是对象的property，而getAttribute方法获取的是对象的Attributes。</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><h4 id="Question"><a href="#Question" class="headerlink" title="Question:"></a>Question:</h4><p>为什么在html标签中声明的不同属性，一个存在于对象的property，而另一个在对象的property和attribute中都存在呢？</p><h4 id="Answer"><a href="#Answer" class="headerlink" title="Answer:"></a>Answer:</h4><p>区分以下几种情况：</p><ol><li>在html标签申明属性。<ol><li>若该属性在对象的property中存在，properties和attributes二者都可能会更新（若有特殊限制，如dir，对于值的格式有要求，则有可能在property中不会更新）</li><li>若属性不存在对象的property中，则只会在attributes中刷新。</li></ol></li><li>通过js添加属性<ol><li>如果是通过使用点表示法和方括号表示法添加属性，则只会在properties中添加，而不会在attributes中添加。<br><img src="http://opqksc9nz.bkt.clouddn.com/attribute11.png" alt="啊图片"></li><li>同理，通过对对象使用setAttributes方法添加属性，则会在对象的attributes中添加该属性，在对象的property有可能添加该属性（若该属性之前存在于property中，且对该属性的值如果有特殊要求，本次赋值对其满足，则可添加）。</li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>让我们再来回顾一下本篇文章中所涉及的知识点：</p><ol><li>对象使用点表示法和括号表示法与使用“getAttribute()”方法有何不同。</li><li>如何通过js或开发人员工具查看对象的properties和attributes。</li><li>如何通过js对对象的property和attribute进行设置。</li></ol></h3>]]></content>
    
    <summary type="html">
    
      关于attribute和property的区别
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>《HTTP下午茶》</title>
    <link href="http://yoursite.com/2017/06/14/http_afternoon_tea/"/>
    <id>http://yoursite.com/2017/06/14/http_afternoon_tea/</id>
    <published>2017-06-14T14:30:50.000Z</published>
    <updated>2020-04-22T15:46:29.007Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP协议的入门小书，全书通俗易读，辅以插图食用口味更佳。</p><a id="more"></a><p>传送门：<a href="https://www.kancloud.cn/kancloud/tealeaf-http/43837" target="_blank" rel="noopener">https://www.kancloud.cn/kancloud/tealeaf-http/43837</a></p><p>书中简要介绍了如下内容：</p><ul><li>如何通过网址如何上网<ul><li>DNS</li><li>客户端和服务器。</li></ul></li><li>无状态协议</li><li>URL</li><li>抓包工具</li><li>HTTP请求<ul><li>get请求</li><li>post请求</li><li>HTTP状态码</li></ul></li><li>如何构建有状态的web应用<ul><li>session</li><li>cookies</li><li>ajax</li></ul></li><li>WEB安全<ul><li>HTTPS</li><li>同源策略</li><li>会话劫持</li><li>XSS攻击（会话劫持的对策）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      一本小书
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
