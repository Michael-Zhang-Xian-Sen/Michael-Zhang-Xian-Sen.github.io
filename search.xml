<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/2020/08/31/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"/>
      <content type="html"><![CDATA[<p>要安装的内容：</p><ol><li>全局安装webpack。<code>npm install webpack -g</code></li><li>webpack命令行工具：<code>npm install webpack-cli -g</code></li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>同源策略及跨域</title>
      <link href="/2020/08/31/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%8F%8A%E8%B7%A8%E5%9F%9F/"/>
      <content type="html"><![CDATA[<h1 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h1><ol><li>同源策略（Same origin policy），浏览器的一个安全策略，现代浏览器大部分都实现了该策略。<ol><li>同源指：域名、协议、端口相同。</li><li>禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。</li><li>禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。</li></ol></li><li>http协议的<code>Content-Type</code>字段：如果该字段在http request header（请求头）里，指“前端向后台传递的数据的类型”，后台框架可能会根据该字段，自动地对前端发来的内容进行解析；如果该字段在htttp response header(响应头)里，指“后台向前端传递的数据的类型”。</li></ol><p>如果要跨域就要解决两个关键问题，一个是浏览器不让你发请求（实质上是浏览器根据预检请求得到的结果，不让你发正式的请求），另一个是浏览器不让你收请求。</p><h1 id="如何绕开同源策略（如何跨域）？"><a href="#如何绕开同源策略（如何跨域）？" class="headerlink" title="如何绕开同源策略（如何跨域）？"></a>如何绕开同源策略（如何跨域）？</h1><h2 id="1-jsonp跨域"><a href="#1-jsonp跨域" class="headerlink" title="1. jsonp跨域"></a>1. jsonp跨域</h2><p>JSONP（JSON with Padding，带填充的json），是由Bob Ippolito在2005年提出的一种跨域手段。jsonp跨域的两个关键点，一个是<code>&lt;script&gt;</code>标签，另一个是回调函数。</p><p>jsonp利用<code>script</code>标签从前端向后台请求数据。前端获得响应后，会在该<code>script</code>标签内执行一个回调函数。</p><p>为什么是<code>&lt;script&gt;</code>标签呢？因为一些HTML标签是不受同源策略限制的，如<code>script</code>、<code>img</code>，因此使用这些标签可以发请求。</p><p>为什么不用<code>img</code>标签呢？因为实际场景，前端不仅要发、收请求，还要对请求的结果进行下一步的处理。script标签内的内容可以作为js代码被浏览器执行，因此script非常符合我们的需求。</p><p>jsonp的另一个关键点就是回调函数了。利用<code>&lt;script&gt;</code>发起请求，返回内容是由后台生成的，因此在<code>script</code>标签内执行的代码只能是后台响应的数据。<br>这样一来..是不是有点尴尬，“后台大哥，我前端只能执行你发的数据，要不我等会代码写好了拷贝一份发你吧！”，后台大哥：“滚！”….<br>我们当然不能这样做，也不一定可行（作用域问题）。我们应该好好利用一个东西：函数！函数能把我们的业务代码囊括进去，一行代码便能执行数十行代码，还能利用闭包解决作用域的问题，简直太棒了！所以我们仅需要把回调函数告诉后台，让后台以函数的调用形式作为请求的响应内容返回就好了！至此，利用jsonp跨域的理论基础便建立起来了。</p><p>所以，利用jsonp发起一个跨域请求的具体步骤大致如下：</p><ol><li>前端创建一个<code>script</code>标签，并设置该标签的<code>src</code>属性为我们期望请求api的url，设置<code>type</code>属性为”text/javascript”。</li><li>将该<code>script</code>标签添加至dom树。该标签加入dom树后，便会自动向<code>src</code>指定的url发送请求。</li><li>后台向前端响应的内容，应该是一段调用回调函数的代码，如：<code>前端回调函数名(参数)</code>。</li><li>在前端声明一个回调函数，该函数在请求成功响应后执行。（注意，大部分情况都是要将该函数挂到全局对象上哦，因为script标签内的作用域是全局作用域）</li></ol><p>jsonp跨域的一些缺点：</p><ol><li>仅支持<code>get</code>请求。</li></ol><h3 id="1-1-jsonp跨域的原生实现："><a href="#1-1-jsonp跨域的原生实现：" class="headerlink" title="1.1 jsonp跨域的原生实现："></a>1.1 jsonp跨域的原生实现：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* vue前端 */</span></span><br><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>), <span class="comment">// 创建一个script标签</span></span><br><span class="line">    jsonpCallbackName = <span class="string">"jsonpCallback"</span>, <span class="comment">// 消除魔法字符串，统一后续的jsonp回调函数名称。</span></span><br><span class="line">    context = <span class="keyword">this</span>; <span class="comment">// 记录当前的上下文。博主的这段代码实际是在vue中编写的，具体代码可见文末的demo。这条赋值语句可以忽略。</span></span><br><span class="line"></span><br><span class="line">script.type = <span class="string">"text/javascript"</span>; <span class="comment">// 使该标签请求获得的数据可以被浏览器执行。</span></span><br><span class="line">script.src = <span class="string">`http://localhost:3000/api/testGet?anything=<span class="subst">$&#123;<span class="keyword">this</span>.form.anything&#125;</span>&amp;callback=<span class="subst">$&#123;jsonpCallbackName&#125;</span>`</span>; <span class="comment">// 建议传一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数。</span></span><br><span class="line"><span class="built_in">document</span>.head.appendChild(script); <span class="comment">// 将该标签添加至dom树，加入dom树后该标签会触发向src的请求。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// script标签请求成功后的回调函数。</span></span><br><span class="line"><span class="built_in">window</span>[jsonpCallbackName] = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.head.removeChild(script);</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">window</span>[jsonpCallbackName];</span><br><span class="line">    context.returnMsg = res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* node后台 */</span></span><br><span class="line">router.get(<span class="string">'/testGet'</span>, (ctx) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`后台testGet接口被触发`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`接收到数据：<span class="subst">$&#123;ctx.request.query.anything&#125;</span>`</span>);</span><br><span class="line">    ctx.response.status = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 后台返回的内容必须为模拟执行回调函数的代码，即：回调函数名(参数)</span></span><br><span class="line">    ctx.body = <span class="string">`<span class="subst">$&#123;ctx.request.query.callback&#125;</span>(&#123;"status":"success"&#125;)`</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于实现过程中的一些细节的解释：</p><ol><li>为什么一定要给<code>script</code>标签设置<code>type</code>属性？<blockquote><p><code>type</code>属性定义script元素包含或src引用的脚本语言。属性的值为MIME类型; 支持的MIME类型包括text/javascript, text/ecmascript, application/javascript, 和application/ecmascript。如果没有定义这个属性，脚本会被视作JavaScript。如果MIME类型不是JavaScript类型（上述支持的类型），则该元素所包含的内容会被当作数据块而不会被浏览器执行。 <strong><em><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script" target="_blank" rel="noopener">(摘自mdn)</a></em></strong></p></blockquote></li><li>为什么要将回调函数挂载到window上？<ul><li>因为<code>script</code>标签内的代码的执行环境是全局作用域，如果不将回调函数挂载到window上，script标签内的代码访问不到该回调函数。</li></ul></li><li>为什么要在回调函数里删除该方法？<ul><li>为了避免内存泄漏。function也是会占用一定内存的。</li></ul></li></ol><p>可能会遇到的报错：</p><ol><li><blockquote><p>Cross-Origin Read Blocking (CORB) blocked cross-origin response <a href="http://localhost:3000/api/testGet?name=test&amp;callback=handleCallback" target="_blank" rel="noopener">http://localhost:3000/api/testGet?name=test&amp;callback=handleCallback</a> with MIME type application/json. See <a href="https://www.chromestatus.com/feature/5629709824032768" target="_blank" rel="noopener">https://www.chromestatus.com/feature/5629709824032768</a> for more details.</p></blockquote></li></ol><ul><li>出现原因：因为CORB策略（详见参考资料1）。后台返回的内容可能满足了CORB的保护规则，触发了CORB，因此前端无法获取到响应信息。</li><li>解决方案：博主是初学时不懂后台要返回一个方法的调用（如：<code>前端回调函数名(参数)</code>），而是返回了一段json数据才导致的这个错误。</li></ul><h3 id="1-2-jquery版本的jsonp跨域"><a href="#1-2-jquery版本的jsonp跨域" class="headerlink" title="1.2 jquery版本的jsonp跨域"></a>1.2 jquery版本的jsonp跨域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonpCallbackName = <span class="string">"jsonpCallback"</span>,</span><br><span class="line">    context = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>[jsonpCallbackName] = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">window</span>[jsonpCallbackName];</span><br><span class="line">    context.returnMsg = res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"http://localhost:3000/api/testGet"</span>,</span><br><span class="line">    type: <span class="string">"get"</span>,</span><br><span class="line">    dataType: <span class="string">"jsonp"</span>, <span class="comment">// 预期服务器返回的数据类型。当值为"jsonp"时，会在url中自动添加"callback=?"，其中?会被自动替换为jsonpCallback字段设置的函数名。</span></span><br><span class="line">    jsonpCallback: jsonpCallbackName, <span class="comment">// 回调函数的函数名。</span></span><br><span class="line">    data: &#123;</span><br><span class="line">        anything: <span class="keyword">this</span>.form.anything,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-iframe-form跨域"><a href="#2-iframe-form跨域" class="headerlink" title="2. iframe+form跨域"></a>2. iframe+form跨域</h2><p>由于form表单在提交时不会出现跨域问题，因此可以利用form表单进行跨域。<br>ifame标签，主要用来避免页面刷新的问题，收到响应数据后直接将表单的数据显示到iframe标签中。<br>但是该方法的局限性比较大，后台传递回来的数据只在<code>iframe</code>中渲染，在<code>iframe</code>的父页面中无法获取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前端 */</span></span><br><span class="line"><span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>), <span class="comment">// 首先创建一个用来发送数据的iframe.</span></span><br><span class="line">form = <span class="built_in">document</span>.createElement(<span class="string">"form"</span>),</span><br><span class="line">node = <span class="built_in">document</span>.createElement(<span class="string">"input"</span>),</span><br><span class="line">context = <span class="keyword">this</span>,</span><br><span class="line">data = &#123;</span><br><span class="line">    anything: <span class="keyword">this</span>.form.anything,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置并添加iframe至dom树</span></span><br><span class="line">iframe.name = <span class="string">"iframePost"</span>;</span><br><span class="line">iframe.style.display = <span class="string">"none"</span>;</span><br><span class="line">iframe.src = <span class="string">"http://localhost:8080"</span>;</span><br><span class="line">iframe.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 暂时还没有解决无法接收后台数据的问题。</span></span><br><span class="line">    context.returnMsg = res;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置并添加form至iframe</span></span><br><span class="line">form.action = <span class="string">"http://localhost:3000/api/testPost"</span>;</span><br><span class="line">form.target = iframe.name; <span class="comment">// 在提交表单之后，在指定的iframe中显示响应信息</span></span><br><span class="line">form.method = <span class="string">"post"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> data) &#123;</span><br><span class="line">    node.name = prop;</span><br><span class="line">    node.value = data[prop].toString();</span><br><span class="line">    form.appendChild(node.cloneNode());</span><br><span class="line">&#125;</span><br><span class="line">form.style.display = <span class="string">"none"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(form);</span><br><span class="line">form.submit(); <span class="comment">// 发送form</span></span><br><span class="line"><span class="built_in">document</span>.body.removeChild(form); <span class="comment">// 表单提交后,就可以删除这个表单,不影响下次的数据发送.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 后台 */</span></span><br><span class="line">router.post(<span class="string">'/testPost'</span>, (ctx) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`后台testPost接口被触发`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`接收到数据：<span class="subst">$&#123;ctx.request.body&#125;</span>`</span>);</span><br><span class="line">    ctx.response.status = <span class="number">200</span>;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">        status: <span class="string">"success"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-CORS（Cross-origin-resource-sharing，跨域资源共享）"><a href="#3-CORS（Cross-origin-resource-sharing，跨域资源共享）" class="headerlink" title="3. CORS（Cross-origin resource sharing，跨域资源共享）"></a>3. CORS（Cross-origin resource sharing，跨域资源共享）</h2><p>cors是一种规范，这个规范规定了一些能够进行跨域的情况。<br>如果我们需要根据cors规范跨域，绝大多数情况下仅需要在前后端设置一下http请求的header。</p><h3 id="关于cors规范，有些内容你必须了解"><a href="#关于cors规范，有些内容你必须了解" class="headerlink" title="关于cors规范，有些内容你必须了解"></a>关于cors规范，有些内容你必须了解</h3><h4 id="1-简单请求和非简单请求"><a href="#1-简单请求和非简单请求" class="headerlink" title="1. 简单请求和非简单请求"></a>1. 简单请求和非简单请求</h4><p>cors规范将请求分为了<strong>简单请求</strong>和<strong>非简单请求</strong>。为什么要划分呢?因为有些http请求可能会对服务器数据产生副作用，划分请求便是为了阻止这些副作用。</p><p>这两个请求的最大区别，便是简单请求只需发送一个http请求，而非简单请求一共需要发送两个http请求。非简单请求首先发起一个预检请求，获知后台是否允许跨域请求，确认允许后才可以发起实际的HTTP请求。简单请求直接发送实际的HTTP请求。</p><p>满足以下所有条件即简单请求(<strong><em><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">摘自mdn</a></em></strong>)</p><blockquote><ul><li>使用下列方法之一<ul><li>GET</li><li>HEAD</li><li>POST</li></ul></li><li>除了被用户代理自动设置的首部字段（例如 Connection ，User-Agent）和在 Fetch 规范中定义为 禁用首部名称 的其他首部，允许人为设置的字段为 Fetch 规范定义的 对 CORS 安全的首部字段集合。该集合为：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type （需要注意额外的限制）</li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul></li><li>Content-Type 的值仅限于下列三者之一：（牢记，容易出问题，我们常用的application/json并不包括在里面）<ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul></li><li>请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</li><li>请求中没有使用 ReadableStream 对象。</li></ul></blockquote><h3 id="cors跨域该如何设置？"><a href="#cors跨域该如何设置？" class="headerlink" title="cors跨域该如何设置？"></a>cors跨域该如何设置？</h3><p>前端：</p><ol><li>如果需要携带认证信息（包括cookie），需要设置<code>xhr.withCredentials = true</code>。</li><li>根据自己传送的数据类型，设置一下<code>contentType</code>，如<code>xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);</code></li></ol><p>后台：</p><ol><li><code>Access-Control-Allow-Origin</code>：设置允许访问资源的源，经常被设置为<code>&quot;*&quot;</code>，注意如果携带了认证信息，该字段值不能设置为<code>&quot;*&quot;</code>，需要设置为相应的uri。</li><li>如果携带认证信息(包括cookie)，设置<code>Access-Control-Allow-Credentials</code>的值为<code>true</code>。非简单请求一般情况下也将该字段设置为<code>true</code>。</li><li><code>Access-Control-Allow-Headers</code>：设置请求头中除一些标准的字段，额外允许携带的字段。比如<code>Content-Type</code>。多个字段用逗号隔开，如：<code>&#39;Content-Type, Content-Length, Authorization, Accept&#39;</code></li><li><code>Access-Control-Allow-Methods</code>：设置前端可以使用哪些方法进行请求。可以设置为：<code>&#39;PUT, POST, GET, DELETE, OPTIONS&#39;</code><br>设置了这几个字段，基本就能实现请求的跨域了，其他字段可以根据需要另行设置。</li></ol><h3 id="与cors跨域相关的字段（仅做总结）"><a href="#与cors跨域相关的字段（仅做总结）" class="headerlink" title="与cors跨域相关的字段（仅做总结）"></a>与cors跨域相关的字段（仅做总结）</h3><h4 id="请求头的相关字段："><a href="#请求头的相关字段：" class="headerlink" title="请求头的相关字段："></a>请求头的相关字段：</h4><ul><li><code>origin</code>：发送请求的源的URI。</li><li><code>Access-Control-Request-Method</code>：仅用于预检请求。将实际请求所使用的 HTTP 方法告诉服务器。</li><li><code>Access-Control-Request-Headers</code>：仅用于预检请求。将实际请求所携带的首部字段告诉服务器。</li></ul><h4 id="响应头的相关字段："><a href="#响应头的相关字段：" class="headerlink" title="响应头的相关字段："></a>响应头的相关字段：</h4><ol><li><code>Access-Control-Allow-Origin</code>，指定可以访问该资源的URI。“*”指任何人都可以访问；也可以是具体的uri，比如：<code>https://developer.mozilla.org</code>。<ul><li>对于附带身份凭证的请求，或需要传递cookie的请求，该值不能使用<code>&quot;*&quot;</code></li></ul></li><li><code>Access-Control-Allow-Credentials</code>，表示是否可以将对请求的响应暴露给页面。<ul><li>如果前端要把cookie传递至后台，则后台必须将响应头中该字段的值设为<code>true</code></li></ul></li><li><code>Access-Control-Allow-Methods</code>，表示前端可以使用哪些方法进行请求。</li><li><code>Access-Control-Allow-Headers</code>，表示请求头中除一些标准的字段，额外允许携带的字段。</li><li><code>Access-Control-Expose-Headers</code>，扩展前端使用<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法所能获取到的响应头信息。<code>getResponseHeader()</code>默认只能获取最基本的响应头：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code></li><li><code>Access-Control-Max-Age</code>，指定预检请求可以被缓存多少秒。</li></ol><h2 id="基于上述内容做的一个跨域模拟器"><a href="#基于上述内容做的一个跨域模拟器" class="headerlink" title="基于上述内容做的一个跨域模拟器"></a>基于上述内容做的一个跨域模拟器</h2><p>项目基于nodejs koa2和vue3.0实现（基本没用什么新特性..），这个模拟器可以用来：</p><ol><li>观察跨域时的http报文..</li><li>直接看源码，了解上述跨域方法是如何使用的。</li></ol><p>嗯嗯..就这些了..这也是我第一次用这个koa框架和vue3.0..喜欢的话帮忙点个Star呗~ 欢迎pr~ 项目地址：<a href="https://github.com/Michael-Zhang-Xian-Sen/cross-domain-simulation" target="_blank" rel="noopener">https://github.com/Michael-Zhang-Xian-Sen/cross-domain-simulation</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/weixin_42672054/article/details/81985736" target="_blank" rel="noopener">30 分钟理解 CORB 是什么</a></li><li><a href="https://en.wikipedia.org/wiki/JSONP" target="_blank" rel="noopener">Jsonp 维基百科</a></li><li><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">前端常见跨域解决方案（全）</a></li><li><a href="https://web.archive.org/web/20120608162347/http://bob.ippoli.to/archives/2005/12/05/remote-json-jsonp/" target="_blank" rel="noopener">Remote JSON - JSONP</a></li><li><a href="https://segmentfault.com/a/1190000015597029" target="_blank" rel="noopener">不要再问我跨域的问题了</a></li></ol><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ol><li><a href="https://www.w3.org/wiki/CORS#Why_is_there_a_preflight_request.3F" target="_blank" rel="noopener">w3c cors标准</a></li></ol>]]></content>
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2020/08/30/IDE/vsc%E5%AE%9E%E7%94%A8%E7%9A%84%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%8F%92%E4%BB%B6/"/>
      <content type="html"><![CDATA[<h1 id="vsc的使用技巧及实用插件。"><a href="#vsc的使用技巧及实用插件。" class="headerlink" title="vsc的使用技巧及实用插件。"></a>vsc的使用技巧及实用插件。</h1><h2 id="实用插件"><a href="#实用插件" class="headerlink" title="实用插件"></a>实用插件</h2><ol><li>EditorConfig：用于统一项目的编码风格，如采用何种方式缩进。该插件的优先级高于编辑器默认的代码格式化规则。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* .editorconfig文件 */</span></span><br><span class="line">[*.&#123;js,jsx,ts,tsx,vue&#125;]</span><br><span class="line">root = <span class="literal">true</span></span><br><span class="line"># 缩进风格：空格</span><br><span class="line">indent_style = space</span><br><span class="line"># 缩进大小：4</span><br><span class="line">indent_size = <span class="number">4</span></span><br><span class="line"># 是否删除行尾的空格：true</span><br><span class="line">trim_trailing_whitespace = <span class="literal">true</span></span><br><span class="line"># 是否在文件的最后插入一个空行：true</span><br><span class="line">insert_final_newline = <span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>js函数防抖与节流</title>
      <link href="/2020/08/28/js%E5%9F%BA%E7%A1%80/js%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
      <content type="html"><![CDATA[<p>在前端开发中，很多场景会频繁地触发事件，出于效率或者业务等方面的考虑，我们不想频繁触发事件，这时候就需要用到函数的防抖和节流。</p><h2 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"content"</span> style=<span class="string">"height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        content.innerHTML = num++;</span><br><span class="line">    &#125;;</span><br><span class="line">    content.onmousemove = count;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h2><p>短时间内多次触发同一事件，只在最后一次执行目标函数，或者只在最开始的一次执行目标函数，中间的不执行。</p><p>实现方式是将目标函数传递给<code>debounce</code>函数进行处理，<code>debounce</code>函数返回一个带有防抖功能的新函数。实际上每次触发事件仍然会执行该函数，但是只有在满足某些条件时，才会执行原来的目标函数。</p><p>根据执行目标函数的时间区分，有立即执行版的函数防抖和非立即执行版的函数防抖。</p><ul><li>立即执行版本的函数防抖：触发某事件后，立刻执行该事件的目标函数，但后续触发事件都不会使目标函数执行，直到最后一次触发事件然后经过指定时间，再次触发事件才可执行目标函数。</li><li>非立即执行版本的函数防抖：触发某事件后不会立即执行目标函数，直到最后一次触发事件然后经过指定时间，才会执行目标函数。</li></ul><p>代码实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">funciton debounce(func,wait,immediate)&#123;</span><br><span class="line">    <span class="keyword">let</span> timer; <span class="comment">// 存储定时器的编号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回添加了防抖功能的函数。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>,</span><br><span class="line">            args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一定需要先清除已有的定时器。</span></span><br><span class="line">        <span class="comment">// 立即执行版的定时器，用于判断能否触发func。如果当前存在timer，说明已经执行过func，需要等待一定时间后才可再次执行该func，故一定要重新设置setTimeout。等待时间一到，此时再次触发该事件，才可执行func（设置timer=null）。</span></span><br><span class="line">        <span class="comment">// 非立即执行版的定时器，用于触发func。如果当前存在timer，需要清除该timer，并重新设置setTimeout，因为我们期望的是”用户最后一次触发事件然后经过指定时间，才可执行func“</span></span><br><span class="line">        <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(immediate)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">                func.apply(context,args);   <span class="comment">// 一段时间未触发该事件，执行func。</span></span><br><span class="line">            &#125;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;timer=<span class="literal">null</span>&#125;,wait);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context,<span class="built_in">arguments</span>)</span><br><span class="line">            &#125;,wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流(throttle)"></a>函数节流(throttle)</h2><p>指连续触发事件但是在 n 秒中只执行一次目标函数。即 2n 秒内执行 2 次、3n秒内执行3次…以此类推。会稀释函数的执行频率。</p><p>有两种不同的实现方式，根据实现方式的不同，触发目标函数的时刻也不相同。</p><ol><li>时间戳实现，在时间段开始的时候触发函数。</li><li>定时器实现，在时间段结束的时候触发函数。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 函数节流</span></span><br><span class="line"><span class="comment"> * @param func 函数</span></span><br><span class="line"><span class="comment"> * @param wait 延迟执行毫秒数</span></span><br><span class="line"><span class="comment"> * @param type 1 表时间戳版，2 表定时器版</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,wait,type</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>,</span><br><span class="line">        timeout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>,</span><br><span class="line">            args = <span class="built_in">arguments</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(type === <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> now = <span class="built_in">Date</span>.now(); <span class="comment">// 记录当前时间</span></span><br><span class="line">            <span class="keyword">if</span>(now - previous &gt; wait)&#123; <span class="comment">// 如果当前时间-上一次执行func的时间&gt;时间间隔，则可以触发func</span></span><br><span class="line">                func.apply(context,args);</span><br><span class="line">                previous = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!timeout)&#123; <span class="comment">// 如果当前没有执行过func或刚执行完毕func，则触发setTimeout，经过wait时间后调用func。</span></span><br><span class="line">                timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    timeout = <span class="literal">null</span>;</span><br><span class="line">                    func.apply(context,args);</span><br><span class="line">                &#125;,wait)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于节流-防抖函数中-context（this）-的指向解析"><a href="#关于节流-防抖函数中-context（this）-的指向解析" class="headerlink" title="关于节流/防抖函数中 context（this） 的指向解析"></a>关于节流/防抖函数中 context（this） 的指向解析</h2><h3 id="首先要明确一个问题，即节流-防抖函数执行后返回的匿名函数的this指向问题。"><a href="#首先要明确一个问题，即节流-防抖函数执行后返回的匿名函数的this指向问题。" class="headerlink" title="首先要明确一个问题，即节流/防抖函数执行后返回的匿名函数的this指向问题。"></a>首先要明确一个问题，即节流/防抖函数执行后返回的匿名函数的this指向问题。</h3><p>由于节流/防抖函数执行后返回的是一个匿名函数，如果无其他操作，该匿名函数内部的<code>this</code>应为window或其他全局对象。但是该匿名函数被赋给了<code>content.onmousemove</code>事件，形成了一个函数表达式，因此该函数内部的<code>this</code>此时指向绑定该事件的节点，即事件的<code>currentTarget</code>。</p><h3 id="其次要明确，func函数内部的this指向问题。"><a href="#其次要明确，func函数内部的this指向问题。" class="headerlink" title="其次要明确，func函数内部的this指向问题。"></a>其次要明确，func函数内部的this指向问题。</h3><p>在执行被节流/防抖的目标函数<code>func</code>时，如果直接调用(即<code>func()</code>)，其调用者为全局对象，因此<code>func</code>函数内部的<code>this</code>为<code>window</code>。如果我们需要<code>func</code>函数内部的<code>this</code>指向当前绑定该事件的元素，则需要使用<code>apply</code>方法手动改变<code>func</code>的<code>this</code>。</p><h3 id="怎么改变func函数内部的this指向调用该事件的dom节点呢？"><a href="#怎么改变func函数内部的this指向调用该事件的dom节点呢？" class="headerlink" title="怎么改变func函数内部的this指向调用该事件的dom节点呢？"></a>怎么改变func函数内部的this指向调用该事件的dom节点呢？</h3><p>我们只需需要将匿名函数中的<code>this</code>传递给<code>func</code>，因为<code>throttle</code>/<code>debounce</code>返回的匿名函数中，<code>this</code>指向的即为调用该事件的dom节点。</p><p>在<code>func</code>无<code>setTimeout</code>包裹的情况下，直接使用<code>func.apply(this,arguments)</code>；但是如果有<code>setTimeout</code>包裹呢？</p><p>这里给出两种传递方法</p><ol><li>将匿名函数的this使用变量记录下来，然后使用<code>func.apply(context,args)</code>，即本文函数防抖与节流的方法。</li><li>使用箭头函数的写法编写setTimeout的回调函数，如：<code>setTimeout(()=&gt;{func.apply(this,arguments)},delay)</code></li></ol><h4 id="方法1：将匿名函数的this使用变量记录下来，然后使用func-apply-，即本文函数防抖与节流的方法。"><a href="#方法1：将匿名函数的this使用变量记录下来，然后使用func-apply-，即本文函数防抖与节流的方法。" class="headerlink" title="方法1：将匿名函数的this使用变量记录下来，然后使用func.apply()，即本文函数防抖与节流的方法。"></a>方法1：将匿名函数的this使用变量记录下来，然后使用<code>func.apply()</code>，即本文函数防抖与节流的方法。</h4><p>为什么不直接写<code>func.apply(this,arguments)</code>呢？</p><p>《JavaScript高级程序设计》第二版中，写到：“超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined”。</p><p>因为setTimeout是一种超时调用，其回调函数的内部作用域便是全局作用域，所以不能直接写<code>func.apply(this,arguments)</code>。</p><p>我们可以利用闭包，将匿名函数的<code>this</code>用另一个变量<code>context</code>记录下来，然后在setTimeout中使用，即：<code>func.apply(context,args)</code>，便实现了改变<code>func</code>内部的<code>this</code>为匿名函数的<code>this</code>。</p><h3 id="方法2：使用箭头函数的写法编写setTimeout的回调函数，如：setTimeout-gt-delay"><a href="#方法2：使用箭头函数的写法编写setTimeout的回调函数，如：setTimeout-gt-delay" class="headerlink" title="方法2：使用箭头函数的写法编写setTimeout的回调函数，如：setTimeout(()=&gt;{},delay)"></a>方法2：使用箭头函数的写法编写setTimeout的回调函数，如：<code>setTimeout(()=&gt;{},delay)</code></h3><p>箭头函数没有自己的this。箭头函数的作用域为定义时箭头函数所在的作用域，即被绑定到创建它时的上下文环境中。</p><p>因此，如果我们使用箭头函数的写法，则<code>setTimeout</code>的回调函数的作用域为匿名函数的作用域，然后通过<code>func.apply(this,argumnets)</code>，便实现了改变<code>func</code>内部的<code>this</code>为匿名函数的<code>this</code>，而匿名函数的<code>this</code>指向调用该事件的dom节点，故实现了改变func函数内部的this指向调用该事件的dom节点。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://juejin.im/post/6844903651278848014#heading-1" target="_blank" rel="noopener">js 函数的防抖(debounce)与节流(throttle)</a></li><li><a href="https://www.cnblogs.com/hutaoer/p/3423782.html" target="_blank" rel="noopener">【javascript 技巧】谈谈setTimeout的作用域以及this的指向问题</a></li></ol>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js闭包</title>
      <link href="/2020/08/27/js%E5%9F%BA%E7%A1%80/js%E9%97%AD%E5%8C%85/"/>
      <content type="html"><![CDATA[<h2 id="什么是闭包-closure-？"><a href="#什么是闭包-closure-？" class="headerlink" title="什么是闭包(closure)？"></a>什么是闭包(closure)？</h2><ul><li>第一种解释：函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。</li><li>第二种解释（方大佬的解释）：「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。</li></ul><h2 id="什么是词法作用域？"><a href="#什么是词法作用域？" class="headerlink" title="什么是词法作用域？"></a>什么是词法作用域？</h2><p>词法（lexical）一词指的是，词法作用域根据源代码中声明变量的位置来确定该变量在何处可用。嵌套函数可访问声明于它们外部的作用域的变量。</p><h2 id="闭包的作用："><a href="#闭包的作用：" class="headerlink" title="闭包的作用："></a>闭包的作用：</h2><ol><li>它允许将函数与其所操作的某些数据（环境）关联起来。（类似面向对象编程中，对象允许我们将某些数据与一个或者多个方法相关联。）</li><li>让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。</li><li>可用于将函数与其所操作的某些数据（环境）关联起来。</li><li>可以使用闭包来模拟私有方法，保护函数内部的变量，有利于数据隐藏和封装。可以用来实现模块模式。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/22486908" target="_blank" rel="noopener">「每日一题」JS 中的闭包是什么？</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">MDN闭包</a></li></ul>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js事件总结</title>
      <link href="/2020/08/27/js%E5%9F%BA%E7%A1%80/js%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<h1 id="js事件总结"><a href="#js事件总结" class="headerlink" title="js事件总结"></a>js事件总结</h1><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><ul><li><code>event.target</code>：一个触发事件的对象的引用， 当事件处理程序在事件的冒泡或捕获阶段被调用时。</li><li><code>event.currentTarget</code>：currentTarget是事件绑定的元素，即当事件遍历DOM时，标识事件的当前目标。</li></ul><h2 id="事件操作"><a href="#事件操作" class="headerlink" title="事件操作"></a>事件操作</h2><h3 id="新增事件"><a href="#新增事件" class="headerlink" title="新增事件"></a>新增事件</h3><ol><li><code>target.addEventListener(type, listener, useCapture);</code></li><li>dom对象.onXxxx</li></ol><p>方法1相较于方法2，可以向同一对象的同一事件添加多个监听方法。</p><h3 id="移除事件"><a href="#移除事件" class="headerlink" title="移除事件"></a>移除事件</h3><ol><li><code>target.removeEventListener(type, listener[, useCapture]);</code>移除事件。</li></ol><h3 id="阻止事件默认行为"><a href="#阻止事件默认行为" class="headerlink" title="阻止事件默认行为"></a>阻止事件默认行为</h3><p><code>event.preventDefault();</code></p><h2 id="事件捕获及事件冒泡"><a href="#事件捕获及事件冒泡" class="headerlink" title="事件捕获及事件冒泡"></a>事件捕获及事件冒泡</h2><p>当一个事件发生在具有父元素的元素上时，现代浏览器运行两个不同的阶段 - 捕获阶段和冒泡阶段。addEventListener添加的事件，默认只会触发冒泡阶段的事件，如果需要触发捕获阶段的事件，则需要将第三个参数设置为true。</p><h3 id="捕获阶段"><a href="#捕获阶段" class="headerlink" title="捕获阶段"></a>捕获阶段</h3><p>事件触发后，从最外层祖先开始，到实际触发事件的元素，依次判断是否存在相应的事件处理程序，如果有则触发该程序。</p><h3 id="冒泡阶段"><a href="#冒泡阶段" class="headerlink" title="冒泡阶段"></a>冒泡阶段</h3><p>事件触发后，从实际触发事件的元素开始，到最外层元素，依次判断是否存在相应的事件处理程序，如果有则触发该程序。</p><h3 id="阻止捕获和冒泡阶段中当前事件的进一步传播"><a href="#阻止捕获和冒泡阶段中当前事件的进一步传播" class="headerlink" title="阻止捕获和冒泡阶段中当前事件的进一步传播"></a>阻止捕获和冒泡阶段中当前事件的进一步传播</h3><p>使用<code>e.stopPropagation()</code>。</p><p>事件捕获及事件冒泡的实例：<a href="https://jsfiddle.net/Himory/L1r4cpaf/" target="_blank" rel="noopener">https://jsfiddle.net/Himory/L1r4cpaf/</a></p><h3 id="事件委托-事件代理-Event-Delegation"><a href="#事件委托-事件代理-Event-Delegation" class="headerlink" title="事件委托/事件代理(Event Delegation)"></a>事件委托/事件代理(Event Delegation)</h3><p>利用事件冒泡的特性，将应该注册在子元素上的处理事件注册在父元素上，这样点击子元素时发现子元素没有相应事件，通过冒泡到父元素进行寻找并执行。</p><p>这样做的优势有：</p><ol><li>减少DOM操作，提高性能。</li><li>随时可以添加子元素，添加的子元素会自动有相应的处理事件。</li></ol><p>事件委托的实例：<a href="https://jsfiddle.net/Himory/r5yav9fe/" target="_blank" rel="noopener">https://jsfiddle.net/Himory/r5yav9fe/</a></p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉树总结</title>
      <link href="/2020/08/25/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<h2 id="二叉树的常见形式"><a href="#二叉树的常见形式" class="headerlink" title="二叉树的常见形式"></a>二叉树的常见形式</h2><h3 id="1-对象数组。"><a href="#1-对象数组。" class="headerlink" title="1. 对象数组。"></a>1. 对象数组。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">value,left,right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.left = left;</span><br><span class="line">    <span class="keyword">this</span>.right = right;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><ol><li>先序(根)遍历。Preorder Traversal (VLR)</li><li>中序(根)遍历。</li><li>后序(根)遍历。</li><li>按层遍历</li></ol><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>根-左-右</p><h4 id="递归实现："><a href="#递归实现：" class="headerlink" title="递归实现："></a>递归实现：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preorderTraversal</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> preorderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123; <span class="comment">// 定义一个函数，用来递归向result数组中添加先序遍历的结果。</span></span><br><span class="line">        <span class="keyword">if</span>(node)&#123; <span class="comment">// 如果当前节点存在值，则将当前节点加入至结果数组，并且遍历其左右子树。</span></span><br><span class="line">            result.push(node.value);</span><br><span class="line">            preorderTraversalNode(node.left);</span><br><span class="line">            preorderTraversalNode(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    preorderTraversalNode(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h4><ul><li>广度优先遍历</li><li>维护一个可走路径的栈。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preorderTraversal</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stack = [],</span><br><span class="line">        result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root) stack.push(root); <span class="comment">// 将根节点入栈</span></span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> curNode = stack.pop();  <span class="comment">// 取出当前遍历的节点</span></span><br><span class="line">        list.push(curNode.value);   <span class="comment">// 将当前节点值放入结果数组。</span></span><br><span class="line">        <span class="keyword">if</span>(curNode.right)&#123;          </span><br><span class="line">            stack.push(curNode.right);  <span class="comment">// 如果右子树存在，则将右子树入栈。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curNode.left)&#123;</span><br><span class="line">            stack.push(curNode.left);   <span class="comment">// 如果左子树存在，则将左子树入栈。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>左-根-右</p><h4 id="递归实现：-1"><a href="#递归实现：-1" class="headerlink" title="递归实现："></a>递归实现：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inorderTraversal</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> preorderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            preorderTraversalNode(node.left);</span><br><span class="line">            result.push(node.value);</span><br><span class="line">            preorderTraversalNode(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    preorderTraversalNode(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代实现-1"><a href="#迭代实现-1" class="headerlink" title="迭代实现"></a>迭代实现</h4><p>整体思路：</p><ul><li>深度优先遍历，仍然需要一个栈来存储路径。</li><li>走过的路径入栈，遇到无路可走时出栈，不断地尝试，直到栈为空（循环，出口为栈为空）。</li><li>不急于走（不先将当前节点入栈），先试探（尝试）当前节点是否能走，如果能走则走当前节点（入栈），然后根据优先级判断下面可以走的节点，然后继续试探（进入下个循环）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inorderTraversal</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [],</span><br><span class="line">        stack = [],</span><br><span class="line">        curNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取当前节点为根节点。</span></span><br><span class="line">    <span class="keyword">if</span>(root) &#123;</span><br><span class="line">        curNode = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stack.length || curNode)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curNode)&#123; <span class="comment">// 如果当前节点可以走，则加入路径（入栈）。</span></span><br><span class="line">            stack.push(curNode);</span><br><span class="line">            curNode = curNode.left; <span class="comment">// 下一步往左走。</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curNode = stack.pop();</span><br><span class="line">            result.push(curNode.value);</span><br><span class="line">            curNode = curNode.right; <span class="comment">// 下一个节点为当前节点的右子树。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>左-右-根</p><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postorderTraversal</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">var</span> postorderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            postorderTraversalNode(node.left);</span><br><span class="line">            postorderTraversalNode(node.right);</span><br><span class="line">            result.push(node.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    postorderTraversalNode(root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代实现-2"><a href="#迭代实现-2" class="headerlink" title="迭代实现"></a>迭代实现</h4><p>将原序列从反顺序遍历。根节点在结果数组中一定晚于左子树和右子树节点出现，且右子树一定晚于左子树出现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postorderTraversal</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [],</span><br><span class="line">        stack = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        stack.push(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">        node.left &amp;&amp; stack.push(node.left);</span><br><span class="line">        node.right &amp;&amp; stack.push(node.right);</span><br><span class="line">        result.unshift(node.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按层遍历"><a href="#按层遍历" class="headerlink" title="按层遍历"></a>按层遍历</h3><p>从上到下，从左到右，依次遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">levelTraversal</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [],</span><br><span class="line">        queue = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root) queue.push(root);</span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">        result.push(node.value);</span><br><span class="line">        node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">        node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode102：二叉树的层序遍历"><a href="#LeetCode102：二叉树的层序遍历" class="headerlink" title="LeetCode102：二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">LeetCode102：二叉树的层序遍历</a></h4><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">二叉树：[3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>题解：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [],</span><br><span class="line">        pathQueue = [],</span><br><span class="line">        depthQueue = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        pathQueue.push(root);</span><br><span class="line">        depthQueue.push(<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">while</span>(pathQueue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = pathQueue.shift(),</span><br><span class="line">            depth = depthQueue.shift();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!result[depth])&#123;</span><br><span class="line">            result[depth] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        result[depth].push(node.val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.left)&#123;</span><br><span class="line">            pathQueue.push(node.left);</span><br><span class="line">            depthQueue.push(depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right)&#123;</span><br><span class="line">            pathQueue.push(node.right);</span><br><span class="line">            depthQueue.push(depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>form标签</title>
      <link href="/2020/08/25/HTML%E5%9F%BA%E7%A1%80/form%E6%A0%87%E7%AD%BE/"/>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js出现舍入误差的原因及应对方案</title>
      <link href="/2020/08/25/js%E5%9F%BA%E7%A1%80/js%E8%88%8D%E5%85%A5%E8%AF%AF%E5%B7%AE%E5%8F%8A%E5%85%B6%E6%B6%88%E9%99%A4%E6%96%B9%E6%A1%88/"/>
      <content type="html"><![CDATA[<h3 id="舍入误差"><a href="#舍入误差" class="headerlink" title="舍入误差"></a>舍入误差</h3><p>Number类型使用IEEE 754 双精度 64 位浮点数格式来表示整数和浮点值。</p><ul><li>符号位，第63位（共1位），用来区分正负数。</li><li>指数，第52-62位（共11位），即2的指数。</li><li>第0到51是尾数位（共52位）。<br>因此，2^(-53)到2^53之间的整数都可以精确表示，但是对于计算机而言，两个数字在相加时是以二进制形式进行的，在呈现结果时才转换成十进制，所以浮点数不一定能精确表示。</li></ul><h4 id="十进制小数转二进制小数"><a href="#十进制小数转二进制小数" class="headerlink" title="十进制小数转二进制小数"></a>十进制小数转二进制小数</h4><p>用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，此时0或1为二进制的最后一位。或者达到所要求的精度为止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如：0.1 =（0.0 0011 0011 0011...(0011无限循环下去)）B</span><br><span class="line">0.1*2=0.2========取出整数部分0</span><br><span class="line">0.2*2=0.4========取出整数部分0</span><br><span class="line">0.4*2=0.8========取出整数部分0</span><br><span class="line">0.8*2=1.6========取出整数部分1</span><br><span class="line">0.6*2=1.2========取出整数部分1</span><br><span class="line">0.2*2=0.4========取出整数部分0</span><br><span class="line">0.4*2=0.8========取出整数部分0</span><br><span class="line">0.8*2=1.6========取出整数部分1</span><br><span class="line">0.6*2=1.2========取出整数部分1</span><br><span class="line">0.2*2=0.4========取出整数部分0</span><br></pre></td></tr></table></figure><p>0.1和0.2的表示如下所示：</p><ul><li>0.1：e = -4; m =1.1001100110011001100110011001100110011001100110011010 (52位)</li><li>0.2：e = -3; m =1.1001100110011001100110011001100110011001100110011010 (52位)</li></ul><h4 id="二进制的舍入规则"><a href="#二进制的舍入规则" class="headerlink" title="二进制的舍入规则"></a>二进制的舍入规则</h4><p>舍入的目标即尽可能使舍入后的结果与真实值误差最小（尽可能减小舍入处理的影响）。如果以形式1.RR..RDD..D表示浮点数（R表示有效位，或保留位，而D表示舍去位），舍入规则就是：</p><ul><li>如果DD..D &lt; 10..0，则向下舍入。如：<code>1.001011</code>，保留四位有效数字，由于舍去位<code>011 &lt; 100</code>，故保留位最后一位不进位，结果为：<code>1.001</code>。</li><li>如果DD..D &gt; 10..0，则向上舍入。如：<code>1.001101</code>，保留四位有效数字，由于舍去位<code>101 &gt; 100</code>，故保留位最后一位进位1，结果为：<code>1.010</code>。</li><li>如要DD..D = 10..0，则向最近偶数舍入，细则如下 ：<ul><li>如果RR..R = XX..0 （最低有效位是0），则向下舍入。如：<code>1.100100</code>，保留四位有效数字，由于最低有效位是0，故不进位，结果为：<code>1.100</code>。</li><li>如果RR..R = XX..1（最低有效位是1），则向上舍入。如：<code>1.001100</code>，保留四位有效数字，由于最低有效位是1，故进位1，结果为：<code>1.010</code>。</li></ul></li></ul><h4 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1 + 0.2 !== 0.3"></a>0.1 + 0.2 !== 0.3</h4><p>0.1与0.2二进制相加，步骤如下：</p><ol><li>对齐二进制位。由于0.1与0.2的指数不一致，需要对齐。<ul><li>0.1：e = -3; m = 0.1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101</li></ul><ul><li>0.2：e = -3; m = 1.1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010</li></ul></li><li>对应位数相加<ul><li>相加后得到的结果：e = -3; m = 10.0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0111</li></ul></li><li>超出的精度需要舍入。由于最后的舍去位是<code>1</code>，且最低有效位是<code>1</code>，故向上舍入，保留位最后一位进1.<ul><li>最终结果：e = -2; m = 1.0011001100110011001100110011001100110011001100110100(52位)</li><li>最终结果的二进制形式：0.010011001100110011001100110011001100110011001100110100</li><li>最终结果的十进制形式：0.30000000000000004</li></ul></li></ol><p>解决js中（或者说遵循IEEE 754规范）的语言中，两浮点数相加结果不正确的问题，可以设置一个误差范围值，即“机器精度”。对于Javascript来说，这个值通常是2^-52。</p><p>ES6中新增属性<code>Number.EMPSILON</code>，表示 1 与Number可表示的大于 1 的最小的浮点数之间的差值。可以使用<code>Number.EMPSILON</code>作为机器精度。</p><p>一个用于判断两数是否相等，并且消除了浮点数相加时舍入误差带来的影响：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a-b) &lt; <span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>深入探讨浮点数舍入问题：<a href="https://blog.csdn.net/qq_42372980/article/details/80554247?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight" target="_blank" rel="noopener">https://blog.csdn.net/qq_42372980/article/details/80554247?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight</a></li><li>Javascript中的Number类型和BigInt类型：<a href="https://blog.csdn.net/RaeZhang/article/details/107624193" target="_blank" rel="noopener">https://blog.csdn.net/RaeZhang/article/details/107624193</a></li><li>MDN中有关Number.EPSILON的介绍：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON</a></li></ol>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深度优先遍历</title>
      <link href="/2020/08/24/%E7%AE%97%E6%B3%95/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>字节前端 一面</title>
      <link href="/2020/08/24/%E7%A7%8B%E6%8B%9B%E5%8E%86%E7%A8%8B/%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2/"/>
      <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>算法题</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">从左侧视角打印一棵二叉树</span><br><span class="line"></span><br><span class="line">         <span class="number">1</span></span><br><span class="line">    <span class="number">2</span>        <span class="number">3</span></span><br><span class="line"><span class="number">4</span>       <span class="number">5</span></span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printTree</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 补全代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; val, left, right &#125;</span><br></pre></td></tr></table></figure></li><li><p>算法题</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">求一个数组A中所有长度为N的组合</span><br><span class="line">A = [1, 2, 3, 4, 5]</span><br><span class="line">N = 3</span><br><span class="line">=&gt;</span><br><span class="line">[[1, 2, 3], [1, 2, 4], [1, 2, 5], ....]</span><br><span class="line"></span><br><span class="line">function group(A, N) &#123;</span><br><span class="line">// 补全代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>什么是CORS?<br>待总结。</p></li></ol><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="1-算法题"><a href="#1-算法题" class="headerlink" title="1. 算法题"></a>1. 算法题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printTree</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [],</span><br><span class="line">        pathQueue = [],</span><br><span class="line">        depthQueue = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        pathQueue.push(root);</span><br><span class="line">        depthQueue.push(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pathQueue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = pathQueue.shift(),</span><br><span class="line">            depth = depthQueue.shift();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(result[depth] === <span class="literal">undefined</span>)&#123;</span><br><span class="line">            result.push(node.value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.left)&#123;</span><br><span class="line">            pathQueue.push(node.left);</span><br><span class="line">            depthQueue.push(depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right)&#123;</span><br><span class="line">            pathQueue.push(node.right);</span><br><span class="line">            depthQueue.push(depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-算法题"><a href="#2-算法题" class="headerlink" title="2. 算法题"></a>2. 算法题</h3><h3 id="3-什么是CORS"><a href="#3-什么是CORS" class="headerlink" title="3. 什么是CORS?"></a>3. 什么是CORS?</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）</p><h3 id="4-TCP协议队头阻塞"><a href="#4-TCP协议队头阻塞" class="headerlink" title="4. TCP协议队头阻塞"></a>4. TCP协议队头阻塞</h3><ol><li>TCP队头阻塞<br>TCP数据包是有序传输，中间一个数据包丢失，会等待该数据包重传，造成后面的数据包的阻塞。</li><li>HTTP队头阻塞<br>http队头阻塞和TCP队头阻塞完全不是一回事。</li></ol><p>http1.x采用长连接(Connection:keep-alive)，可以在一个TCP请求上，发送多个http请求。</p><p>有非管道化和管道化，两种方式。</p><p>非管道化，完全串行执行，请求-&gt;响应-&gt;请求-&gt;响应…，后一个请求必须在前一个响应之后发送。</p><p>管道化，请求可以并行发出，但是响应必须串行返回。后一个响应必须在前一个响应之后。原因是，没有序号标明顺序，只能串行接收。</p><p>管道化请求的致命弱点:</p><ol><li>会造成队头阻塞，前一个响应未及时返回，后面的响应被阻塞</li><li>请求必须是幂等请求，不能修改资源。因为，意外中断时候，客户端需要把未收到响应的请求重发，非幂等请求，会造成资源破坏。</li></ol><p>由于这个原因，目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式。</p><p>无论是非管道化还是管道化，都会造成队头阻塞(请求阻塞)。</p><p>解决http队头阻塞的方法：</p><ol><li>并发TCP连接（浏览器一个域名采用6-8个TCP连接，并发HTTP请求）</li><li><p>域名分片（多个域名，可以建立更多的TCP连接，从而提高HTTP请求的并发）</p></li><li><p>HTTP2方式</p></li></ol><p>http2使用一个域名单一TCP连接发送请求，请求包被二进制分帧，不同请求可以互相穿插，避免了http层面的请求队头阻塞。但是不能避免TCP层面的队头阻塞。</p><p>抄自：<a href="https://www.cnblogs.com/mengff/p/12724641.html" target="_blank" rel="noopener">https://www.cnblogs.com/mengff/p/12724641.html</a></p><h3 id="5-进程间通信的方式有哪些"><a href="#5-进程间通信的方式有哪些" class="headerlink" title="5. 进程间通信的方式有哪些"></a>5. 进程间通信的方式有哪些</h3><p>进程间通信方式有bai管道、信du号量、信号、消息队列、共享内存、套接字六种。<br>（1）管道分为有名管道和无名管道，其中无名管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用，一般用于两个不同进程之间的通信。有名管道也是一种半双工的通信方式，但它允许无亲缘关系进程间的通信。<br>（2）信号量是一个计数器，可以用来控制多个线程对共享资源的访问，它不是用于交换大批数据，而用于多线程之间的同步。他常作为一种锁机制。因此，主要作为进程间以及同一个进程内不同线程之间的同步手段。<br>（3）信号是一种比较复杂的通信方式，用于通知接收进程某个时间已经发生。<br>（4）消息队列是消息的链表，存放在内核中并由消息队列标识符标识，消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。<br>（5）共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。他往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。<br>（6）套接字可用于不同及其间的进程通信。</p><h3 id="6-数据库的事务是指什么。"><a href="#6-数据库的事务是指什么。" class="headerlink" title="6. 数据库的事务是指什么。"></a>6. 数据库的事务是指什么。</h3><p>数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。ACID特性。</p><p>1、原子性(Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么全部不执行。<br>2、一致性(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序 串行执行的结果相一致。<br>3、隔离性(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。<br>4、持久性(Durability):对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。</p><h3 id="7-怎么用css实现一个正方形，要求宽度是屏幕宽度的一半。"><a href="#7-怎么用css实现一个正方形，要求宽度是屏幕宽度的一半。" class="headerlink" title="7. 怎么用css实现一个正方形，要求宽度是屏幕宽度的一半。"></a>7. 怎么用css实现一个正方形，要求宽度是屏幕宽度的一半。</h3><p>vw单位。1vw等于视口宽度的1%。</p><h3 id="8-编写isEqual-a-b-，使得逾期返回true。"><a href="#8-编写isEqual-a-b-，使得逾期返回true。" class="headerlink" title="8. 编写isEqual(a, b)，使得逾期返回true。"></a>8. 编写isEqual(a, b)，使得逾期返回true。</h3><p>已总结博客。见：js出现舍入误差的原因及应对方案</p><ol><li>什么是CORS?</li><li>TCP协议队头阻塞？</li><li>进程间通信的方式有哪些</li></ol><h3 id="9-事件的target和currentTarget分别是什么"><a href="#9-事件的target和currentTarget分别是什么" class="headerlink" title="9. 事件的target和currentTarget分别是什么"></a>9. 事件的target和currentTarget分别是什么</h3><p>target指触发事件的元素。</p><p>currentTarget指由于冒泡/捕获遍历元素的事件程序时，当前遍历到的元素。</p><p>已总结博客，见“js事件总结“</p><h3 id="10-for…in-和-Object-keys-的区别"><a href="#10-for…in-和-Object-keys-的区别" class="headerlink" title="10. for…in 和 Object.keys 的区别"></a>10. for…in 和 Object.keys 的区别</h3><p>两者之间最主要的区别就是Object.keys( )不会走原型链，而for in 会走原型链….</p><h3 id="11-form元素的target属性作用是什么：target-action"><a href="#11-form元素的target属性作用是什么：target-action" class="headerlink" title="11. form元素的target属性作用是什么：target=? action"></a>11. form元素的target属性作用是什么：target=? action</h3><p>target属性定在何处打开actionURL。共有五个属性值：</p><ol><li>_blank，在新窗口打开。</li><li>_self，默认，在相同的框架打开。</li><li>_parent，在父框架集中打开。</li><li>_top，在整个窗口中打开。</li><li>framename，在指定的框架打开。</li></ol><p>action属性，用来处理表单提交的URL。该属性可能会被覆盖。</p><h3 id="12-VUE父子组件怎么通信？"><a href="#12-VUE父子组件怎么通信？" class="headerlink" title="12. VUE父子组件怎么通信？"></a>12. VUE父子组件怎么通信？</h3><ol><li>props、emit</li><li>eventBus（不推荐）</li><li>vuex（不推荐）</li></ol>]]></content>
      
      <categories>
          
          <category> 秋招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秋招 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP状态码</title>
      <link href="/2020/08/24/http/http%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <content type="html"><![CDATA[<ol><li><code>1xx</code>消息（Informational）</li><li><code>2xx</code>成功（Success）</li><li><code>3xx</code>重定向（Redirection）</li><li><code>4xx</code>客户端错误（Client error）：客户端请求出错，服务器无法处理请求</li><li><code>5xx</code>服务器错误（Server Error）：服务器处理请求出错。</li></ol><h3 id="1-消息"><a href="#1-消息" class="headerlink" title="1. 消息"></a>1. 消息</h3><p>接收的请求正在处理。</p><h3 id="2-成功"><a href="#2-成功" class="headerlink" title="2. 成功"></a>2. 成功</h3><p>请求正常处理完毕。</p><ul><li><code>200 OK</code>，表示从客户端发送给服务器的请求被正常处理并返回。</li><li><code>204 No Content</code>，请求处理成功，但没有任何资源可以返回给客户端，一般在只需要从客户端往服务器发送信息，而服务器不需要向客户端发送新信息内容的情况下使用。</li><li><code>206 Partial Content</code>，是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</li></ul><h3 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3. 重定向"></a>3. 重定向</h3><p>需要进行附加操作以完成请求。</p><ul><li><code>301 Moved Permanently</code>，永久性重定向。请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。</li><li><code>302 Found</code>，临时性重定向。和301相似，但302代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。</li><li><code>303 See Other</code>，该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。</li><li><code>304 Not Modified</code>，资源已找到，但未符合条件请求。该状态码表示客户端发送附带条件的请求时（采用GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部）服务端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304。</li><li><code>307 Temporary Redirect</code>，临时重定向。与302有相同的含义。</li></ul><h4 id="301永久重定向与302临时重定向的区别"><a href="#301永久重定向与302临时重定向的区别" class="headerlink" title="301永久重定向与302临时重定向的区别"></a>301永久重定向与302临时重定向的区别</h4><ul><li>301永久重定向，新网址完全继承旧网址，旧网址的排名等完全清零</li><li>302临时重定向，搜索引擎会抓取新的内容而保留旧的网址，</li></ul><h3 id="CNAME（Canonical-Name）与HTTP重定向的区别"><a href="#CNAME（Canonical-Name）与HTTP重定向的区别" class="headerlink" title="CNAME（Canonical Name）与HTTP重定向的区别"></a>CNAME（Canonical Name）与HTTP重定向的区别</h3><p>CNAME记录只是域名的别名，多用于CDN加速，而HTTP重定向是接收到重定向报文后，将请求重新发送给重定向所指出的URL。</p><h3 id="4-客户端错误"><a href="#4-客户端错误" class="headerlink" title="4. 客户端错误"></a>4. 客户端错误</h3><ul><li><code>400 Bad Request</code>，服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。</li><li><code>401 Unauthorized</code>，该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。</li><li><code>403 Forbidden</code>，不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。</li><li><code>404 Not Found</code>，服务器上没有请求的资源。路径错误等。</li></ul><h3 id="5-服务器本身发生错误"><a href="#5-服务器本身发生错误" class="headerlink" title="5. 服务器本身发生错误"></a>5. 服务器本身发生错误</h3><ul><li><code>500 Internal Server Error</code>，该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。</li><li><code>503 Service Unavailable</code>，该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。</li></ul>]]></content>
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js对象</title>
      <link href="/2020/08/23/js%E5%9F%BA%E7%A1%80/js%E5%AF%B9%E8%B1%A1/"/>
      <content type="html"><![CDATA[<h2 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h2><ol><li>数据属性<ul><li><code>configurable</code>：能否通过delete删除属性从而重新定义属性、能否修改属性的特性、能否把属性修改为访问器属性。对于直接在对象上定义的属性，默认为true。</li><li><code>enumerable</code>：表示能否通过for-in循环返回属性。默认为true。</li><li><code>writable</code>：表示能否修改属性的值。默认为true。</li><li><code>value</code>：包含这个属性的数据值。默认为undefined。</li></ul></li><li>访问器属性<ul><li><code>configurable</code>：表示能否通过delete删除属性从而重新定义属性、能否修改属性的特性、能否把属性修改为数据属性。对于直接在对象上定义的属性，默认为true。</li><li><code>enumerable</code>：表示能否通过for-in循环返回属性。默认为true。</li><li><code>get</code>：在读取属性时调用的函数，默认值为undefined。</li><li><code>set</code>：在写入属性时调用的函数，默认值为undefined。</li></ul></li><li>其他属性<ul><li><code>constructor</code>：对象的构造函数。</li></ul></li><li>相关方法<ul><li>定义属性描述符的方法1：<code>Object.defineProperty(对象, 属性名, 描述符对象)</code></li><li>定义属性描述符的方法2：<code>Object.defineProperties(对象, 描述符对象)</code></li><li>读取属性描述符的方法：<code>Object.getOwnPropertyDescriptor(对象, 属性名)</code></li></ul></li></ol><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1. 工厂模式"></a>1. 工厂模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure><h3 id="2-构造函数模式"><a href="#2-构造函数模式" class="headerlink" title="2. 构造函数模式"></a>2. 构造函数模式</h3><p>创建实例时实际经历的步骤：</p><ol><li>创建一个对象。</li><li>将构造函数的作用域赋给新对象</li><li>执行构造函数中的代码。</li><li>返回新对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Enigneer"</span>);</span><br></pre></td></tr></table></figure></li></ol><p>注意：</p><ol><li>构造函数始终应该以大写字母开头。</li><li>构造出的不同对象的方法并不共用同一片内存。</li></ol><h3 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3. 原型模式"></a>3. 原型模式</h3><p>创建新函数时，会为该函数创建一个prototype属性，该属性指向该函数的原型对象。默认情况下，所有的原型对象都会具有一个<code>constructor</code>属性，这个属性是一个指向<code>prototype</code>属性所在函数的指针，如下所示<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> NewFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">NewFunction.prototype.constructor === NewFunction <span class="comment">// true.</span></span><br></pre></td></tr></table></figure></p><h4 id="读取一个对象的属性，发生了什么？"><a href="#读取一个对象的属性，发生了什么？" class="headerlink" title="读取一个对象的属性，发生了什么？"></a>读取一个对象的属性，发生了什么？</h4><ol><li>首先搜索对象实例本身。如果在实例中找到了具有给定名字的属性，则返回该属性的值。</li><li>若第一步没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。</li></ol><h4 id="原型添加属性和方法"><a href="#原型添加属性和方法" class="headerlink" title="原型添加属性和方法"></a>原型添加属性和方法</h4><ol><li>通过<code>prototype</code>属性。如:<code>NewFunction.prototype.a = 1</code></li><li><p>通过对象字面量的方法，此时原型的constructor不再指向原函数，但是<code>instanceof</code>操作符仍然会返回true。可以通过显示地向对象添加constructor属性，以保证原型的constructor指向原函数。另外需要注意，使用对象字面量的方法，可能会重写原型链。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NewFunction</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">NewFunction.prototype = &#123;</span><br><span class="line">    a:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">NewFunction.prototype.constructor === NewFunction; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> newFunctionObj = <span class="keyword">new</span> NewFunction();</span><br><span class="line">newFunctionObj <span class="keyword">instanceof</span> NewFunction <span class="comment">// true</span></span><br><span class="line">NewFunction.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>:NewFunction,</span><br><span class="line">    a:1,</span><br><span class="line">&#125;</span><br><span class="line">NewFunction.prototype.<span class="keyword">constructor</span> === NewFunction; // true</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Object.defineProperty()</code>。</p></li></ol><h4 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h4><p>对原型对象所做的任何修改，都能立刻从实例上反映出来。</p><h4 id="原型相关的方法"><a href="#原型相关的方法" class="headerlink" title="原型相关的方法"></a>原型相关的方法</h4><ol><li><code>prototypeObject.prototype.isPrototypeOf(被测对象)</code> 用于prototypeObject是否存在于被测对象的原型链上。</li><li><code>Object.getPrototypeOf()</code>，用于获取指定对象的原型</li><li><code>obj.hasOwnProperty(属性名)</code>，方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性。不包括原型中的属性。</li><li><code>&quot;属性名&quot; in obj</code>，<code>in</code>操作符可检测对象是否有相应属性，不论属性在实例中还是在原型中。</li><li><code>Object.keys(obj)</code>,获取obj对象上的所有可枚举的实例属性。</li><li><code>Object.getOwnPropertyNames(obj)</code>，获取obj对象上的所有实例属性，无论是否可枚举。</li></ol><h3 id="4-组合使用构造函数模式和原型模式"><a href="#4-组合使用构造函数模式和原型模式" class="headerlink" title="4. 组合使用构造函数模式和原型模式"></a>4. 组合使用构造函数模式和原型模式</h3><p>使用构造函数模式定义实例属性，使用原型模式定义方法和共享的属性。</p><h3 id="5-动态原型模式"><a href="#5-动态原型模式" class="headerlink" title="5. 动态原型模式"></a>5. 动态原型模式</h3><p>将实例属性、原型方法和原型属性都定义在构造函数中。如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="comment">// 仅需检测一个原型中可能存在的属性或方法即可。若该属性/方法在原型中不存在，则将原型上应存在的所有属性和方法添加至原型。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName !== <span class="string">"function"</span>)&#123;</span><br><span class="line">        <span class="comment">// 也可使用instanceof，如：</span></span><br><span class="line">        <span class="comment">// if(this.sayName instanceof Function)</span></span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, nice to meet you <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-寄生构造函数模式"><a href="#6-寄生构造函数模式" class="headerlink" title="6. 寄生构造函数模式"></a>6. 寄生构造函数模式</h3><p>创建一个函数，该函数仅封装创建对象的代码，然后再返回新创建的对象。主要用来为现有的引用类型增加其他的功能，且不污染现有的引用类型。</p><p>与工厂模式有两个区别：</p><ol><li>命名上，不再采用createXxxx。</li><li>在实例化时，通过<code>new</code>运算符进行实例化，而不是仅调用方法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    values.push.apply(values,<span class="built_in">arguments</span>);</span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>);</span><br><span class="line">alert(colors.toPipedString());</span><br><span class="line">colors <span class="keyword">instanceof</span> SpecialArray <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ol><p>注意：寄生构造函数返回的对象与构造函数及构造函数的原型之间没有任何关系。</p><h3 id="7-稳妥构造函数模式"><a href="#7-稳妥构造函数模式" class="headerlink" title="7. 稳妥构造函数模式"></a>7. 稳妥构造函数模式</h3><p>稳妥对象：没有公共属性，而且其方法也不引用this。</p><p>稳妥构造函数模式不适用<code>new</code>操作符调用构造函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此处定义私有变量</span></span><br><span class="line"></span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法，是js语言实现继承的主要方法。</p><h3 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h3><ol><li>方法1：使用<code>instanceof</code></li><li>方法2：使用<code>isPrototypeOf</code>，如<code>Object.prototype.isPrototypeOf(instance)</code>;</li></ol><h3 id="原型链存在的问题"><a href="#原型链存在的问题" class="headerlink" title="原型链存在的问题"></a>原型链存在的问题</h3><ol><li>原型上引用类型值的属性，会被所有实例共享。</li><li>在不影响所有对象实例的情况下，无法给超类型的构造函数提供参数。</li></ol><h3 id="1-借用构造函数"><a href="#1-借用构造函数" class="headerlink" title="1. 借用构造函数"></a>1. 借用构造函数</h3><p>在子类型构造函数的内部调用超类型构造函数,便可以实现向超类型传递参数。</p><p>存在的问题：无法实现函数复用（因为超类型的原型中定义的方法，对于子类型而言是不可见的。）</p><h3 id="2-组合继承"><a href="#2-组合继承" class="headerlink" title="2. 组合继承"></a>2. 组合继承</h3><p>一种继承模式，将原型链和借用构造函数的技术组合到一起。主要思路为使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。</p><p>组合继承模式有两个关键步骤。在调用子类的构造函数实例化对象前，一定要先将超类挂载至子类的原型上，然后将子类原型的构造方法手动设置为子类的构造方法（因为在挂载原型时，构造方法会被覆盖）。</p><h3 id="3-原型式继承"><a href="#3-原型式继承" class="headerlink" title="3. 原型式继承"></a>3. 原型式继承</h3><p>借助原型，基于已有的对象创建新对象，同时也不必创建自定义类型。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ES6的<code>Object.craete(用作新对象原型的对象, 为新对象定义额外属性的对象)</code>api实现了原型式继承。</p><h3 id="4-寄生式继承"><a href="#4-寄生式继承" class="headerlink" title="4. 寄生式继承"></a>4. 寄生式继承</h3><p>创建一个仅用于封装继承过程的函数，使用该函数实现继承。</p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NodeJS入门</title>
      <link href="/2020/08/23/Node/node%E5%85%A5%E9%97%A8/"/>
      <content type="html"><![CDATA[<h1 id="搭建nodeJS环境。"><a href="#搭建nodeJS环境。" class="headerlink" title="搭建nodeJS环境。"></a>搭建nodeJS环境。</h1><ol><li>官网下载相应版本的NodeJS，直接安装即可。</li></ol>]]></content>
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>chrome浏览器的渲染过程</title>
      <link href="/2020/08/17/%E6%B5%8F%E8%A7%88%E5%99%A8/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
      <content type="html"><![CDATA[<h2 id="浏览器的渲染过程分为以下几步："><a href="#浏览器的渲染过程分为以下几步：" class="headerlink" title="浏览器的渲染过程分为以下几步："></a>浏览器的渲染过程分为以下几步：</h2><p>1.解析HTML，构建DOM树<br>2.解析CSS样式表，构建CSSOM(CSS Object Model)<br>3.将DOM和CSSOM进行合并生成Render Tree(渲染树)<br>4.根据Render Tree计算布局<br>5.依据Render Tree进行渲染</p><h2 id="关于回流和重绘"><a href="#关于回流和重绘" class="headerlink" title="关于回流和重绘"></a>关于回流和重绘</h2><ol><li>回流(reflow/layout)：当Render Tree中的一部分(或所有)因为其中元素的规模尺寸、布局(计算确切位置)、隐藏等改变而需要重新构建Render Tree。</li><li>重绘(repaint/painting)：当Render Tree中的一些元素需要更新属性，但这些属性只会影响元素的外观，风格，而不会影响布局，无需重新构建render tree。</li></ol><p>导致回流的具体情况：</p><ul><li>添加或删除可见的DOM元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li><li>页面一开始渲染的时候（这肯定避免不了）</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li></ul><p>回流一定会触发重绘，但是重绘不一定触发回流。</p><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><ul><li>利用cssTest属性和修改class更改元素样式，避免直接修改元素样式，最小化重绘和重排。</li><li>让DOM脱离文档流，进行修改完毕后，再回到文档流。脱离文档流后的改动不会引起回流。</li><li>现代浏览器大部分有一个队列，用于优化重排过程。而类似offsetTop的方法会强制队列刷新。所以需要避免在修改样式时直接引用以上属性，即避免触发同步布局事件。</li><li>复杂动画最好能脱离文档流。</li><li>css3硬件加速。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>谷歌开发者web基础：<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn</a></li><li>你真的了解重流和重绘吗：<a href="https://segmentfault.com/a/1190000017329980" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017329980</a></li></ol>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器原理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浏览器存储总结</title>
      <link href="/2020/08/17/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<p>存储方式：</p><ol><li>localStorage</li><li>sessionStorage</li><li>cookie</li></ol><p>浏览器的存储根据上下文环境不同，涉及到几个层级关系。</p><ol><li>浏览器。firefox or chome or …</li><li>浏览器窗口。一个窗口包含一堆标签页。</li><li>浏览器标签页。<ul><li>引申：标签页之间是否同源。</li><li>引申：点击链接，进行跳转<ul><li>跳转到新的标签页。</li><li>在本标签页内跳转，不生成新页面。</li></ul></li></ul></li><li>内嵌iframe</li></ol><h2 id="1-localStorage"><a href="#1-localStorage" class="headerlink" title="1. localStorage"></a>1. localStorage</h2><p>HTML5新增。</p><ul><li>生命周期：用于将数据长久保存在网站中，保存的数据没有过期时间，直到手动删除。关闭浏览器呢？</li><li>使用范围：同一个浏览器下的不同浏览器窗口的同源标签页之间，可以共享。</li><li>大小：因浏览器而异，大致在2.5MB到10MB之间。</li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><code>localStorage</code>对象的对象原型为<code>Storage</code>。</p><ul><li>设置localStorage：<code>localStorage.setItem(&#39;test&#39;,&#39;设置localStorage&#39;)</code></li><li>获取localStorage<ul><li>获取指定记录：<code>localStorage.getItem(&#39;test&#39;)</code></li><li>获取全部记录：<code>window.localStorage</code></li></ul></li><li>移除localStorage<ul><li>移除指定记录：<code>localStorage.removeItem(&#39;test&#39;)</code></li><li>移除全部记录：<code>localStorage.clear()</code></li></ul></li><li>获取localStorage的长度：<code>localStorage.length</code></li><li>获取某条localStorage记录的名称：<code>localStorage.key(idx)</code></li></ul><h2 id="2-sessionStorage"><a href="#2-sessionStorage" class="headerlink" title="2. sessionStorage"></a>2. sessionStorage</h2><p>HTML5新增。</p><ul><li>生命周期：当前窗口/标签页，刷新时不会被清空。</li><li>使用范围：当前标签页。当前标签页内跳转可以共享sessionStorage，但是通过打开新标签页跳转时不能共享。</li></ul><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p><code>sessionStorage</code>的对象原型也为<code>Storage</code>。api和localStorage几乎可以说是一模一样。</p><ul><li>设置sessionStorage：<code>sessionStorage.setItem(&#39;test&#39;,&quot;设置sessionStorage)</code></li><li>获取sessionStorage<ul><li>获取指定记录：<code>sessionStorage.getItem(&#39;test&#39;)</code></li><li>获取全部记录：<code>window.sessionStorage</code></li></ul></li><li>移除sessionStorage<ul><li>移除指定记录：<code>sessionStorage.removeItem(&#39;test&#39;)</code></li><li>移除全部记录：<code>sessionStorage.clear()</code></li></ul></li><li>获取sessionStorage的长度：<code>sessionStorage.length</code></li><li>获取某条sessionStorage记录的名称：<code>sessionStorage.key(idx)</code></li></ul><h2 id="3-cookie"><a href="#3-cookie" class="headerlink" title="3. cookie"></a>3. cookie</h2><p>cookie经常与session搭配使用。由于http协议是无状态的，而服务器如果要识别当前通信的客户，此时需要一个“通行证”，由服务器颁发给客户端，客户端以后再与后台通信时，仅需要将通行证和要传递的内容一起发给后台，后台看到通行证就会明白自己在与谁通信，然后就可以将需要的数据返回给前端。cookie和session的作用，就是此处的通行证。</p><p>生命周期：Cookie存储于电脑上的文本文件中，如果不进行清除或未打到过期时间，永远不会消失。<br>适用范围：同一个浏览器下可以共享。<br>使用场景：可以帮助我们实现记录用户个人信息的功能。Cookie经常被用于存储用户的信息，来实现记住用户名、记住密码等功能。</p><h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>设置cookie：<code>document.cookie=&quot;键值对;过期时间;cookie路径&quot;</code>，如：<code>document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;;</code></li><li>获取cookie：获取字符串格式的cookie：<code>document.cookie</code></li><li>删除cookie：为该记录设置一个已经过去的时间或者当前时间<code>document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;;</code><br>由于cookie的相关api较少，操作不方便，故使用时最好能够封装一些cookie的基本操作。</li></ul><h2 id="4-indexedDB"><a href="#4-indexedDB" class="headerlink" title="4. indexedDB"></a>4. indexedDB</h2><p>浏览器内置的大量数据存储技术。</p><p>相关教程：<a href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/indexeddb.html</a></p><h2 id="localStorage和sessionStorage的区别"><a href="#localStorage和sessionStorage的区别" class="headerlink" title="localStorage和sessionStorage的区别"></a>localStorage和sessionStorage的区别</h2><p>时效性。localStorage会一直存储在浏览器中，除非手动删除。而sessionStorage会在关闭窗口或标签页后清除，仅仅用于临时保存。</p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器原理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>display:none与visibility:hidden的辨析</title>
      <link href="/2020/08/17/css%E5%9F%BA%E7%A1%80/dispaly:none%E4%B8%8Evisibility%E7%9A%84%E8%BE%A8%E6%9E%90/"/>
      <content type="html"><![CDATA[<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>都能把网页上某个元素隐藏起来。</li></ol><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol><li>display:none隐藏的元素不占据物理空间（设置该属性的元素会产生回流，不会加入到render tree），visibility:hidden隐藏的元素占据物理空间（不会产生回流，会加入到render tree）。</li><li>display:none会跳过ol的计数器，而visibility不会跳过。</li><li>css3的transition支持visibility属性，不支持display属性。</li><li>visibility:hidden具有继承性，子元素也会继承visibility:hidden属性。display:none没有继承性。</li></ol>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>版本管理工具：svn小记</title>
      <link href="/2020/08/03/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9Asvn%E5%B0%8F%E8%AE%B0/"/>
      <content type="html"><![CDATA[<h2 id="mac使用svn-Subvision"><a href="#mac使用svn-Subvision" class="headerlink" title="mac使用svn(Subvision)"></a>mac使用svn(Subvision)</h2><p>mac自带svn，在控制台可直接使用，无需下载。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>下载项目：<code>svn checkout url(svn项目全路径) project_dir(本地项目全路径) --username=用户名 --password=密码</code></li><li>查看最近5条svn log日志：<code>svn log -l 5</code><br>该项目已遗失 (被非 svn 命令所删除) 或是不完整</li><li>svn status：执行SVN up和svn merge等命令出现在首位置的各字母含义如下：<ul><li>“ ” 无修改</li><li>“A” 新增</li><li>“C” 冲突</li><li>“D” 删除</li><li>“G” 合并</li><li>“I” 忽略</li><li>“M” 改变</li><li>“R” 替换</li><li>“X” 未纳入版本控制，但被外部定义所用</li><li>“?” 未纳入版本控制</li><li>“!” 该项目已遗失 (被非 svn 命令所删除) 或是不完整</li><li>“~” 版本控制下的项目与其它类型的项目重名</li><li>L abc.c # svn已经在.svn目录锁定了abc.c</li></ul></li></ul><h3 id="svn-update"><a href="#svn-update" class="headerlink" title="svn update"></a>svn update</h3><ul><li>A  已添加</li><li>D  已删除</li><li>U  已更新</li><li>C  合并冲突</li><li>G  合并成功</li><li>E  已存在</li></ul><h2 id="设置忽略文件"><a href="#设置忽略文件" class="headerlink" title="设置忽略文件"></a>设置忽略文件</h2><h3 id="全局设置忽略文件"><a href="#全局设置忽略文件" class="headerlink" title="全局设置忽略文件"></a>全局设置忽略文件</h3><p>找到svn的全局配置文件：<code>~/.subversion/config</code>，将<code>[miscellany]</code>段中<code>global-ignores</code>前的注释符号去掉即可。还可增加一些自己想要忽略的文件类型。</p><p>此处推荐添加的一些额外忽略文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Editor directories and files</span><br><span class="line">.idea .vscode *.iml *.suo</span><br><span class="line">*.ntvs* *.njsproj *.sln *.sw?</span><br></pre></td></tr></table></figure></p><h3 id="工程目录下设置忽略文件和目录"><a href="#工程目录下设置忽略文件和目录" class="headerlink" title="工程目录下设置忽略文件和目录"></a>工程目录下设置忽略文件和目录</h3><p>使用<code>svn propedit svn:ignore &lt;dir&gt;</code>命令。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li>官网文档：<a href="https://subversion.apache.org/docs/" target="_blank" rel="noopener">https://subversion.apache.org/docs/</a></li><li>svnbook：<a href="http://svnbook.red-bean.com/" target="_blank" rel="noopener">http://svnbook.red-bean.com/</a></li></ul>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本管理工具 </tag>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js 命名规范</title>
      <link href="/2020/08/02/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%EF%BC%9Ajs/"/>
      <content type="html"><![CDATA[<h3 id="变量名："><a href="#变量名：" class="headerlink" title="变量名："></a>变量名：</h3><ul><li>变量名应为名词如car或person。</li></ul><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>语法规范：<br>任何合法的javascript标识符都可以作为函数的名称。<br>约定俗成的内容：(非ECMAScript语法，但是为了便于开发者理解和识别，约定的函数命名规范。)<br>命名方法： 小驼峰式命名法</p><ul><li>命名规范： 前缀应该为动词，常用前缀如下：<ul><li>can     判断是否可执行某个动作</li><li>has     判断是否含有某个值</li><li>is     判断是否为某个值</li><li>get     获取某个值</li><li>set     设置某个值</li><li>load     加载某些数据</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 命名规范 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git常用命令小记</title>
      <link href="/2020/08/01/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9Agit%E5%B0%8F%E8%AE%B0/"/>
      <content type="html"><![CDATA[<p>git的常用操作及相关问题的解决方案。</p><a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>遇到git命令参数的问题，可通过查看文档解决：</p><ol><li>输入<code>git</code>后回车可以显示常用的git命令。</li><li>输入<code>git 某个命令 -h</code> 可以查看该命令具体的参数信息。</li></ol><h3 id="1-分支操作"><a href="#1-分支操作" class="headerlink" title="1. 分支操作"></a>1. 分支操作</h3><ol><li>将当前内容全部复制到一个新分支：<code>git checkout -b 新分支名称</code></li><li>删除分支：<code>git branch -d</code></li></ol><h2 id="具体问题的解决方案"><a href="#具体问题的解决方案" class="headerlink" title="具体问题的解决方案"></a>具体问题的解决方案</h2><h3 id="1-fork得到的仓库的代码如何更新使得其与原仓库的代码一致。"><a href="#1-fork得到的仓库的代码如何更新使得其与原仓库的代码一致。" class="headerlink" title="1. fork得到的仓库的代码如何更新使得其与原仓库的代码一致。"></a>1. fork得到的仓库的代码如何更新使得其与原仓库的代码一致。</h3><ol><li>配置原仓库的路径：<code>git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</code></li><li>查看远程仓库的路径，确保正确添加上游仓库：<code>git remote -v</code></li><li>抓取原仓库的修改：<code>git fetch upstream</code></li><li>其他内容：删除某个远程仓库<code>git remote remove &lt;name&gt;</code></li></ol><h3 id="2-修改commit的注释"><a href="#2-修改commit的注释" class="headerlink" title="2. 修改commit的注释"></a>2. 修改commit的注释</h3><p><code>git commit --amend</code>amend为修正的意思。</p><h3 id="3-撤销git-add"><a href="#3-撤销git-add" class="headerlink" title="3. 撤销git add"></a>3. 撤销git add</h3><p><code>git reset 文件名</code></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本管理工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>打造舒适的Mac工作环境：CLI配置</title>
      <link href="/2020/07/02/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Mac%20bash%E9%85%8D%E7%BD%AE/"/>
      <content type="html"><![CDATA[<p>mac环境下的CLI终端工具及bash配置推荐。</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>CLI终端推荐：iTerm2</li><li>bash推荐：oh-my-zsh</li><li>bsah相关的命令</li></ol><h2 id="1-CLI终端推荐：iTerm2"><a href="#1-CLI终端推荐：iTerm2" class="headerlink" title="1. CLI终端推荐：iTerm2"></a>1. CLI终端推荐：iTerm2</h2><ol><li>下载地址：<a href="https://www.iterm2.com/" target="_blank" rel="noopener">https://www.iterm2.com/</a></li></ol><h3 id="实用小技巧"><a href="#实用小技巧" class="headerlink" title="实用小技巧"></a>实用小技巧</h3><ul><li>分屏：<code>command+d</code>。</li></ul><h2 id="2-bash推荐：oh-my-zsh"><a href="#2-bash推荐：oh-my-zsh" class="headerlink" title="2. bash推荐：oh-my-zsh"></a>2. bash推荐：oh-my-zsh</h2><p>oh-my-zsh是一款傻瓜化的zsh配置工具。优点：省心，功能强大。</p><ol><li>安装oh-my-zsh：<code>sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></li></ol><h3 id="2-1-插件"><a href="#2-1-插件" class="headerlink" title="2.1 插件"></a>2.1 插件</h3><p>如何安装插件？</p><ol><li>在<code>oh-my-zsh安装位置/.oh-my-zsh/custom/plugins</code>文件夹下，使用插件名创建文件夹<code>mkdir 插件名</code></li><li>将下载好的插件放入该文件夹中。</li><li>打开oh-my-zsh配置文件：<code>vim ~/.zshrc</code></li><li>在配置文件结束添加如下内容：<code>source $ZSH/custom/plugins/插件名文件夹/插件名</code>（vim中<code>shit+G</code>可以快速跳转到最后一行）</li><li>更新配置<code>source ~/.zshrc</code></li></ol><h4 id="2-1-1-git-plugin（自带插件）"><a href="#2-1-1-git-plugin（自带插件）" class="headerlink" title="2.1.1 git plugin（自带插件）"></a>2.1.1 git plugin（自带插件）</h4><p>这款插件默认开启。该插件为大量的git的命令设置了别名，</p><p>文档地址：<a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git/" target="_blank" rel="noopener">https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git/</a></p><h4 id="2-1-2-extract-plugin（自带插件）"><a href="#2-1-2-extract-plugin（自带插件）" class="headerlink" title="2.1.2 extract plugin（自带插件）"></a>2.1.2 extract plugin（自带插件）</h4><p>一款功能强大的解压软件。仅通过一个命令<code>extract</code>即可解压大部分的压缩文件，包括rar、zip、tar等。</p><p>文档地址：<a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/extract" target="_blank" rel="noopener">https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/extract</a></p><h4 id="2-1-3-自动补全插件"><a href="#2-1-3-自动补全插件" class="headerlink" title="2.1.3 自动补全插件"></a>2.1.3 自动补全插件</h4><p>这款插件可以在用户输入命令时，在光标下方提示可以使用的命令、文件等信息，再也不用为记不住linux命令名、不停地输入ls而苦恼。</p><p>插件下载地址：<a href="http://mimosa-pudica.net/src/incr-0.2.zsh" target="_blank" rel="noopener">http://mimosa-pudica.net/src/incr-0.2.zsh</a></p><h2 id="2-bash相关的命令"><a href="#2-bash相关的命令" class="headerlink" title="2. bash相关的命令"></a>2. bash相关的命令</h2><ul><li>查看当前终端使用的bash：<code>echo $SHELL</code></li><li>查看当前安装的所有bash：<code>cat /etc/shells</code></li></ul>]]></content>
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用idea开发springboot项目生成文件的含义详解</title>
      <link href="/2020/07/01/IDE/%E4%BD%BF%E7%94%A8idea%E5%BC%80%E5%8F%91spring%20boot%E9%A1%B9%E7%9B%AE%E7%94%9F%E6%88%90%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%87%E4%BB%B6/"/>
      <content type="html"><![CDATA[<h1 id="使用idea开发spring-boot项目生成的一些文件"><a href="#使用idea开发spring-boot项目生成的一些文件" class="headerlink" title="使用idea开发spring boot项目生成的一些文件"></a>使用idea开发spring boot项目生成的一些文件</h1><ul><li>.iml：idea的工程配置文件。包含当前project的一些配置信息，如模块开发的相关信息，比如java组件，maven组件，插件组件等，还可能会存储一些模块路径信息，依赖信息以及一些别的信息。</li><li>mvnw：一个执行脚本，用于命令行环境。mvnw是一个maven wrapper script,它可以让你在没有安装maven或者maven版本不兼容的条件下运行maven的命令.</li><li>mvnw.cmd：作用与mvnw相同，只是用于win环境。</li></ul>]]></content>
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于箭头函数</title>
      <link href="/2020/07/01/js%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
      <content type="html"><![CDATA[<ol><li>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。</li><li>箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</li></ol>]]></content>
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于箭头函数</title>
      <link href="/2020/05/20/js%E5%9F%BA%E7%A1%80/%E5%B8%B8%E7%94%A8console%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>console.log</code> 用于输出普通信息</li><li><code>console.info</code> 用于输出提示性信息</li><li><code>console.error</code> 用于输出错误信息</li><li><code>console.warn</code> 用于输出警示信息</li><li><code>console.debug</code> 用于输出调试信息</li></ul><p>针对不同类型的信息，大多数浏览器在consoole会使用不同的标志进行标识，并可以根据信息类型进行筛选。</p><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul><li><code>console.table(obj)</code> ：可以将对象或者数组以表格的形式直观地打印出来</li><li><code>console.count()</code>：以参数为标识记录调用的次数，调用时在控制台打印标识以及调用次数。</li><li><code>console.countReset()</code>：重置指定标签的计数器值。</li><li><code>console.time()</code>：启动一个以入参作为特定名称的计时器，在显示页面中可同时运行的计时器上限为10,000.</li><li><code>console.timeEnd()</code>：结束特定的 计时器 并以豪秒打印其从开始到结束所用的时间。</li><li><code>console.timeLog()</code>：打印特定 计时器 所运行的时间。</li></ul><h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><ul><li>css占位符（仅在chrome支持？）：<code>console.log(&quot;%cHello World&quot;,padding:50px;font-size:40px;color:gray);</code></li></ul>]]></content>
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js数据类型</title>
      <link href="/2020/05/04/js%E5%9F%BA%E7%A1%80/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <content type="html"><![CDATA[<h1 id="数据类型概览"><a href="#数据类型概览" class="headerlink" title="数据类型概览"></a>数据类型概览</h1><p>共八种，分为基础类型和引用类型。</p><h2 id="基本类型（又称原始类型、简单类型。）"><a href="#基本类型（又称原始类型、简单类型。）" class="headerlink" title="基本类型（又称原始类型、简单类型。）"></a>基本类型（又称原始类型、简单类型。）</h2><p>值本身无法被改变。尤其注意的是基本类型和内置对象是不一样的。比如Boolean的基本类型的值只有false和true，而Boolean对象只是用来承载Boolean基本类型的。</p><ol><li>Boolean：值仅有<code>true</code>或<code>false</code><ul><li>判断基本类型：<code>typeof variable === &quot;boolean&quot;</code></li></ul></li><li>Null<ul><li>判断基本类型：<code>variable === null</code></li></ul></li><li>Undefined<ul><li>判断基本类型方法1：<code>variable === undefined</code></li><li>判断基本类型方法2：<code>typeof a === &quot;undefined&quot;</code></li></ul></li><li>Number<ul><li>判断基本类型：<code>typeof variable === &quot;number&quot;</code></li><li>判断整数：<code>Number.isInteger()</code>。</li><li>判断是否为NaN：<code>Number.isNaN()</code>。</li><li>判断是否为有穷数：<code>Number.isFinite()</code>。</li><li>字符串转浮点数：<code>Number.parseFloat()</code>。</li><li>字符串转整数：<code>Number.parseInt()</code>。和全局的<code>parseInt()</code>方法一致。</li></ul></li><li>BigInt<ul><li>判断基本类型：<code>typeof variable === &quot;bigint&quot;</code></li><li>注意：不能用于Math对象中的方法。</li></ul></li><li>String<ul><li>判断基本类型：<code>typeof variable === &quot;String&quot;</code></li></ul></li><li>Symbol<ul><li>判断基本类型：<code>typeof variable === &quot;Symbol&quot;</code></li></ul></li></ol><h2 id="引用类型Object"><a href="#引用类型Object" class="headerlink" title="引用类型Object"></a>引用类型Object</h2><p>值本身可以被改变。</p><h3 id="对象判空的方法"><a href="#对象判空的方法" class="headerlink" title="对象判空的方法"></a>对象判空的方法</h3><ol><li>使用JSON.stringify()。</li><li>使用<code>for in</code>。</li><li>使用Object.keys()。</li></ol><h3 id="1-使用JSON-stringify"><a href="#1-使用JSON-stringify" class="headerlink" title="1. 使用JSON.stringify()"></a>1. 使用JSON.stringify()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isObjEmpty(obj)&#123;</span><br><span class="line">    return JSON.stringify(obj) === &quot;&#123;&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用for-in"><a href="#2-使用for-in" class="headerlink" title="2. 使用for in"></a>2. 使用<code>for in</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function isObjEmpty(obj)&#123;</span><br><span class="line">    for(let attr in obj)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用Object-keys"><a href="#3-使用Object-keys" class="headerlink" title="3. 使用Object.keys()"></a>3. 使用Object.keys()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isObjEmpty(obj)&#123;</span><br><span class="line">    return Object.keys(obj).length === 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6学习笔记（二）：字符串的扩展</title>
      <link href="/2020/04/29/es6/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89:%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
      <content type="html"><![CDATA[<h2 id="normalize-方法"><a href="#normalize-方法" class="headerlink" title="normalize()方法"></a>normalize()方法</h2><p>参数如下，注意参数必须大写！</p><ul><li>NFC(default)。标准等价合成（Normalization Form Canonical Composition）。先规范分解，然后进行规范组合。</li><li>NFD。标准等价分解（Normalization Form Canonical Decomposition）。规范分解。</li><li>NFKC。兼容等价合成（Normalization Form Compatibility Composition）。先兼容性分解，然后进行规范组合。</li><li>NFKD。兼容等价分解（Normalization Form Compatibility Decomposition）。兼容性分解。</li></ul><p>个人理解，针对字母后跟音标符号的组合，如<code>\u004F\u030C</code>，与一个标有音标符合的字符<code>\u01D1</code>，属于<strong>规范等价</strong>，因此可以用NFC和NFD。<br>兼容等价（NFKC和NFKD）包含了规范等价，但比规范等价额外包含了<strong>兼容</strong>的部分，是规范等价的超集。若两个字符完全相同的组合，如<code>\u0066\u0066</code>，与他们的单个字符表现形式<code>\uFB00</code>，他们的语义相同，则二者为兼容等价。可以使用规范化将二者变为同一形式。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><ol><li><p>NFC和NFD比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">'\u01D1'</span> <span class="comment">// Ǒ</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'\u004F\u030C'</span> <span class="comment">// Ǒ</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`str1的原始值（即赋予str1的值）为<span class="subst">$&#123;<span class="built_in">String</span>.raw<span class="string">`\u01D1`</span>&#125;</span>，显示的值为<span class="subst">$&#123;str1&#125;</span>,长度为<span class="subst">$&#123;str1.length&#125;</span>`</span>);  <span class="comment">// Ǒ</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`str2的原始值（即赋予str2的值）为<span class="subst">$&#123;<span class="built_in">String</span>.raw<span class="string">`\u004F\u030C`</span>&#125;</span>，显示的值为<span class="subst">$&#123;str2&#125;</span>,长度为<span class="subst">$&#123;str2.length&#125;</span>`</span>);  <span class="comment">// Ǒ</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`str1与str2是否相等？<span class="subst">$&#123;str1 === str2&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> params = [&#123;</span><br><span class="line">    param:<span class="string">'NFD'</span>,</span><br><span class="line">    beNorm:<span class="string">'str1'</span>,</span><br><span class="line">    beNormStr:str1,</span><br><span class="line">    beCompared:<span class="string">'str2'</span>,</span><br><span class="line">    beComparedStr:str2</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    param:<span class="string">'NFC'</span>,</span><br><span class="line">    beNorm:<span class="string">'str2'</span>,</span><br><span class="line">    beNormStr:str2,</span><br><span class="line">    beCompared:<span class="string">'str1'</span>,</span><br><span class="line">    beComparedStr:str1</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    param:<span class="string">'NFKD'</span>,</span><br><span class="line">    beNorm:<span class="string">'str1'</span>,</span><br><span class="line">    beNormStr:str1,</span><br><span class="line">    beCompared:<span class="string">'str2'</span>,</span><br><span class="line">    beComparedStr:str2</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    param:<span class="string">'NFKC'</span>,</span><br><span class="line">    beNorm:<span class="string">'str2'</span>,</span><br><span class="line">    beNormStr:str2,</span><br><span class="line">    beCompared:<span class="string">'str1'</span>,</span><br><span class="line">    beComparedStr:str1</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">params.forEach(<span class="function">(<span class="params">cur,idx</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;idx+<span class="number">1</span>&#125;</span>. 对<span class="subst">$&#123;cur.beNorm&#125;</span>进行<span class="subst">$&#123;cur.param&#125;</span>规范化`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`规范化后的<span class="subst">$&#123;cur.beNorm&#125;</span>与<span class="subst">$&#123;cur.beCompared&#125;</span>是否相等？<span class="subst">$&#123;cur.beNormStr.normalize(cur.param) === cur.beComparedStr&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`规范化前后<span class="subst">$&#123;cur.beNorm&#125;</span>的值分别为：<span class="subst">$&#123;cur.beNormStr&#125;</span>,<span class="subst">$&#123;cur.beNormStr.normalize(cur.param)&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`规范化前后<span class="subst">$&#123;cur.beNorm&#125;</span>的长度分别为：<span class="subst">$&#123;cur.beNormStr.length&#125;</span>,<span class="subst">$&#123;cur.beNormStr.normalize(cur.param).length&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>NFKC和NFKD比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">'\uFB00'</span> <span class="comment">// Ǒ</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'\u0066\u0066'</span> <span class="comment">// Ǒ</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`str1的原始值（即赋予str1的值）为<span class="subst">$&#123;<span class="built_in">String</span>.raw<span class="string">`\u01D1`</span>&#125;</span>，显示的值为<span class="subst">$&#123;str1&#125;</span>,长度为<span class="subst">$&#123;str1.length&#125;</span>`</span>);  <span class="comment">// Ǒ</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`str2的原始值（即赋予str2的值）为<span class="subst">$&#123;<span class="built_in">String</span>.raw<span class="string">`\u004F\u030C`</span>&#125;</span>，显示的值为<span class="subst">$&#123;str2&#125;</span>,长度为<span class="subst">$&#123;str2.length&#125;</span>`</span>);  <span class="comment">// Ǒ</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`str1与str2是否相等？<span class="subst">$&#123;str1 === str2&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> params = [&#123;</span><br><span class="line">    param:<span class="string">'NFD'</span>,</span><br><span class="line">    beNorm:<span class="string">'str1'</span>,</span><br><span class="line">    beNormStr:str1,</span><br><span class="line">    beCompared:<span class="string">'str2'</span>,</span><br><span class="line">    beComparedStr:str2</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    param:<span class="string">'NFC'</span>,</span><br><span class="line">    beNorm:<span class="string">'str2'</span>,</span><br><span class="line">    beNormStr:str2,</span><br><span class="line">    beCompared:<span class="string">'str1'</span>,</span><br><span class="line">    beComparedStr:str1</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    param:<span class="string">'NFKD'</span>,</span><br><span class="line">    beNorm:<span class="string">'str1'</span>,</span><br><span class="line">    beNormStr:str1,</span><br><span class="line">    beCompared:<span class="string">'str2'</span>,</span><br><span class="line">    beComparedStr:str2</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    param:<span class="string">'NFKC'</span>,</span><br><span class="line">    beNorm:<span class="string">'str2'</span>,</span><br><span class="line">    beNormStr:str2,</span><br><span class="line">    beCompared:<span class="string">'str1'</span>,</span><br><span class="line">    beComparedStr:str1</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    param:<span class="string">'NFKC'</span>,</span><br><span class="line">    beNorm:<span class="string">'str1'</span>,</span><br><span class="line">    beNormStr:str1,</span><br><span class="line">    beCompared:<span class="string">'str2'</span>,</span><br><span class="line">    beComparedStr:str2</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">params.forEach(<span class="function">(<span class="params">cur,idx</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;idx+<span class="number">1</span>&#125;</span>. 对<span class="subst">$&#123;cur.beNorm&#125;</span>进行<span class="subst">$&#123;cur.param&#125;</span>规范化`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`规范化后的<span class="subst">$&#123;cur.beNorm&#125;</span>与<span class="subst">$&#123;cur.beCompared&#125;</span>是否相等？<span class="subst">$&#123;cur.beNormStr.normalize(cur.param) === cur.beComparedStr&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`规范化前后<span class="subst">$&#123;cur.beNorm&#125;</span>的值分别为：<span class="subst">$&#123;cur.beNormStr&#125;</span>,<span class="subst">$&#123;cur.beNormStr.normalize(cur.param)&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`规范化前后<span class="subst">$&#123;cur.beNorm&#125;</span>的长度分别为：<span class="subst">$&#123;cur.beNormStr.length&#125;</span>,<span class="subst">$&#123;cur.beNormStr.normalize(cur.param).length&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>第四次比较中为什么str2没有进行组合？暂时还未解决该疑惑。</p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vuex学习笔记</title>
      <link href="/2020/04/24/vue/vuex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <content type="html"><![CDATA[<h3 id="mapState辅助函数"><a href="#mapState辅助函数" class="headerlink" title="mapState辅助函数"></a>mapState辅助函数</h3><p>第一个可选参数不太懂。<br>第二个参数可以为对象或者数组。<br>数组，适用于计算属性的名称和state的名称相同时。<br>对象，key为computed的key，value如果是字符串，直接返回该字符串对应的State。如果是函数，则函数的第一个参数为state。<br>辅助函数常与扩展运算符一起用。</p><h3 id="使用常量替代-Mutation-事件类型"><a href="#使用常量替代-Mutation-事件类型" class="headerlink" title="使用常量替代 Mutation 事件类型"></a>使用常量替代 Mutation 事件类型</h3><h4 id="具体实践："><a href="#具体实践：" class="headerlink" title="具体实践："></a>具体实践：</h4><ol><li>将mutation的名称全部作为常量提取到另一个文件<code>mutations-type.js</code>，并将全部常量export。</li><li>定义mutation时，导入<code>mutations-type.js</code>文件中的常量。并且在创建vuex的mutations中全部用常量作为类型名。</li><li>触发mutation，即调用commit时，需要将调用的类型名从<code>mutations-type.js</code>中引入，并使用常量作为commit方法的类型名。</li></ol><p>优点：</p><ol><li>如果需要修改mutation的类型名，只需将常量的值进行修改即可，无需改动其他内容。降低改动成本。</li><li>可以让合作者对整个应用的mutation一目了然。即mutation是如何定义的、何处调用的commit会更加清晰。</li></ol>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js遍历方法总结</title>
      <link href="/2020/04/23/js%E5%9F%BA%E7%A1%80/js%E9%81%8D%E5%8E%86%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#1">遍历语句</a><ol><li><a href="#1.1">for</a></li><li><a href="#1.2">for … of</a></li><li><a href="#1.3">for … in</a></li></ol></li><li><a href="#2">数组遍历方法</a></li><li><a href="#3">其他注意事项</a><ol><li><a href="#3.1">map</a></li><li><a href="#3.2">reduce</a></li></ol></li><li><a href="#4">一些思考</a></li></ol><h2 id="1-遍历语句"><a href="#1-遍历语句" class="headerlink" title="1.遍历语句"></a><div id="1">1.遍历语句</div></h2><h2 id="1-for"><a href="#1-for" class="headerlink" title="1.for"></a><div id="1.1">1.for</div></h2><p>极其简单，极其强大，但是书写麻烦，不予赘述。</p><h2 id="2-for-…-of"><a href="#2-for-…-of" class="headerlink" title="2. for … of"></a><div id="1.2">2. for … of</div></h2><p>主要用来对可迭代对象进行迭代，注意一下不同迭代对象的迭代形式。</p><h2 id="3-for-…-in"><a href="#3-for-…-in" class="headerlink" title="3. for … in"></a><div id="1.3">3. for … in</div></h2><p><strong>以任意顺序遍历一个对象的除Symbol以外的可枚举属性</strong>，主要用来迭代对象属性以及debug。</p><h2 id="2-数组遍历方法"><a href="#2-数组遍历方法" class="headerlink" title="2. 数组遍历方法"></a><div id="2">2. 数组遍历方法</div></h2><p>注意点：</p><ol><li>遍历方法的作用。</li><li>遍历方法的参数。</li><li>表达式的返回值是什么？</li><li>能否跳出遍历？</li><li>遍历方法的推荐使用场景。</li><li>遍历过程中数组是否实时更新。换句话说：被遍历的数组在遍历时的内容是否以调用该遍历方法时为准？</li><li>遍历时传入回调函数中的元素是数组中相应项的深拷贝吗？</li></ol><table><thead><tr><th>方法名</th><th>作用</th><th>参数</th><th>返回值</th><th>能否跳出遍历</th><th>常见使用场景</th></tr></thead><tbody><tr><td>map</td><td>对数组中的每一项使用回调方法进行处理，返回处理后的元素形成的新数组</td><td>回调函数（当前处理的元素、索引、原数组），this参数</td><td>处理后的元素组成的新数组。</td><td>否</td><td>需要对一个数组进行遍历，并且需要使用遍历产生的新数组</td></tr><tr><td>filter</td><td>过滤数组，生成新数组</td><td>回调函数（当前处理的元素、索引、原数组），this参数</td><td>回调函数返回值为true的元素组成的新数组</td><td>否</td><td>个人用的较多的情况便是过滤数组</td></tr><tr><td>every</td><td>判断数组中的每一项是否能通过测试</td><td>回调函数（当前处理的元素、索引、原数组），this参数</td><td>布尔值true/false</td><td>是</td><td>个人觉得最正规的用途可能就是检测数组中的元素是否符合某个特点，符合正规用途的使用场景较窄。但是作为唯一一个可以中途跳出遍历的循环，也可以用作for循环的更简便的替代方案——但是不推荐这种用法，还是针对不同场景使用更加符合语义的遍历方式吧</td></tr><tr><td>some</td><td>判断数组中是否有一项使得回调函数的返回值为true</td><td>回调函数（当前处理的元素、索引、原数组），this参数</td><td>布尔值true/false</td><td>是</td><td>针对某个数据在数组中是否“存在”的判断</td></tr><tr><td>reduce</td><td>对数组中的元素进行遍历，同时在遍历过程中能够进行累加，最后返回累加器最后的值</td><td>回调函数（即reducer函数，包括四个参数：累加器acc，当前值cur，索引idx，被调用的数组src），累加器的初始值</td><td>reduce函数返回累加器最后的值。reducer函数的返回值由使用者定义，该返回值将被分配给累加器</td><td>否</td><td>对数字进行操、使用字符串连接函数等处理字符串，用途十分广泛</td></tr><tr><td>reduceRight</td><td>同reduce，但遍历顺序为降序，即从数组的尾部向前遍历</td><td>同reduce</td><td>同reduce</td><td>否</td><td>同reduce</td></tr><tr><td>find</td><td>返回数组中满足提供的测试函数的第一个元素的值。</td><td>回调函数（当前处理的元素、索引、原数组），this参数</td><td>数组中满足回调函数的元素的值，未命中返回<code>undefined</code></td><td>是</td><td>寻找数组中的某一项</td></tr><tr><td>findIndex</td><td>大致与find相同，只是返回的为满足测试函数的元素的索引</td><td>同find</td><td>回调函数返回值为true的元素的索引，未命中返回-1</td><td>是</td><td>同find</td></tr><tr><td>forEach</td><td>对数组的每个元素执行一次给定的函数</td><td>调函数（当前处理的元素、索引、原数组），this参数</td><td>undefined</td><td>否。可以先使用filter，再使用forEach</td><td>可以替代for循环，更简洁一些。由于该方法会跳过数组中的空数组单元，用来处理系数数组的效果较好</td></tr></tbody></table><h3 id="遍历过程中数组是否实时更新。换句话说：被遍历的数组在遍历时的内容是否为调用遍历方法时为准？"><a href="#遍历过程中数组是否实时更新。换句话说：被遍历的数组在遍历时的内容是否为调用遍历方法时为准？" class="headerlink" title="遍历过程中数组是否实时更新。换句话说：被遍历的数组在遍历时的内容是否为调用遍历方法时为准？"></a>遍历过程中数组是否实时更新。换句话说：被遍历的数组在遍历时的内容是否为调用遍历方法时为准？</h3><h4 id="map、filter、every、some、find、findIndex等"><a href="#map、filter、every、some、find、findIndex等" class="headerlink" title="map、filter、every、some、find、findIndex等"></a>map、filter、every、some、find、findIndex等</h4><p>分情况，“修改”、“删除”、“新增”的情况不同，“修改”情况又分为修改前遍历该元素和修改后遍历到该元素。</p><ul><li>遍历中修改某个元素：在遍历到某个元素之前发生变化，遍历到该元素时得到的为变化后的值。若遍历后发生修改，则修改是会反映到原数组中的，但是不会影响之前的遍历。</li><li>遍历中删除某个元素：该元素变为underfined（empty?），但仍然占据在数组中的原位置。如果方法返回的是一个新数组，同时会影响新生成的数组的该索引的元素（根据修改规则判断是否影响）。生成的数组长度不变，原数组长度也不变。</li><li>遍历中新增某个元素：在遍历时不会对其进行遍历。</li></ul><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>规则有点不同。如果数组在迭代时被修改了，则其他元素会被跳过。</p><h3 id="上述方法，遍历时传入回调函数中的元素是数组中相应项的深拷贝吗？"><a href="#上述方法，遍历时传入回调函数中的元素是数组中相应项的深拷贝吗？" class="headerlink" title="上述方法，遍历时传入回调函数中的元素是数组中相应项的深拷贝吗？"></a>上述方法，遍历时传入回调函数中的元素是数组中相应项的深拷贝吗？</h3><p>不是。</p><h2 id="3-其他注意事项"><a href="#3-其他注意事项" class="headerlink" title="3. 其他注意事项"></a><div id="3">3. 其他注意事项</div></h2><h3 id="3-1-map"><a href="#3-1-map" class="headerlink" title="3.1 map"></a><div id="3.1">3.1 map</div></h3><p>在遍历过程中一定记得写明返回值！直接更改当前遍历的内容而不反回，不会反映到遍历结束生成的数组中！比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = arr.map(<span class="function"><span class="params">i</span>=&gt;</span>&#123;i.text = <span class="string">"测试"</span>;i.value=<span class="string">"测试"</span>&#125;);       <span class="comment">// 此时b数组中所有项的值皆undefined</span></span><br><span class="line"><span class="keyword">var</span> b = arr.map(<span class="function"><span class="params">i</span>=&gt;</span>&#123;<span class="keyword">return</span> &#123;<span class="attr">text</span>:<span class="string">"测试"</span>,<span class="attr">value</span>:<span class="string">"测试"</span>&#125;&#125;)     <span class="comment">// 此时b数组所有项的值才为一个包含text和value属性的对象</span></span><br></pre></td></tr></table></figure></p><h3 id="3-2-reduce"><a href="#3-2-reduce" class="headerlink" title="3.2 reduce"></a><div id="3.2">3.2 reduce</div></h3><p>注意一下reduce函数中累加器的初始值设置。</p><h2 id="4-一些思考"><a href="#4-一些思考" class="headerlink" title="4. 一些思考"></a><div id="4">4. 一些思考</div></h2><p>for循环功能很强大，但总不能处处都用for循环。在项目中只用for可能会徒增不必要的代码，使得代码写的复杂、晦涩，存在大量重复等。代码在保证运行效率的情况下，应该足够简洁，编写的代码才会更易懂、易维护，应该针对不同的场景使用合适的遍历方法。</p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue学习笔记：可复用性&amp;组合</title>
      <link href="/2020/04/20/vue/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0:%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7&amp;%E7%BB%84%E5%90%88/"/>
      <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#1">混入（mixin）</a></li><li><a href="#2">自定义指令</a></li><li><a href="#3">渲染函数&amp;JSX</a></li><li><a href="#4">插件</a></li><li><a href="#5">过滤器</a></li></ol><h2 id="1-混入"><a href="#1-混入" class="headerlink" title="1. 混入"></a><div id="1">1. 混入</div></h2><p>Vue中使用全局变量的方案。顾名思义，混入功能可以将vue组件的一些选项如data、created、methods，置入到每一个组件中，从而被每个组件使用。混入的内容将涉及所有组件——十分混乱；混入的内容可注入到每个组件中——十分深入。</p><ul><li>选项合并：解决混入时的同名选项冲突问题。<ul><li>数据对象：递归合并，组件优先。</li><li>生命周期钩子：合并为数组，mixin中的钩子先调用。</li><li>值为对象的选项：合并为同一个对象，键名冲突时组件优先（如methods中的同名方法）。</li></ul></li><li>全局混入：即全局注册，混入的主要使用场景。</li><li>自定义选项合并策略（不太清楚这一块的作用。）</li></ul><h3 id="全局混入用法实践"><a href="#全局混入用法实践" class="headerlink" title="全局混入用法实践"></a>全局混入用法实践</h3><ul><li><p>将混入内容单独写到一个文件中，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mixin = &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg:<span class="string">"Hello~"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> mixin</span><br></pre></td></tr></table></figure></li><li><p>在main.js文件中引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mixin <span class="keyword">from</span> <span class="string">'路径/mixin.js'</span></span><br><span class="line">Vue.mixin(mixin)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-自定义指令"><a href="#2-自定义指令" class="headerlink" title="2. 自定义指令"></a>2. <div id="2">自定义指令</div></h2><p>通过自定义指令可以更方便地控制dom的样式及行为，而不仅仅局限于v-bind、v-model、v-show等。</p><ul><li>钩子函数：类似组件的生命周期。这就是钩子函数就是自定义指令的生命周期。</li><li>钩子函数参数：所绑定元素的DOM、包含指令属性的对象、vnode、上一个vnode。</li><li>对象字面量：指令函数能够接收所有合法js语句。</li></ul><h2 id="3-渲染函数"><a href="#3-渲染函数" class="headerlink" title="3. 渲染函数"></a>3. <div id="3">渲染函数</div></h2><p>通过render函数，可以使用js编写模版。有时直接使用template编写模版重复度会较高，而使用js编写可以简洁很多。<br>这一部分内容比较多，理解难度比较大，暂时没有完全吃透。</p><h2 id="4-插件"><a href="#4-插件" class="headerlink" title="4. 插件"></a>4. <div id="4">插件</div></h2><p>可以通过插件封装经常使用的重复代码，在一定程度上减少了冗余代码。</p><h2 id="5-过滤器"><a href="#5-过滤器" class="headerlink" title="5. 过滤器"></a>5. <div id="5">过滤器</div></h2><p>主要用来格式化数据。除了可以在组件内部使用filers属性定义局部过滤器之外，还可以使用Vue.filter()定义全局过滤器。<br>过滤器的声明和使用方法：<a href="https://www.cnblogs.com/yan7/p/8133897.html" target="_blank" rel="noopener">https://www.cnblogs.com/yan7/p/8133897.html</a></p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>后台代码质量检查工具：SonarQube</title>
      <link href="/2020/04/09/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%A3%80%E6%9F%A5/%E4%BD%BF%E7%94%A8SonarQube%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%A3%80%E6%9F%A5/"/>
      <content type="html"><![CDATA[<p>SonarQube的安装、插件配置及个人的一些感受</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#1">安装SonarQube</a></li><li><a href="#2">配置相关插件</a><ol><li><a href="#2.1">汉化插件</a></li><li><a href="#2.2">导出代码质量检测报告插件</a></li></ol></li><li><a href="#3">其他SonarQube相关操作</a><ol><li><a href="#3.1">查看当前SonarQube版本</a></li></ol></li></ol><h2 id="1-安装SonarQube"><a href="#1-安装SonarQube" class="headerlink" title="1. 安装SonarQube"></a><span id="1">1. 安装SonarQube</span></h2><ol><li>前往SonarQube官网进行下载（推荐下载Community版本，免费，功能够用）：<a href="https://www.sonarqube.org/downloads/" target="_blank" rel="noopener">https://www.sonarqube.org/downloads/</a></li><li>下载完成后解压该文件，此处最好不要使用root用户进行解压。该步骤在官网文档的说明十分详细：<a href="https://docs.sonarqube.org/latest/setup/get-started-2-minutes/" target="_blank" rel="noopener">https://docs.sonarqube.org/latest/setup/get-started-2-minutes/</a> </li><li><p>解压后在命令行下进入解压后的文件夹，然后进入<code>bin</code>目录，该文件夹包含了不同平台下的脚本文件。如：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jsw-licensemacosx-universal-64</span><br><span class="line">linux-x86-64windows-x86-64</span><br></pre></td></tr></table></figure></li><li><p>根据自己的平台cd到相应文件夹下（博主是macos），然后输入<code>sonar.sh start</code>运行SonarQube。</p></li><li>进入SonarQube客户端界面：<a href="http://localhost:9000" target="_blank" rel="noopener">http://localhost:9000</a> </li></ol><h2 id="2-配置相关插件"><a href="#2-配置相关插件" class="headerlink" title="2. 配置相关插件"></a><span id="2">2. 配置相关插件</span></h2><h3 id="2-1-汉化插件"><a href="#2-1-汉化插件" class="headerlink" title="2.1 汉化插件"></a><span id="2.1">2.1 汉化插件</span></h3><ol><li>下载汉化插件。一定要下载相应版本，否则可能会无法启动SonarQube：<a href="https://github.com/SonarQubeCommunity/sonar-l10n-zh" target="_blank" rel="noopener">https://github.com/SonarQubeCommunity/sonar-l10n-zh</a></li><li>将下载后的插件移动到<code>sonarQube根目录/extensions/plugins</code></li><li>重启SonarQube</li></ol><h3 id="导出代码质量检测报告插件"><a href="#导出代码质量检测报告插件" class="headerlink" title="导出代码质量检测报告插件"></a><span id="2.2">导出代码质量检测报告插件</span></h3><ol><li>使用该仓库的python程序导出：<a href="https://github.com/ximone/Sonar_Report_Generator" target="_blank" rel="noopener">https://github.com/ximone/Sonar_Report_Generator</a></li></ol><h2 id="3-其他SonarQube相关操作"><a href="#3-其他SonarQube相关操作" class="headerlink" title="3. 其他SonarQube相关操作"></a><span id="3">3. 其他SonarQube相关操作</span></h2><h3 id="1-查看当前SonarQube的版本"><a href="#1-查看当前SonarQube的版本" class="headerlink" title="1. 查看当前SonarQube的版本"></a><span id="3.1">1. 查看当前SonarQube的版本</span></h3><p>在SonarQube的客户端界面选择Administration-&gt;System</p><h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><p>使用不多，课程要求才进行了初步尝试。<br>个人感觉该软件对一个软件开发团队而言意义更大一些。</p><ol><li>可以更好地帮助一个软件开发团队维护代码，使得代码编写符合内部的编码规范。</li><li>可以方便地review代码。</li></ol>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码质量检查 </tag>
            
            <tag> SonarQube </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js设计模式：发布订阅模式</title>
      <link href="/2020/04/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<p>通用实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 发布者。</span><br><span class="line">var publisherModel = &#123;</span><br><span class="line">    subscriber:&#123;&#125;,</span><br><span class="line">    listen:function(key,fn)&#123;</span><br><span class="line">        if(!this.subscriber[key])&#123;</span><br><span class="line">            this.subscriber[key] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        this.subscriber[key].push(fn);</span><br><span class="line">    &#125;,</span><br><span class="line">    publish:function()&#123;</span><br><span class="line">        let key = Array.prototype.shift.call(arguments),</span><br><span class="line">            fns = this.subscriber[key];</span><br><span class="line">        if(!fns || fns.length === 0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for(var i=0,fn;fn = fns[i++];)&#123;</span><br><span class="line">            fn.apply(this,arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 生成发布者</span><br><span class="line">var installPublisher = function(obj)&#123;</span><br><span class="line">    for(var i in publisherModel)&#123;</span><br><span class="line">        obj[i] = publisherModel[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实用vue工具推荐：treeselect多选插件</title>
      <link href="/2020/04/02/vue/%E5%AE%9E%E7%94%A8%E7%9A%84vue%E5%B7%A5%E5%85%B7%EF%BC%9Atreeselect%E5%A4%9A%E9%80%89%E6%8F%92%E4%BB%B6/"/>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><h4 id="options属性"><a href="#options属性" class="headerlink" title="options属性"></a>options属性</h4><p>options属性是一个数组，每一个对象为多选框的一条记录。每条记录拥有如下三个属性：</p><ul><li>id:该记录的唯一标识符，选中后将该值存放进v-model绑定的数组内。</li><li>label：用户看到的、显示的内容</li><li>children:子数据。</li></ul><h4 id="normalizer属性"><a href="#normalizer属性" class="headerlink" title="normalizer属性"></a>normalizer属性</h4><p>normalizer属性用于为options的id、label和children属性设置别名。格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">normalizer(node)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        id:node.key,                // options数组中对象的key属性作为原id属性。</span><br><span class="line">        label:node.name,            // options数组中对象的name属性作为原label属性。</span><br><span class="line">        children:node.subOptions    // options数组中对象的children属性作为原children属性。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS的那些坑</title>
      <link href="/2020/03/27/css%E5%9F%BA%E7%A1%80/CSS%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
      <content type="html"><![CDATA[<p>css中的坑不少啊。</p><a id="more"></a><h3 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h3><ol><li>webkit内核的浏览器中，该属性不支持小于<code>12px</code>的值。若要将字体设置的更小，可以使用css3中的<code>transform:scale()</code>。</li></ol>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6学习笔记（一）：let和const关键字的总结</title>
      <link href="/2020/03/23/es6/ES6%EF%BC%9Alet%E5%92%8Cconst%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<h2 id="let总结"><a href="#let总结" class="headerlink" title="let总结"></a>let总结</h2><p>let关键字：其所声明的变量，只在let命令所在的代码块内有效。</p><ol><li>暂时性死区（TDZ,Temporal Dead Zone），避免了使用var时出现的变量提升现象。</li><li>不允许重复声明。</li><li>在一些场景下取代了匿名立即执行函数（IIFE）。</li><li>结合块级作用域的用法。<ul><li>块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</li><li>使用let声明的变量，块外无法引用。</li><li>块内声明定义的函数，块外无法使用。（浏览器的实现有偏差）（应该避免在块级作用域内声明函数。在一定要声明函数的情况下，采用块级作用域的形式）</li></ul></li><li>声明的全局变量，不属于顶层对象的属性</li></ol><h2 id="const总结"><a href="#const总结" class="headerlink" title="const总结"></a>const总结</h2><p>const关键字：声明只读常量。一旦声明，常量的值就不能改变。<br>本质：变量指向的那个内存地址所保存的数据不得改动。</p><ol><li>声明时必须初始化。</li><li>只在声明所在的块级作用域中有效。</li><li>存在暂时性死区现象。</li><li>不可重复声明。</li><li>声明的全局变量，不属于顶层对象的属性。</li></ol>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> let </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript中的引用类型总结</title>
      <link href="/2020/03/16/js%E5%9F%BA%E7%A1%80/js%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
      <content type="html"><![CDATA[<p>常用的引用类型：</p><ol><li>Object类型。</li><li>Array类型。</li><li>Date类型。</li><li>RegExp类型。</li><li>Function类型。</li><li>基本包装类型（Boolean、Number、String）。</li><li>Global对象。</li></ol><p>其他：</p><ol><li>instanceof运算符</li></ol><h2 id="1-Objet类型"><a href="#1-Objet类型" class="headerlink" title="1. Objet类型"></a>1. Objet类型</h2><h3 id="创建实例的方法"><a href="#创建实例的方法" class="headerlink" title="创建实例的方法"></a>创建实例的方法</h3><ol><li>使用Object构造函数：<code>var a = new Object()</code></li><li>对象字面量方法：<code>var person = {name:&#39;Michael Zhang&#39;}</code></li></ol><h3 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h3><ol><li>使用点表示法：<code>alert(person.name)</code></li><li>使用方括号语法：<code>alert(person[&#39;name&#39;])</code></li></ol><h2 id="2-Array类型"><a href="#2-Array类型" class="headerlink" title="2. Array类型"></a>2. Array类型</h2><h3 id="创建数组的方法"><a href="#创建数组的方法" class="headerlink" title="创建数组的方法"></a>创建数组的方法</h3><ol><li>使用Array构造函数：<code>var nums = new Array(arrayLength)</code>，<code>var nums = Array(1,2,3,4,5)</code></li><li>使用数组字面量的方法：<code>var colors = [&quot;red&quot;,&quot;green&quot;]</code></li></ol><h3 id="判断Array的方式"><a href="#判断Array的方式" class="headerlink" title="判断Array的方式"></a>判断Array的方式</h3><ol><li><code>Array.isArray(arr)</code>最推荐！</li><li><code>instanceof</code> 运算符。如果有多个全局作用域可能会失效。</li></ol><h3 id="数组的排序方法"><a href="#数组的排序方法" class="headerlink" title="数组的排序方法"></a>数组的排序方法</h3><ol><li><code>sort()</code>，默认调用每个数组项的<code>toString()</code>方法，默认比较数组项的UTF-16代码单元值序列，按升序排列。接收一个比较函数作为参数，用于对数组项的两两比较。比较函数接收两个参数，分别代表当前比较的两个元素。如果比较函数的参数分别为a,b,返回值小于0，则a在b前。若等于0，二者相对位置不变，若返回值大于0，则b在a前。</li></ol><h3 id="数组与数据结构相关的方法"><a href="#数组与数据结构相关的方法" class="headerlink" title="数组与数据结构相关的方法"></a>数组与数据结构相关的方法</h3><ol><li>栈方法。<ul><li>入栈<code>push()</code>，如<code>colors.push(&quot;brown&quot;,&quot;yellow&quot;)</code>，返回值为入栈后的数组长度。</li><li>出栈<code>pop()</code>，返回值为数组的最后一项。</li></ul></li><li>队列方法。<ul><li>入队<code>push()</code>，返回值为入队列后的数组长度。</li><li>出队<code>shift()</code>，返回值为数组的第一项。<code>unshift</code>与之相反，是添加任意项元素至数组头部，返回值为插入后的数组长度。</li></ul></li></ol><h3 id="奇淫技巧"><a href="#奇淫技巧" class="headerlink" title="奇淫技巧"></a>奇淫技巧</h3><ol><li>length属性——数组的长度，是可以手动设置的。可以用来给数组末尾添加项：<code>var colors = [&quot;red&quot;];colors[colors.length] = &quot;green&quot;;</code></li></ol><h2 id="3-Date类型"><a href="#3-Date类型" class="headerlink" title="3. Date类型"></a>3. Date类型</h2><p>Date()对象表示某个时刻。</p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><h4 id="1-无参数"><a href="#1-无参数" class="headerlink" title="1. 无参数"></a>1. 无参数</h4><ul><li>语法：<code>new Date()</code></li><li>返回一个Date对象，该对象表示实例化Date()时的时刻。</li></ul><h4 id="2-Unix时间戳"><a href="#2-Unix时间戳" class="headerlink" title="2. Unix时间戳"></a>2. Unix时间戳</h4><ul><li>语法<code>new Date(timestamp)</code></li><li>示例：<code>new Date((new Date()).getTime()-1000*60*60*24)</code>，获取表示昨天当前时刻的date对象。</li><li>什么是Unix时间戳？一个 Unix 时间戳（Unix Time Stamp），它是一个整数值，表示自1970年1月1日00:00:00 UTC（the Unix epoch）以来的毫秒数，忽略了闰秒。</li></ul><h4 id="3-字符串（不建议）"><a href="#3-字符串（不建议）" class="headerlink" title="3. 字符串（不建议）"></a>3. 字符串（不建议）</h4><ul><li>形式：<code>new Date(dateString)</code></li><li>示例：<code>new Date(&#39;2020-03-16&#39;)</code>，获取表示当前日期、时间的小时数等于当前时区（博主是东八区），分、秒皆为0的时刻。该示例返回的时间日期为：<code>&quot;Sun Feb 02 2020 08:00:00 GMT+0800 (中国标准时间)&quot;</code></li><li>字符串的要求：该dateString需要能被<code>date.parse()</code>识别。</li></ul><h4 id="4-提供时间与日期的每一项成员"><a href="#4-提供时间与日期的每一项成员" class="headerlink" title="4. 提供时间与日期的每一项成员"></a>4. 提供时间与日期的每一项成员</h4><ul><li>语法：<code>new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]])</code></li><li>示例1：<code>new Date(2020,2)</code>，返回的date对象时间和日期为：<code>&quot;Sun Mar 01 2020 00:00:00 GMT+0800 (中国标准时间)&quot;</code><ul><li><strong>注意1</strong>：月数的索引从0开始，与字符串形式的索引不一致。</li><li><strong>注意2</strong>：时间默认从当前时区的0点开始。</li></ul></li><li>示例2：执行语句<code>new Date(2020,3,16)</code>返回的date对象的时间和日期为：<code>&quot;Thu Apr 16 2020 00:00:00 GMT+0800 (中国标准时间)&quot;</code></li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li><code>Date.now()</code>，返回自UTC时间1970-1-1 00:00:00至今所经过的毫秒数。<ul><li>执行语句：<code>Date.now()</code>。执行结果：<code>1584452901581</code></li></ul></li><li><code>Date.parse()</code>，解析一个表示日期的字符串，返回自UTC时间1970-1-1 00:00:00至今所经过的毫秒数。<ul><li>执行语句：<code>Date.parse(&#39;2020-03-17&#39;)</code>，执行结果：<code>1584403200000</code></li><li>执行语句：<code>(new Date(Date.parse(&quot;2020-03-17&quot;))).toString()</code>，执行结果：<code>&quot;Tue Mar 17 2020 08:00:00 GMT+0800 (中国标准时间)&quot;</code></li><li><strong>不建议使用，因浏览器的实现有差异</strong></li></ul></li><li><code>Date.UTC()</code>接受参数同构造器4“提供时间与日期的每一项成员”，返回自UTC时间1970-1-1 00:00:00至今所经过的毫秒数。<ul><li>执行语句：<code>Date.parse(2020,02,17)</code>，执行结果：<code>1584403200000</code>。注意此处的月份索引从0开始。</li><li>执行语句：<code>(new Date(Date.parse(2020,02,17))).toString()</code>，执行结果：<code>&quot;Tue Mar 17 2020 08:00:00 GMT+0800 (中国标准时间)&quot;</code></li></ul></li></ul><h4 id="Date-prototype-toDateString"><a href="#Date-prototype-toDateString" class="headerlink" title="Date.prototype.toDateString()"></a><code>Date.prototype.toDateString()</code></h4><ul><li>作用：以人类易读（human-readable）的形式返回该日期对象日期部分的字符串。</li><li>执行语句：<code>(new Date()).toDateString()</code>。执行结果：<code>&quot;Tue Mar 17 2020&quot;</code></li></ul><h4 id="Date-prototype-toISOString"><a href="#Date-prototype-toISOString" class="headerlink" title="Date.prototype.toISOString()"></a><code>Date.prototype.toISOString()</code></h4><ul><li>作用：把一个日期转换为符合 ISO 8601 扩展格式的字符串。》》》》》这里最好也做一个跳链。</li><li>ISO 8601：由国际标准化组织（ISO）提出的编号为8601的标准。该标准的全部内容需要收费阅读，但作为开发我们只需要看万维网联盟（W3C）根据ISO内容制定的标准即可<a href="https://www.w3.org/TR/NOTE-datetime" target="_blank" rel="noopener">Date and Time Formats</a>。比较重要的内容如下：<ul><li>完整的日期与时间格式，包含年、月、日、时、分、秒、秒的小数位和时区指示符：<code>YYYY-MM-DDThh:mm:ssTZD</code>，例如：<code>1997-07-16T19:20:30+01:00</code>。</li><li>使用UTC时区，则显示时区指示符<code>Z</code></li><li>使用本地时区，则显示时区指示符<code>+hh:mm</code>或<code>-hh:mm</code>。<code>+hh:mm</code>含义为”本地时区相较于UTC时区，要快hh个小时、mm分钟；<code>-hh:mm</code>含义为”本地时区相较于UTC时区要慢hh个小时、mm分钟”。</li></ul></li><li>执行语句：<code>(new Date()).toISOString()</code>。执行结果：<code>&quot;2020-03-17T14:22:12.947Z&quot;</code>（注：此时本地时间为2020-03-17,22:22:12）</li></ul><h4 id="Date-prototype-toJSON"><a href="#Date-prototype-toJSON" class="headerlink" title="Date.prototype.toJSON()"></a><code>Date.prototype.toJSON()</code></h4><ul><li>作用：使用 toISOString() 返回一个表示该日期的字符串。为了在 JSON.stringify() 方法中使用。</li><li>调用<code>toJSON()</code>作用和调用<code>toISOString()</code>一样一样的。为什么呢？请看后文》》》》这里给个跳链。</li><li>执行语句：<code>(new Date()).toJSON()</code>。执行结果：<code>&quot;2020-03-17T15:30:30.979Z&quot;</code>。</li></ul><h4 id="Date-prototype-toGMTString"><a href="#Date-prototype-toGMTString" class="headerlink" title="Date.prototype.toGMTString()"></a><code>Date.prototype.toGMTString()</code></h4><ul><li>作用：返回一个基于 GMT (UT) 时区的字符串来表示该日期。<strong>mdn官方不建议使用，请使用 toUTCString() 方法代替。</strong></li><li>执行语句：<code>(new Date()).toGMTString()</code>。执行结果：<code>&quot;Tue, 17 Mar 2020 15:37:56 GMT&quot;</code></li></ul><h4 id="Date-prototype-toLocaleDateString"><a href="#Date-prototype-toLocaleDateString" class="headerlink" title="Date.prototype.toLocaleDateString()"></a><code>Date.prototype.toLocaleDateString()</code></h4><ul><li>作用：返回一个表示该日期对象日期部分的字符串，该字符串格式与系统设置的地区关联（locality sensitive）。</li><li>执行语句：<code>(new Date()).toLocaleDateString()</code>。执行结果：<code>&quot;2020/3/18&quot;</code></li></ul><h4 id="Date-prototype-toLocaleString"><a href="#Date-prototype-toLocaleString" class="headerlink" title="Date.prototype.toLocaleString()"></a><code>Date.prototype.toLocaleString()</code></h4><ul><li>作用：返回一个表示该日期对象的字符串，该字符串与系统设置的地区关联（locality sensitive）。覆盖了 Object.prototype.toLocaleString() 方法。</li><li>执行语句：<code>(new Date()).toLocaleString()</code>。执行结果：<code>&quot;2020/3/18 下午11:45:03&quot;</code></li></ul><h4 id="Date-prototype-toLocaleTimeString"><a href="#Date-prototype-toLocaleTimeString" class="headerlink" title="Date.prototype.toLocaleTimeString()"></a><code>Date.prototype.toLocaleTimeString()</code></h4><ul><li>作用：返回一个表示该日期对象时间部分的字符串，该字符串格式与系统设置的地区关联（locality sensitive）。</li><li>执行语句：<code>(new Date()).toLocaleTimeString()</code>。执行结果：<code>&quot;下午11:47:12&quot;</code></li></ul><h4 id="Date-prototype-toString"><a href="#Date-prototype-toString" class="headerlink" title="Date.prototype.toString()"></a><code>Date.prototype.toString()</code></h4><ul><li>作用：返回一个表示该日期对象的字符串。覆盖了Object.prototype.toString() 方法。</li><li>执行语句：<code>(new Date()).toString()</code>。执行结果：<code>&quot;Wed Mar 18 2020 23:48:31 GMT+0800 (中国标准时间)&quot;</code></li></ul><h4 id="Date-prototype-toTimeString"><a href="#Date-prototype-toTimeString" class="headerlink" title="Date.prototype.toTimeString()"></a><code>Date.prototype.toTimeString()</code></h4><ul><li>作用：以人类易读格式返回日期对象时间部分的字符串。</li><li>执行语句：<code>(new Date()).toTimeString()</code>。执行结果：<code>&quot;23:50:22 GMT+0800 (中国标准时间)&quot;</code></li></ul><h4 id="Date-prototype-toUTCString"><a href="#Date-prototype-toUTCString" class="headerlink" title="Date.prototype.toUTCString()"></a><code>Date.prototype.toUTCString()</code></h4><ul><li>作用：把一个日期对象转换为一个以UTC时区计时的字符串。</li><li>执行语句：<code>(new Date()).toUTCString()</code>。执行结果：<code>&quot;Wed, 18 Mar 2020 15:51:49 GMT&quot;</code></li></ul><h4 id="Date-prototype-valueOf"><a href="#Date-prototype-valueOf" class="headerlink" title="Date.prototype.valueOf"></a><code>Date.prototype.valueOf</code></h4><ul><li>作用：返回一个日期对象的原始值。覆盖了 Object.prototype.valueOf() 方法。</li><li>执行语句：<code>(new Date()).valueOf()</code>。执行结果：<code>1584546764856</code></li></ul><h2 id="4-RegExp类型"><a href="#4-RegExp类型" class="headerlink" title="4. RegExp类型"></a>4. RegExp类型</h2><h3 id="创建实例的方法-1"><a href="#创建实例的方法-1" class="headerlink" title="创建实例的方法"></a>创建实例的方法</h3><ol><li>使用RegExp构造函数：<code>var pattern1 = new RegExp(&quot;[bc]at&quot;,&quot;i&quot;)</code>，<code>var pattern1 = new RegExp(/ab+c/,&quot;i&quot;)</code></li><li>使用字面量形式：<code>var pattern2 = /[bc]at/i</code></li></ol><h3 id="匹配方法"><a href="#匹配方法" class="headerlink" title="匹配方法"></a>匹配方法</h3><ol><li><code>exec()</code>，如：<code>var arr =  regex1.exec(str1)</code>。可以获取匹配的字符位于原字符串的索引、分组捕获、原始字符串等信息，同时RegExp对象也会更新下一次匹配开始的位置。更多信息详见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec</a></li><li><code>test()</code>，用来查看正则表达式与指定的字符串是否匹配，如：<code>let result = /^hello/.test(str)</code></li></ol><h2 id="5-Function类型。"><a href="#5-Function类型。" class="headerlink" title="5. Function类型。"></a>5. Function类型。</h2><h3 id="创建Function的方法"><a href="#创建Function的方法" class="headerlink" title="创建Function的方法"></a>创建Function的方法</h3><ol><li>函数声明。如：<code>function sum(num1,num2){return num1+num2}</code></li><li>函数表达式。如：<code>var sum = function(num1,num2){return num1+num2}</code><br>注意，函数声明存在提升。</li></ol><h3 id="函数内部的两个特殊变量"><a href="#函数内部的两个特殊变量" class="headerlink" title="函数内部的两个特殊变量"></a>函数内部的两个特殊变量</h3><ol><li><code>arguments</code>，保存函数参数。<code>arguments</code>有一个特殊属性<code>callee</code>，可用于与函数名解耦。</li><li><code>this</code>。</li></ol><h3 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h3><ol><li><code>length</code>属性，表示函数希望接收的命名参数的个数。</li><li><code>proptotype</code>属性。</li><li><code>apply</code>、<code>call</code>和<code>bind</code>，更改函数的作用域。<code>functionName.apply(作用域，arguments数组)</code>,<code>functionName.call(作用域，数组1，数组2)</code>，<code>var newFunction = functionName.bind(作用域)</code></li></ol><h2 id="6-基本包装类型"><a href="#6-基本包装类型" class="headerlink" title="6. 基本包装类型"></a>6. 基本包装类型</h2><p>基本包装类型是对应基本类型值的特殊的引用类型<br>读取String、Boolean或者Number基本类型值时，后台可能会执行如下操作：</p><ol><li>创建String类型的一个实例。</li><li>在实例上调用指定的方法。</li><li>销毁这个实例。<br>注意：后台自动生成的基本包装类型对象，和通过<code>new</code>操作符生成的基本包装类型对象，生命周期不同。后台自动生成的对象，只存在于一行代码执行的瞬间。而<code>new</code>操作符生成的基本包装类型的对象，在执行流离开当前作用域之前都一直保存在内存中。</li></ol><h3 id="Boolean包装类型"><a href="#Boolean包装类型" class="headerlink" title="Boolean包装类型"></a>Boolean包装类型</h3><p>注意，在布尔表达式中使用Boolean对象，会将其转化为true。<br>建议永远不要使用Boolean对象。</p><h3 id="Number包装类型"><a href="#Number包装类型" class="headerlink" title="Number包装类型"></a>Number包装类型</h3><ol><li><code>toString()</code>方法可以传递一个表示基数的参数。</li><li><code>toFixed()</code>方法可以传递指定小数位数的数字，将按指定的小数位返回数值的字符串表示。</li></ol><h3 id="String包装类型"><a href="#String包装类型" class="headerlink" title="String包装类型"></a>String包装类型</h3><ol><li><code>concat()</code>，将一个或多个字符串拼接起来，返回拼接得到的新字符串。</li></ol><h2 id="7-Global对象"><a href="#7-Global对象" class="headerlink" title="7. Global对象"></a>7. Global对象</h2><p>Math对象、Window对象等</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h2 id="1-instance运算符"><a href="#1-instance运算符" class="headerlink" title="1. instance运算符"></a>1. instance运算符</h2><p>用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。</p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL小记</title>
      <link href="/2020/03/15/mysql/Mysql%E5%B0%8F%E8%AE%B0/"/>
      <content type="html"><![CDATA[<p>记录使用mysql时常用的语法、函数和语句。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="case-when语句"><a href="#case-when语句" class="headerlink" title="case when语句"></a>case when语句</h3><ul><li>用于计算条件列表并返回多个可能结果表达式之一。</li><li>有两种形式，<strong>简单case函数</strong>和<strong>case搜索函数</strong></li></ul><h4 id="1-简单case函数"><a href="#1-简单case函数" class="headerlink" title="1. 简单case函数"></a>1. 简单case函数</h4><p>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE input_expression</span><br><span class="line">    WHEN when_expression THEN result_expression</span><br><span class="line">        [ ...n ]</span><br><span class="line">    [</span><br><span class="line">        ELSE else_result_expression</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></p><h4 id="2-case搜索函数"><a href="#2-case搜索函数" class="headerlink" title="2. case搜索函数"></a>2. case搜索函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE   </span><br><span class="line">WHEN Boolean_expression THEN result_expression</span><br><span class="line">        [ ...n ]</span><br><span class="line">    [</span><br><span class="line">        ELSE else_result_expression</span><br><span class="line">    END</span><br></pre></td></tr></table></figure><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="1-convert"><a href="#1-convert" class="headerlink" title="1. convert()"></a>1. convert()</h3><p>把字段转换成指定类型。</p><h3 id="2-concat"><a href="#2-concat" class="headerlink" title="2. concat()"></a>2. concat()</h3><ul><li>作用：拼接字符串。</li><li>语法：concat(str1,str2)</li></ul><h3 id="3-dayofweek"><a href="#3-dayofweek" class="headerlink" title="3. dayofweek()"></a>3. dayofweek()</h3><ul><li>作用：返回指定日期的工作日索引（即指定日期是一周中的第几天）。其中1是周日，2是周一，以此类推…7是周六。</li><li>语法：dayofweek(date)</li></ul><h3 id="4-dayofmonth"><a href="#4-dayofmonth" class="headerlink" title="4. dayofmonth()"></a>4. dayofmonth()</h3><ul><li>作用：返回指定日期所在月的天数的索引（即指定日期是一个月中的第几天）。范围为1到31。</li><li>语法：dayofmonth(date)</li></ul><h3 id="5-dayofyear"><a href="#5-dayofyear" class="headerlink" title="5. dayofyear()"></a>5. dayofyear()</h3><ul><li>作用：返回指定日期date所在年的天数的索引（即指定日期是一年中的第几天）。范围为1到366。</li><li>语法：dayofyear(date)</li></ul><h3 id="6-weekofyear"><a href="#6-weekofyear" class="headerlink" title="6. weekofyear()"></a>6. weekofyear()</h3><ul><li>作用：返回指定日期所在的星期是这一年的第几个星期。范围为1到53.</li><li>语法：weekofyear(date)</li></ul><h3 id="7-adddate-date-INTERVAL-expr-unit"><a href="#7-adddate-date-INTERVAL-expr-unit" class="headerlink" title="7. adddate(date,INTERVAL expr unit)"></a>7. adddate(date,INTERVAL expr unit)</h3><ul><li>作用：修改时间。向指定的日期添加指定的时间。</li><li>语法：adddate(date,INTERVAL expr unit)</li></ul><h3 id="8-curdate"><a href="#8-curdate" class="headerlink" title="8. curdate()"></a>8. curdate()</h3><ul><li>作用：返回当前的日期。</li><li>语法：curdate()</li></ul><h3 id="9-year"><a href="#9-year" class="headerlink" title="9. year()"></a>9. year()</h3><ul><li>作用：返回指定日期的年份。</li><li>语法：year(date)</li></ul><h3 id="10-month"><a href="#10-month" class="headerlink" title="10. month()"></a>10. month()</h3><ul><li>作用：返回指定日期的月份。</li><li>语法：month(date)</li></ul><h3 id="11-quarter"><a href="#11-quarter" class="headerlink" title="11. quarter()"></a>11. quarter()</h3><ul><li>作用：返回指定日期在一年中的季度。</li><li>语法：quarter(date)</li></ul><h3 id="12-sign"><a href="#12-sign" class="headerlink" title="12. sign()"></a>12. sign()</h3><ul><li>作用：根据X是负数、零或正数，将参数的符号返回为-1、0、或1</li><li>语法：sign(x)</li></ul><h3 id="13-find-in-set"><a href="#13-find-in-set" class="headerlink" title="13. find_in_set()"></a>13. find_in_set()</h3><p>FIND_IN_SET(str,strlist)</p><p>str 要查询的字符串<br>strlist 字段名 参数以”,”分隔 如 (1,2,6,8)<br>查询字段(strlist)中包含(str)的结果，返回结果为null或记录</p><p>假如字符串str在由N个子链组成的字符串列表strlist 中，则返回值的范围在 1 到 N 之间。 一个字符串列表就是一个由一些被 ‘,’ 符号分开的子链组成的字符串。如果第一个参数是一个常数字符串，而第二个是type SET列，则FIND_IN_SET() 函数被优化，使用比特计算。 如果str不在strlist 或strlist 为空字符串，则返回值为 0 。如任意一个参数为NULL，则返回值为 NULL。这个函数在第一个参数包含一个逗号(‘,’)时将无法正常运行。</p><h2 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h2><ol><li>修改自增字段的起始值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER table table_name</span><br><span class="line">AUTO_INCREMENT=起始值</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>搭建mysql环境（mac版本）</title>
      <link href="/2020/03/15/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/mac%E6%90%AD%E5%BB%BAmysql%E7%8E%AF%E5%A2%83/"/>
      <content type="html"><![CDATA[<p>简要地记录了mac系统搭建mysql数据库的过程。</p><a id="more"></a><h2 id="从官网下载安装包并进行安装"><a href="#从官网下载安装包并进行安装" class="headerlink" title="从官网下载安装包并进行安装"></a>从官网下载安装包并进行安装</h2><ol><li><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">官网</a>根据期望安装的版本号下载mysql。建议下载dmg包。</li><li>下载完成后，根据提示步骤安装。<ul><li>注意：mysql可能会生成默认密码，生成时有相应提示，请把默认密码记录下来。</li></ul></li><li>安装完毕，重启mac，可以发现系统偏好设置中添加了mysql的图标。</li><li>启动mysql服务后，在控制台输入<code>ps aux | grep mysql</code>，查找到mysql的运行路径。</li><li>根据运行路径找到mysql文件夹，并找到mysql程序的<code>bin</code>目录（即可运行的二进制文件目录）。笔者的路径为：<code>/usr/local/mysql/bin</code>。</li><li><p>添加mysql的路径至环境变量：<code>vim ~/.bash_profile</code>，添加如下内容：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MYSQL_HOME=/usr/local/mysql</span><br><span class="line">export PATH=$PATH:$MAVEN_HOME/bin:$MYSQL_HOME/bin</span><br></pre></td></tr></table></figure><p> 其中 <code>export MYSQL_HOME=/usr/local/mysql</code>和<code>export PATH=$PATH:$MYSQL_HOME/bin</code>是重点。<code>$MAVEN_HOME/bin:</code>可以忽略，这个仅仅是笔者电脑中又添加了MAVEN的环境变量。</p></li><li>运行<code>mysql -u root -p</code>，输入密码，登陆mysql，大功告成。</li></ol><h2 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a>推荐工具</h2><h3 id="图形化客户端"><a href="#图形化客户端" class="headerlink" title="图形化客户端"></a>图形化客户端</h3><p>Navicat Premium for Mac</p>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端代码检测工具：eslint</title>
      <link href="/2020/03/11/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%A3%80%E6%9F%A5/%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7eslint%E5%88%9D%E5%8D%B0%E8%B1%A1/"/>
      <content type="html"><![CDATA[<p>eslint配置简单、功能强大，官网文档丰富、实用。</p><p>一款难得的好工具。</p><a id="more"></a><h1 id="vue项目中使用eslint（vue-cli搭建）"><a href="#vue项目中使用eslint（vue-cli搭建）" class="headerlink" title="vue项目中使用eslint（vue-cli搭建）"></a>vue项目中使用eslint（vue-cli搭建）</h1><h2 id="1-安装eslint"><a href="#1-安装eslint" class="headerlink" title="1. 安装eslint"></a>1. 安装eslint</h2><ul><li>vue-cli安装eslint：在使用vue-cli搭建vue项目时，可选择安装eslint。</li><li>手动安装eslint至当前项目：<code>npm i eslint --save-dev</code></li><li>全局安装eslint命令行工具：<code>npm i eslint -g</code></li></ul><h2 id="2-配置eslint"><a href="#2-配置eslint" class="headerlink" title="2. 配置eslint"></a>2. 配置eslint</h2><h3 id="使用vue-cli安装eslint时的配置文件"><a href="#使用vue-cli安装eslint时的配置文件" class="headerlink" title="使用vue-cli安装eslint时的配置文件"></a>使用vue-cli安装eslint时的配置文件</h3><p>vue-cli安装eslint，有两种可能的配置文件方式</p><ol><li>配置文件集成在<code>package.json</code>文件中</li><li>配置文件为<code>.eslintrc.js</code><br>二者可同时生效</li></ol><h2 id="3-配置文件内容解读"><a href="#3-配置文件内容解读" class="headerlink" title="3. 配置文件内容解读"></a>3. 配置文件内容解读</h2><p>以我使用vue-cli搭建的项目的eslint配置文件为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* eslint配置 */</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    root: <span class="literal">true</span>,     <span class="comment">// 只在项目目录中寻找eslint配置文件，禁止向父级目录寻找配置文件。</span></span><br><span class="line">    env: &#123;          <span class="comment">// 在env中指定脚本的运行环境</span></span><br><span class="line">        node: <span class="literal">true</span>  <span class="comment">// 使用 Node.js 全局变量和 Node.js 作用域。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    extends: [                  <span class="comment">// 扩展配置</span></span><br><span class="line">        <span class="string">"plugin:vue/essential"</span>, <span class="comment">// 启用esline-plugin-vue的essential配置</span></span><br><span class="line">        <span class="string">"eslint:recommended"</span>    <span class="comment">// 启用eslint推荐的规则</span></span><br><span class="line">    ],</span><br><span class="line">    parserOptions: &#123;            <span class="comment">// 解析器选项</span></span><br><span class="line">        parser: <span class="string">"babel-eslint"</span>  <span class="comment">// 一个对Babel解析器的包装，使其能够与 ESLint 兼容。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [  <span class="comment">// 插件</span></span><br><span class="line">        <span class="string">'vue'</span>,  <span class="comment">// eslint-plugin-vue插件</span></span><br><span class="line">        <span class="string">'html'</span>  <span class="comment">// eslint-plugin-html插件</span></span><br><span class="line">    ],</span><br><span class="line">    rules: &#123;    <span class="comment">// 规则</span></span><br><span class="line">        <span class="string">"no-multiple-empty-lines"</span>: [<span class="number">2</span>, &#123; <span class="string">"max"</span>: <span class="number">3</span> &#125;],   <span class="comment">// 空行不得连续超过三行。</span></span><br><span class="line">        <span class="string">"no-extra-boolean-cast"</span>: <span class="number">2</span>,  <span class="comment">// 禁止不必要的布尔类型转换</span></span><br><span class="line">        <span class="string">"no-extra-semi"</span>: <span class="number">2</span>,          <span class="comment">// 禁止使用额外的分号，禁止情况如：";;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-规则的级别"><a href="#4-规则的级别" class="headerlink" title="4. 规则的级别"></a>4. 规则的级别</h2><ol><li>“off” or 0 - 关闭规则</li><li>“warn” or 1 - 将规则视为一个警告（不会影响退出码）</li><li>“error” or 2 - 将规则视为一个错误 (退出码为1)</li></ol><blockquote><p>这三个错误级别可以允许你细粒度的控制 ESLint 是如何应用规则。（摘自官方文档）</p></blockquote><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li>eslint官方文档：<a href="https://eslint.bootcss.com/" target="_blank" rel="noopener">https://eslint.bootcss.com/</a></li><li>plugin-vue-eslint官方文档：<a href="https://eslint.vuejs.org/" target="_blank" rel="noopener">https://eslint.vuejs.org/</a></li></ul>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码质量检查 </tag>
            
            <tag> eslint </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于异步（二）：async function</title>
      <link href="/2020/03/10/js%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8E%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E4%BA%8C/"/>
      <content type="html"><![CDATA[<p>只需要两个关键字：async、await，辅助Promise的一些方法，即可优雅地将异步请求进行串行处理。</p><p>本文主要展示async的用法。顺带将async与Promise进行比较，同时指出了setTimeout函数的一些注意事项。</p><a id="more"></a><h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2><h3 id="使用async和await将异步请求串行传里的方法"><a href="#使用async和await将异步请求串行传里的方法" class="headerlink" title="使用async和await将异步请求串行传里的方法"></a>使用async和await将异步请求串行传里的方法</h3><ol><li>首先要将包含异步操作的函数，声明为异步函数</li><li>在异步方法前加await关键字。</li></ol><h3 id="async关键字"><a href="#async关键字" class="headerlink" title="async关键字"></a>async关键字</h3><ol><li>async关键字的功能：声明异步函数。</li></ol><h3 id="await关键字"><a href="#await关键字" class="headerlink" title="await关键字"></a>await关键字</h3><ol><li>await关键字的功能：暂停异步函数的执行，等接收到Promise的执行结果后，再继续异步函数的执行。</li><li>await关键字的返回值：返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。</li><li>await关键字的使用条件：必须在async function中才能使用。</li></ol><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"准备执行异步方法..."</span>);</span><br><span class="line">    <span class="keyword">var</span> returnVal = <span class="keyword">await</span> asyncFunction();  <span class="comment">// asyncFunciton 是一个包含异步方法的函数，如包含ajax通信或setTimeout的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法执行完毕！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体示例1：串行执行异步方法"><a href="#具体示例1：串行执行异步方法" class="headerlink" title="具体示例1：串行执行异步方法"></a>具体示例1：串行执行异步方法</h2><p>只言片语可能无法很好理解，下面是一个小的示例，比较了promise的链式语法和async function的区别。</p><p>我们期望在两秒后，对value变量设置一个值，并打印其结果。但是在实现上有些条件。</p><ol><li>需要在一个方法中调用setTimeout。</li><li>在另一个方法中调用这个方法，并设置变量的值。</li></ol><p>是不是像极了平时写项目时，在一个方法中发起ajax请求，再另一个方法中调用这个请求，并接收请求返回的内容，对内容进行下一步的处理？</p><h3 id="第一种写法：一种错误的示例"><a href="#第一种写法：一种错误的示例" class="headerlink" title="第一种写法：一种错误的示例"></a>第一种写法：一种错误的示例</h3><p>不使用Promise、不使用async function，博主在什么都不懂时便写过类似的代码，但这种写法肯定不行，无法满足要求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function setValueAfter2Seconds()&#123;</span><br><span class="line">    return setTimeout(()=&gt;&#123;</span><br><span class="line">        console.log(&quot;setTimeout 执行完毕&quot;)</span><br><span class="line">        return &quot;new value&quot;</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test()&#123;</span><br><span class="line">    var value = &quot;old value&quot;;</span><br><span class="line">    console.log(&quot;准备调用&quot;);</span><br><span class="line">    value = setValueAfter2Seconds()</span><br><span class="line">    console.log(&quot;结束调用，准备打印值&quot;);</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>错误原因：</p><ol><li>注意，setTimeout回调函数的返回值和setTimeout的返回值没有任何关系！没有任何关系！没有任何关系！所以通过在setTimeout函数中进行return没有任何作用！setTimeout的返回值是一个唯一的id，用于传入给<code>clearTimeout</code>后可取消该定时器。</li><li>setTimeout方法和其他语句是异步执行的，具体原因需要了解js中的并发模型与事件循环的机制。我们只消知道setTimeout是个异步的方法即可。</li></ol><h3 id="第二种写法：Promise的写法"><a href="#第二种写法：Promise的写法" class="headerlink" title="第二种写法：Promise的写法"></a>第二种写法：Promise的写法</h3><p>使用Promise链式语法的方案如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setValueAfter2Seconds</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`setTimeout 准备执行`</span>)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`setTimeout 执行结束`</span>)</span><br><span class="line">            resolve(<span class="string">`new value`</span>);</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">"old value"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise执行函数 准备执行"</span>);</span><br><span class="line">    setValueAfter2Seconds().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Promise执行函数 执行结束"</span>);</span><br><span class="line">        value = res;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise链外部的内容仍然会先于setTimeout执行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面对代码进行分析</p><ol><li>在<code>setValueAfter2Seconds()</code>中，返回了一个Promise对象。该对象的参数为一个函数，叫做“执行函数”。执行函数接受的第一个参数resolve，是Promise的一个方法。当执行函数中的所有内容顺利完成时，将调用resolve函数，否则会调用reject函数（此处未添加，reject是执行器函数的第二个参数）。</li><li>在<code>test()</code>中，运行了<code>setValueAfter2Seconds()</code>后，执行Promise对象的then方法（<code>then()</code>即Promise的执行函数顺利完成后执行的方法），<code>then()</code>接收的参数为一个函数，被称作“处理方法（handlers）”。所有期望在<code>setValueAfter2Seconds()</code>方法执行完毕后，继续执行的代码需要写到“处理方法(handlers)”中。”处理方法”之外的语句，与Promise链中的语句仍然是异步执行（这点注意，这是Promise与async不同的最大表现之一）。</li></ol><h3 id="第三种写法：使用async"><a href="#第三种写法：使用async" class="headerlink" title="第三种写法：使用async"></a>第三种写法：使用async</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">setValueAfter2Seconds</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`setTimeout 准备执行`</span>)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`setTimeout 执行结束`</span>)</span><br><span class="line">            resolve(<span class="string">`new value`</span>);</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">"old value"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Prmomise执行函数准备执行"</span>);</span><br><span class="line">    value = <span class="keyword">await</span> setValueAfter2Seconds();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise执行函数 执行结束"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对代码进行分析：</p><ol><li>使用<code>async</code>关键字声明<code>test()</code>是一个异步函数。</li><li>使用<code>await</code>关键字暂停异步函数的执行，等待Promise执行函数运行完毕，接收Promise对象的处理结果，即resolve函数的参数<code>new value</code>，并赋值给value变量，然后执行后续的代码。</li></ol><h3 id="具体示例2：并行执行异步方法"><a href="#具体示例2：并行执行异步方法" class="headerlink" title="具体示例2：并行执行异步方法"></a>具体示例2：并行执行异步方法</h3><h3 id="Promise写法"><a href="#Promise写法" class="headerlink" title="Promise写法"></a>Promise写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncFunction1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法1 准备执行 等待时间设置为1秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法1"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法1 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> asyncFunction2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法2 准备执行 等待时间设置为2秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法2"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法2 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> concurrentPromise = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"开始并行执行异步方法"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.all([asyncFunction1(), asyncFunction2()]).then(<span class="function">(<span class="params">messages</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(messages[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">console</span>.log(messages[<span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise.all外部的内容仍然会先于setTimeout执行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="async写法1：使用Promise-all，所有异步方法执行完毕后执行后续内容。"><a href="#async写法1：使用Promise-all，所有异步方法执行完毕后执行后续内容。" class="headerlink" title="async写法1：使用Promise.all，所有异步方法执行完毕后执行后续内容。"></a>async写法1：使用Promise.all，所有异步方法执行完毕后执行后续内容。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncFunction1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法1 准备执行 等待时间设置为1秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法1"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法1 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> asyncFunction2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法2 准备执行 等待时间设置为2秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法2"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法2 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> concurrentAsync1 = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"开始并行执行异步方法"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([asyncFunction1(), asyncFunction2()]).then(<span class="function">(<span class="params">messages</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(messages[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">console</span>.log(messages[<span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise.all外部的内容与Promise.all顺序执行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="async写法2：异步方法同时执行，其他内容串行执行，遇到await时阻塞。"><a href="#async写法2：异步方法同时执行，其他内容串行执行，遇到await时阻塞。" class="headerlink" title="async写法2：异步方法同时执行，其他内容串行执行，遇到await时阻塞。"></a>async写法2：异步方法同时执行，其他内容串行执行，遇到await时阻塞。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncFunction1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法1 准备执行 等待时间设置为1秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法1"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法1 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> asyncFunction2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步方法2 准备执行 等待时间设置为2秒"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">"异步方法2"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"异步方法2 执行完毕"</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> concurrentAsync2 = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = [<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"开始并行执行异步方法"</span>);</span><br><span class="line">    </span><br><span class="line">    message[<span class="number">0</span>] = asyncFunction1();</span><br><span class="line">    message[<span class="number">1</span>] = asyncFunction2();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> message[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> message[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async1Funvtion1、asyncFunction2的并行执行，其他内容串行执行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="async-await和Promise链式写法的区别"><a href="#async-await和Promise链式写法的区别" class="headerlink" title="async await和Promise链式写法的区别"></a>async await和Promise链式写法的区别</h2><ol><li>async写法避免了Promise的链式写法。</li><li>结合使用async和Promise能发挥更大的作用。</li></ol>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js异步 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于异步方法（一）：使用Promise</title>
      <link href="/2020/03/05/js%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8E%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E4%B8%80/"/>
      <content type="html"><![CDATA[<h2 id="1-时刻牢记：ajax请求是异步的。"><a href="#1-时刻牢记：ajax请求是异步的。" class="headerlink" title="1. 时刻牢记：ajax请求是异步的。"></a>1. 时刻牢记：ajax请求是异步的。</h2><p>比如：A方法调用ajax请求,B方法调用A方法，同时B方法调用C方法进行一些涉及到ajax返回的数据的处理工作（因某些原因该工作不能放到ajax请求的回调函数中，比如需要用到另一个ajax请求的内容）。</p><p>伪代码如下，用axios替代ajax请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 这段代码的目的：通过B函数，成功为经过ajax请求获取到的id设置name。</span><br><span class="line"></span><br><span class="line">// 全局变量</span><br><span class="line">var data = []   // 我们最终要设置的变量</span><br><span class="line">var mapRelation = [&#123;userId:123,userName:1234&#125;]  // 注意：这是通过另外一个ajax请求获得的。所以处理函数C不能或者说不方便放到A方法中。</span><br><span class="line"></span><br><span class="line">// 该方法通过异步请求，获取Id。</span><br><span class="line">function A()&#123;</span><br><span class="line">    return axios(请求参数).then(res=&gt;&#123;</span><br><span class="line">        // 对请求所返回内容的处理工作</span><br><span class="line">        // 假如res为&#123;userId:123&#125;;</span><br><span class="line">        data.push(res); </span><br><span class="line">    &#125;).catch(err=&gt;console.log(err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 该方法通过对象data的userId，为data设置userName。</span><br><span class="line">function C(data)&#123;</span><br><span class="line">    mapRelation.map(userItem=&gt;&#123;</span><br><span class="line">        if(userItem.userId === data.userId)&#123;</span><br><span class="line">            data.userName = userItem.uesrName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设计B函数，为经过ajax请求获取到的id设置name。</span><br><span class="line">// 错误的写法。</span><br><span class="line">function bWrong()&#123;</span><br><span class="line">    // 这里并不会成功地为后台传来的userId找到usernName。</span><br><span class="line">    // 因为A中axios请求的回调函数和函数C()是并行的关系。</span><br><span class="line">    A();</span><br><span class="line">    C();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 正确的写法</span><br><span class="line">function bCorrect()&#123;</span><br><span class="line">    // 由于axios().then()返回的是一个promise对象（），该对象又被A函数返回，于是可以通过.then()的方式进行串行处理请求。</span><br><span class="line">    A().then(()=&gt;&#123;</span><br><span class="line">        C();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><ol><li>Promise.then()的语法如下。其中<code>[]</code>中的内容代表可选内容。<code>Promise.then(onFulfilled[,onRejected])。</code></li><li>then()返回一个 Promise 对象。(关于Promise.then()的更多内容<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener">mdn</a>)</li><li>catch()返回一个 Promise 对象。(关于Promise.catch()的更多内容<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch" target="_blank" rel="noopener">mdn</a>)</li><li>Promise定义于ES6.</li></ol><h2 id="2-在多个异步请求执行完毕后，执行一段代码——Promise-all"><a href="#2-在多个异步请求执行完毕后，执行一段代码——Promise-all" class="headerlink" title="2. 在多个异步请求执行完毕后，执行一段代码——Promise.all()"></a>2. 在多个异步请求执行完毕后，执行一段代码——Promise.all()</h2><p>在写项目的时候经常会遇到，需要得到两个ajax请求的结果后，才能进行数据处理的场景。此时用Promise.all()便能将两个异步请求与数据处理方法进行串行化。</p><p>一般的写法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([方法1，方法2]).then(res=&gt;&#123;</span><br><span class="line">    需要串行执行的方法</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="补充：-1"><a href="#补充：-1" class="headerlink" title="补充："></a>补充：</h4><ol><li>Promise.all(iterable)方法，返回一个Promise实例。如果iterable参数的所有方法执行成功，则返回的Promise实例中的参数为iterable执行成功后的返回值。否则返回没有成功执行的原因。</li></ol><h2 id="3-不得不说：Promise真的是个好东西。"><a href="#3-不得不说：Promise真的是个好东西。" class="headerlink" title="3. 不得不说：Promise真的是个好东西。"></a>3. 不得不说：Promise真的是个好东西。</h2><ol><li>解决了异步请求进行同步执行的问题。</li><li>解决了回调地狱的问题，链式调用简介又直观还好写。</li></ol><h3 id="Promise对象的状态"><a href="#Promise对象的状态" class="headerlink" title="Promise对象的状态"></a>Promise对象的状态</h3><ul><li>pendding，指异步操作正在进行中。</li><li>fulfilled，指异步操作成功完成。</li><li>rejected，指异步操作执行失败。</li></ul><h4 id="补充：Promise相关的方法"><a href="#补充：Promise相关的方法" class="headerlink" title="补充：Promise相关的方法"></a>补充：Promise相关的方法</h4><ol><li><code>Promise.resolve()</code>：个人理解是Prmoise的一个状态，指问题成功解决、代码成功运行,设置Promise处于fulfilled状态。</li><li><code>Promise.reject()</code>：问题解决失败或代码运行失败。</li><li><code>Promise.then(succes,failed)</code>：在then中加入Promise状态为fulfilled或者reject的回调函数，链式执行。</li><li><code>Promise.catch(failed)</code>：仅在Promise状态为reject或者抛出异常时运行catch中的函数。</li><li><code>Promise.finally()</code>：仅在Promise结束时运行，无论结果是reject还是fulfilled。</li><li><code>Promise.all(iterator)</code>：执行iterator中的所有方法，方法之间是且的关系。如果全部方法的执行结果全部为fulfilled或未返回Promise的情况，回调fulfilled，否则回调reject。</li><li><code>Promise.race(iterator)</code>：执行iterator中的方法，方法之间可以理解为或的关系。回调的是最早执行的函数的状态，如果最早的函数执行结果是fulfilled，则回调fulfilled，否则回调reject。如果迭代内容iterator是空，则永远等待。</li><li><code>Promise.allSettled(iterator)</code>将iterator包装成一个Prmoise实例，再执行iterator中的方法，所有方法都完成后才返回结果，返回结果是包含iterator执行结果的数组，且返回时Promise的状态一定是fulfilled。返回结果的数组中，每一项都有status属性，对应着Prmoise的执行结果，值为<code>&#39;fulfilled&#39;</code>或<code>&#39;rejected&#39;</code>。该方法由ES2020引入。</li><li><code>Promise.any(iterator)</code>执行iterator中的方法。如果iterator中某个方法返回的Promise状态为fulfilled，则函数回调fulfilled，否则当所有方法都返回rejected时，才回调rejected方法。该方法当前处于第三阶段提案。</li><li><code>Promise.try()</code>现在仍然属于提案，可以捕获Promise执行函数中的所有同步和异步错误。与<code>Promise.catch()</code>相呼应。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>使用Promise。From mdn：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises</a></li><li>Promise对象：From mdn：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></li><li>Promise对象：From 阮一峰：<a href="https://es6.ruanyifeng.com/#docs/promise#Promise-reject" target="_blank" rel="noopener">https://es6.ruanyifeng.com/#docs/promise#Promise-reject</a></li></ul>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js异步 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《你不知道的JavaScript 上册》第一部分</title>
      <link href="/2020/01/31/js%E5%9F%BA%E7%A1%80/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%20%E4%B8%8A%E5%8D%B7%E3%80%8B%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
      <content type="html"><![CDATA[<p>第一部分：作用域和闭包</p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol><li><a href="#chapter1">作用域是什么</a><br> 1.1. <a href="#1.1">编译原理</a><br> 1.2. <a href="#1.2">理解作用域</a></li><li><a href="#chapter2">词法作用域</a><br> 2.1. <a href="#2.1">词法阶段</a><br> 2.2. <a href="#2.2">欺骗词法</a></li><li><a href="#chapter3">函数作用域和块作用域</a><br> 3.1. <a href="#3.1">函数中的作用域</a><br> 3.2. <a href="#3.2">隐藏内部实现</a><br> 3.3. <a href="#3.3">块作用域</a></li><li><a href="#chapter4">提升</a></li><li><a href="#chapter5">作用域闭包</a><br> 5.2. <a href="#5.2">实质问题</a><br> 5.4. <a href="#5.4">循环和闭包</a><br> 5.5. <a href="#5.5">模块</a></li><li><a href="#appendixA">附录A</a></li><li><a href="#appendixB">附录B 块作用域的替代方案</a><br> B.1. <a href="#B.1">Traceur</a><br> B.2. <a href="#B.2">隐式和显式作用域</a><br> B.3. <a href="#B.3">性能</a></li><li><a href="#appendixC">附录C this词法</a></li></ol><hr><h2 id="第一章-作用域是什么"><a href="#第一章-作用域是什么" class="headerlink" title="第一章 作用域是什么"></a><div id="chapter1">第一章 作用域是什么</div></h2><h3 id="1-1-编译原理"><a href="#1-1-编译原理" class="headerlink" title="1.1 编译原理"></a><div id="1.1">1.1 编译原理</div></h3><ul><li>编译代码的三个步骤<ol><li>分词/词法分析：将字符串分解成(对编程语言来说)有意义的代码块，这些代码块被称为词法单元(token)。</li><li>解析/语法分析：将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。</li><li>代码生成：将 AST 转换为可执行代码的过程称被称为代码生成。<br>编译器编译完毕后，由引擎执行生成的代码。</li></ol></li></ul><h3 id="1-2-理解作用域"><a href="#1-2-理解作用域" class="headerlink" title="1.2 理解作用域"></a><div id="1.2">1.2 理解作用域</div></h3><ul><li>LHS查询：变量出现在赋值操作的左侧时进行的查询。试图找到变量的容器本身，<code>set</code>操作，当执行非法操作时，比如对一个没有声明的变量进行赋值，非严格模式下的引擎会自动声明该变量，而非严格模式会报错<code>ReferenceError</code>。</li><li>RHS查询：变量出现在赋值操作的右侧时进行的查询。retrieve his source value，取到它的值，类似<code>get</code>操作，可能会引发两种错误：1. <code>ReferenceError</code>同作用域判别失败相关 2. <code>TypeError</code>则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</li></ul><h2 id="第二章-词法作用域"><a href="#第二章-词法作用域" class="headerlink" title="第二章 词法作用域"></a><div id="chapter2">第二章 词法作用域</div></h2><p>作用域的两种工作模型：</p><ul><li>词法作用域。</li><li>动态作用域。<br>JavaScript采用的是词法作用域。</li></ul><h3 id="2-1-词法阶段"><a href="#2-1-词法阶段" class="headerlink" title="2.1 词法阶段"></a><div id="2.1">2.1 词法阶段</div></h3><ul><li>标识符查找：从当前作用域，逐级向上，找到为止。<ul><li>引申：遮蔽效应(内部的标识符“遮蔽”了外部的标识符)</li></ul></li><li>全局变量与全局对象的关系：全局变量会自动成为全局对象(比如浏览器中的 window 对象)的属性。</li></ul><h3 id="2-2-欺骗词法"><a href="#2-2-欺骗词法" class="headerlink" title="2.2 欺骗词法"></a><div id="2.2">2.2 欺骗词法</div></h3><p>欺骗词法即在运行时修改词法的作用域。</p><ul><li><p>注意：不推荐进行欺骗词法。</p><ul><li>原因1：作用域会导致性能“下降”。引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。</li><li>原因2：会被严格模式所影响(限制)。<code>with</code>被完全禁止，而在保留核心功能的前提下，间接或非安全地使用<code>eval(..)</code>也被禁止了。</li></ul></li><li><p>欺骗词法的两种方式：</p><ul><li>eval函数：eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。<ul><li>注意：在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其 中的声明无法修改所在的作用域。</li></ul></li><li>with关键字：重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。<ul><li>注意：尽管<code>with</code>块可以将一个对象处理为词法作用域，但是这个块内部正常的<code>var</code>声明并不会被限制在这个块的作用域中，而是被添加到<code>with</code>所处的函数作用域中。使用let即可避免污染函数作用域。</li></ul></li></ul></li></ul><h2 id="第三章-函数作用域和块作用域"><a href="#第三章-函数作用域和块作用域" class="headerlink" title="第三章 函数作用域和块作用域"></a><div id="chapter3">第三章 函数作用域和块作用域</div></h2><h3 id="3-1-函数中的作用域"><a href="#3-1-函数中的作用域" class="headerlink" title="3.1 函数中的作用域"></a><div id="3.1">3.1 函数中的作用域</div></h3><ul><li>函数作用域的概念：属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)。</li></ul><h3 id="3-2-隐藏内部实现"><a href="#3-2-隐藏内部实现" class="headerlink" title="3.2 隐藏内部实现"></a><div id="3.2">3.2 隐藏内部实现</div></h3><ul><li>为什么要隐藏内部实现？<ul><li>最小特权原则（最小授权原则、最小暴露原则）：软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。</li><li>规避冲突。避免命名冲突，污染全局作用域。</li></ul></li><li>隐藏内部实现的原理：将变量和函数用函数包裹起来，将其放置在函数作用域中。</li><li>隐藏内部实现的方法<ul><li>全局命名空间。在全局作用域中声明一个独特的变量，作为库的命名空间，所有需要暴露给外界的功能都是其属性。参考jquery（使用$符号），d3.js（使用d3）。</li><li>模块管理。使用依赖管理器，将库的标识符显示地导入到特定的作用域中。</li><li>IIFE，代表立即执行函数表达式 (Immediately Invoked Function Expression)。（具名函数的 IIFE 是最佳实践）</li></ul></li><li>函数表达式和函数声明的辨析<ul><li>函数表达式：函数被包含在一对 ( ) 括号内部，因此成为了一个表达式。</li><li>函数声明：第一个单词必须是function。</li><li>函数表达式可以是匿名的，而函数声明则不可以省略函数名。始终给函数表达式命名是一个最佳实践。</li></ul></li><li>IIFE的进阶用法<ul><li>把它们当作函数调用并传递参数进去。</li><li>将一个参数命名为 undefined，但是在对应的位置不传入任何值，这样就可以 保证在代码块中 undefined 标识符的值真的是 undefined。</li><li>倒置代码的运行顺序。</li></ul></li></ul><h3 id="3-3-块作用域"><a href="#3-3-块作用域" class="headerlink" title="3.3 块作用域"></a><div id="3.3">3.3 块作用域</div></h3><ul><li><p>形式上的块作用域，实际上并不是块作用域的写法，会导致变量污染到整个函数作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var foo = true;</span><br><span class="line">if (foo) &#123;</span><br><span class="line">    var bar = foo * 2;</span><br><span class="line">    bar = something( bar ); console.log( bar );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>块作用域实现的几种方法</p><ul><li>with。用 with 从对象中创建出的作用域仅在 with 声明中而非外 部作用域中有效。</li><li>try/catch。JavaScript 的 ES3 规范中规定 try/catch 的 catch 分句会创建一个块作用域，其中声明的变量（catch的实参？）仅在 catch 内部有效。如果在catch的代码块中使用var声明变量，在函数作用域中仍然能获取到声明的变量。</li><li>let。ES6引入的新关键字，实现块作用域的最好方式。</li><li>const。ES6引入的新关键字，同样可以实现块作用域，但变量的值不可以更改。</li></ul></li><li>块作用域可以将无用的变量进行垃圾回收。</li></ul><h2 id="第四章-提升"><a href="#第四章-提升" class="headerlink" title="第四章 提升"></a><div id="chapter4">第四章 提升</div></h2><p>变量声明在作用域中出现的位置不同，会导致不同的影响。</p><ul><li>提升的本质：代码的执行分为两个阶段：编译阶段和执行阶段。编译阶段编译器找到所有的声明，并用合适的作用域将它们关联起来。执行阶段引擎会直接执行代码。</li><li>提升的对象：只有声明本身会被提升（无论是变量声明还是函数声明），而赋值或其他运行逻辑会留在原地。</li><li>提升需要注意的点：<ul><li>即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用。</li><li>函数会首先被提升，然后才是变量。</li><li>函数会首先被提升，然后才是变量。</li><li>尽量避免重复声明。</li></ul></li></ul><h2 id="第五章-作用域闭包"><a href="#第五章-作用域闭包" class="headerlink" title="第五章 作用域闭包"></a><div id="chapter5">第五章 作用域闭包</div></h2><p>函数与对其状态即词法环境（lexical environment）的引用共同构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在JavaScript，函数在每次创建时生成闭包。（from mdn）</p><h3 id="5-2-实质问题"><a href="#5-2-实质问题" class="headerlink" title="5.2 实质问题"></a><div id="5.2">5.2 实质问题</div></h3><ul><li>下面的这段代码清晰地展示了什么叫闭包：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123; </span><br><span class="line">    var a = 2;</span><br><span class="line">    function bar() &#123; </span><br><span class="line">        console.log( a );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return bar; </span><br><span class="line">&#125;    </span><br><span class="line">var baz = foo();</span><br><span class="line">baz(); // 2 —— 朋友，这就是闭包的效果。</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-4-循环和闭包"><a href="#5-4-循环和闭包" class="headerlink" title="5.4 循环和闭包"></a><div id="5.4">5.4 循环和闭包</div></h3><ul><li><p>想要实现每隔一秒钟，按顺序打印出<code>1 2 3 4 5</code>。</p><ul><li><p>代码不能写成如下的形式，打印的结果会是每隔一秒钟输出一个6，原因是setTimeOut的回调函数是在循环结束了之后才执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (var i=1; i&lt;=5; i++) &#123; </span><br><span class="line">    setTimeout( function timer() &#123;</span><br><span class="line">    console.log( i ); &#125;, i*1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码可以写成如下形式：</p><ul><li><p>第一种方式，通过IIFE，创建新的作用域，并在新的作用域中记录循环时的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i=1; i&lt;=5; i++) &#123; (function(j) &#123;</span><br><span class="line">    setTimeout( function timer() &#123; console.log( j );</span><br><span class="line">        &#125;, j*1000 );</span><br><span class="line">    &#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二种方式，使用闭包的块作用域：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i=1; i&lt;=5; i++) &#123; </span><br><span class="line">    setTimeout( function timer() &#123;</span><br><span class="line">    console.log( i ); &#125;, i*1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>模块模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function CoolModule() &#123;</span><br><span class="line">    var something = &quot;cool&quot;;</span><br><span class="line">    var another = [1, 2, 3];</span><br><span class="line">    </span><br><span class="line">    function doSomething() &#123; </span><br><span class="line">        console.log( something );</span><br><span class="line">    &#125;</span><br><span class="line">    function doAnother() &#123;</span><br><span class="line">        console.log( another.join( &quot; ! &quot; ) );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">        doSomething: doSomething, </span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br><span class="line">var foo = CoolModule(); </span><br><span class="line">foo.doSomething(); // cool</span><br><span class="line">foo.doAnother(); // 1 ! 2 ! 3</span><br></pre></td></tr></table></figure></li><li><p>闭包经模块模式稍加改进后实现的单例模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var foo = (function CoolModule() &#123; var something = &quot;cool&quot;;</span><br><span class="line">    var another = [1, 2, 3];</span><br><span class="line">    function doSomething() &#123; </span><br><span class="line">        console.log( something );</span><br><span class="line">    &#125;</span><br><span class="line">    function doAnother() &#123;</span><br><span class="line">        console.log( another.join( &quot; ! &quot; ) );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">        doSomething: doSomething, </span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;)();</span><br><span class="line">foo.doSomething(); // cool </span><br><span class="line">foo.doAnother(); // 1 ! 2 ! 3</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-5-模块"><a href="#5-5-模块" class="headerlink" title="5.5 模块"></a><div id="5.5">5.5 模块</div></h3><p>模块有两个主要特征:</p><ol><li>为创建内部作用域而调用了一个包装函数;</li><li>包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</li></ol><h3 id="5-5-1-现代的模块机制"><a href="#5-5-1-现代的模块机制" class="headerlink" title="5.5.1 现代的模块机制"></a>5.5.1 现代的模块机制</h3><ul><li><p>一个模块管理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var MyModules = (function Manager() &#123;</span><br><span class="line">    var modules = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    function define(name, deps, impl) &#123;</span><br><span class="line">        for (var i=0; i&lt;deps.length; i++) &#123;</span><br><span class="line">            deps[i] = modules[deps[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        modules[name] = impl.apply( impl, deps ); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function get(name) &#123; </span><br><span class="line">        return modules[name];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">        define: define,</span><br><span class="line">        get: get </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>使用模块管理器来定义模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">MyModules.define( &quot;bar&quot;, [], function() &#123; </span><br><span class="line">    function hello(who) &#123;</span><br><span class="line">        return &quot;Let me introduce: &quot; + who; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">        hello: hello</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MyModules.define( &quot;foo&quot;, [&quot;bar&quot;], function(bar) &#123; </span><br><span class="line">    var hungry = &quot;hippo&quot;;</span><br><span class="line">    function awesome() &#123;</span><br><span class="line">        console.log( bar.hello( hungry ).toUpperCase() );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">        awesome: awesome</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var bar = MyModules.get( &quot;bar&quot; );</span><br><span class="line">var foo = MyModules.get( &quot;foo&quot; ); </span><br><span class="line">console.log( bar.hello( &quot;hippo&quot; )); // Let me introduce: hippo </span><br><span class="line">foo.awesome(); // LET ME INTRODUCE: HIPPO</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-5-2-未来的模块机制"><a href="#5-5-2-未来的模块机制" class="headerlink" title="5.5.2 未来的模块机制"></a>5.5.2 未来的模块机制</h3><ul><li><p>bar.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function hello(who) &#123;</span><br><span class="line">    return &quot;Let me introduce: &quot; + who;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export hello;</span><br></pre></td></tr></table></figure></li><li><p>foo.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 仅从 &quot;bar&quot; 模块导入 hello() import hello from &quot;bar&quot;;</span><br><span class="line">var hungry = &quot;hippo&quot;;</span><br><span class="line">function awesome() &#123; </span><br><span class="line">    sconsole.log(hello( hungry ).toUpperCase() );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export awesome;</span><br></pre></td></tr></table></figure></li><li><p>baz.js,导入完整的 “foo” 和 “bar” 模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module foo from &quot;foo&quot;; </span><br><span class="line">module bar from &quot;bar&quot;;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">    bar.hello( &quot;rhino&quot; )</span><br><span class="line">); // Let me introduce: rhino </span><br><span class="line"></span><br><span class="line">foo.awesome(); // LET ME INTRODUCE: HIPPO</span><br></pre></td></tr></table></figure></li><li><p>import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量 上(在我们的例子里是 hello)。</p></li><li>module 会将整个模块的 API 导入并绑定到一个变量上(在 我们的例子里是 foo 和 bar)。</li><li>export 会将当前模块的一个标识符(变量、函数)导出为公 共 API。</li><li>这些操作可以在模块定义中根据需要使用任意多次。</li></ul><h2 id="附录A-动态作用域"><a href="#附录A-动态作用域" class="headerlink" title="附录A 动态作用域"></a><div id="appendixA">附录A 动态作用域</div></h2><p>动态作用域和词法作用域的区别如下：</p><ul><li>词法作用域，关心函数是在何处声明以及如何声明。</li><li>词法作用域的定义过程发生在书写代码的阶段。</li><li>动态作用域，关心函数是如何调用的、从何处调用的。</li><li>动态作用域在运行时才被动态定义。</li></ul><p>书中通过举例，比较了动态作用域和静态作用域之间的区别。</p><p>动态作用域的代码调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log( a ); // 3(不是 2 !)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123; </span><br><span class="line">    var a = 3;</span><br><span class="line">    foo(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure></p><p>静态作用域的代码调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123; </span><br><span class="line">    console.log( a ); // 2</span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123; </span><br><span class="line">    var a = 3;</span><br><span class="line">    foo(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2; </span><br><span class="line">bar();</span><br></pre></td></tr></table></figure></p><h2 id="附录B-块作用域的替代方案"><a href="#附录B-块作用域的替代方案" class="headerlink" title="附录B 块作用域的替代方案"></a><div id="appendixB">附录B 块作用域的替代方案</div></h2><h3 id="B-1-Traceur"><a href="#B-1-Traceur" class="headerlink" title="B.1 Traceur"></a><div id="B.1">B.1 Traceur</div></h3><p>块作用域的替代方案：</p><ul><li>try catch。代码丑陋，但这是一种使不兼容es6的代码使用块作用域的一个手段。通常在代码中按照es6的块作用域方法去写，再由特定的工具（比如traceur）对块作用域转换为类似形式。</li></ul><h3 id="B-2-隐式和显式作用域"><a href="#B-2-隐式和显式作用域" class="headerlink" title="B.2 隐式和显式作用域"></a><div id="B.2">B.2 隐式和显式作用域</div></h3><p>在第三章曾经提到过：</p><blockquote><p>用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。在开发和修改代码的过 程中，如果没有密切关注哪些块作用域中有绑定的变量，并且习惯性地移动这些块或者将 其包含在其他的块中，就会导致代码变得混乱。</p></blockquote><p>显式作用域的好处：</p><ul><li>显式作用域，作用域更加突出，</li><li>显式作用域，在代码重构时表现得更加健壮。</li></ul><p>在第三章中提出的由隐式作用域变为显式作用域的解决方案是在隐式作用域的周围添加大括号。还有一种方案，通过let声明，也可以显式地表明一块作用域，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let (a = 2) &#123;</span><br><span class="line">    console.log( a ); // 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log( a ); // ReferenceError</span><br></pre></td></tr></table></figure></p><p>但是<strong>注意：let 声明并不包含在 ES6 中。</strong></p><p>使用es6语法的方案，方案一，仍然使用大括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*let*/ &#123; </span><br><span class="line">    let a = 2; </span><br><span class="line">    console.log( a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log( a ); // ReferenceError</span><br></pre></td></tr></table></figure></p><p>方案二，通过工具，把自己编写的let声明，转换为es6语法，即使用大括号围住显式作用域。</p><p>（感觉有点太麻烦了，还不如直接用隐式的作用域或者在不明显的地方用大括号。）</p><h3 id="B-3-性能"><a href="#B-3-性能" class="headerlink" title="B.3 性能"></a><div id="B.3">B.3 性能</div></h3><ul><li>try catch的性能很差。</li><li>什么时候使用块作用域？<ul><li>你是否想要块作用域?如果你想要，上述的内容可以帮助你。如果不想要，继续使用 var 来写代码就好了!</li></ul></li></ul><h3 id="附录C-this词法"><a href="#附录C-this词法" class="headerlink" title="附录C this词法"></a><div id="appendixC">附录C this词法</div></h3><ul><li>箭头函数不仅仅意味着少些代码。</li><li>不建议箭头函数和词法作用域混用。</li><li>建议在使用this的地方使用bind。（bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 from mdn）。</li></ul>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>科学上网</title>
      <link href="/2020/01/26/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
      <content type="html"><![CDATA[<p>记录博主科学上网的方法。「封面图来自：《飞行家》，2004，莱昂纳多主演」</p><a id="more"></a><ol><li><a href="#server">服务器</a></li><li><a href="#client">客户端</a></li><li><a href="#other">其他工具</a></li></ol><h3 id="1-服务器"><a href="#1-服务器" class="headerlink" title="1.服务器"></a><div id="server">1.服务器</div></h3><ul><li><a href="https://www.vultr.com/?ref=8556744" target="_blank" rel="noopener">服务器提供商</a>。</li><li><a href="https://github.com/233boy/v2ray" target="_blank" rel="noopener">服务器运行的程序</a>。</li></ul><h3 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2.客户端"></a><div id="client">2.客户端</div></h3><ul><li>小灰机<ul><li>windows：<a href="https://github.com/shadowsocks/shadowsocks-windows" target="_blank" rel="noopener">点我</a>（打开页面后，点击”中文说明”-&gt;下载”最新版”-&gt;assets里的链接。）</li><li>安卓：<a href="https://www.apkturbo.com/apps/shadowsocks/com.github.shadowsocks/4.8.7/" target="_blank" rel="noopener">下载链接点我</a>（如果安装失败可以尝试下载其他版本。也可通过<a href="https://www.apkturbo.com/搜索com.github.shadowsocks下载其他类似软件。）" target="_blank" rel="noopener">https://www.apkturbo.com/搜索com.github.shadowsocks下载其他类似软件。）</a></li><li>mac：SsrConnectPro（需要花几块钱购买）</li><li>ios：SsrConnectPro</li></ul></li><li>v2ray<ul><li>windows：<a href="https://github.com/2dust/v2rayN/releases" target="_blank" rel="noopener">GitHub仓库点我</a></li><li>安卓：<a href="https://github.com/2dust/v2rayNG" target="_blank" rel="noopener">GitHub仓库点我</a>，<a href="https://www.apkturbo.com/apps/v2rayng/com.v2ray.ang/1.0.0/" target="_blank" rel="noopener">下载链接点我</a></li><li>mac：<a href="https://github.com/Cenmrev/V2RayX" target="_blank" rel="noopener">GitHub仓库点我</a></li><li>ios：暂未找到…</li></ul></li></ul><h3 id="3-其他工具"><a href="#3-其他工具" class="headerlink" title="3.其他工具"></a><div id="other">3.其他工具</div></h3><h4 id="上网不科学，也能谷歌play"><a href="#上网不科学，也能谷歌play" class="headerlink" title="上网不科学，也能谷歌play"></a>上网不科学，也能谷歌play</h4><ul><li><a href="https://apps.evozi.com/apk-downloader/" target="_blank" rel="noopener">https://apps.evozi.com/apk-downloader/</a></li><li><a href="https://www.apkturbo.com/" target="_blank" rel="noopener">https://www.apkturbo.com/</a></li></ul><h4 id="Google-BBR算法-优化tcp链接速度"><a href="#Google-BBR算法-优化tcp链接速度" class="headerlink" title="Google BBR算法 优化tcp链接速度"></a>Google BBR算法 优化tcp链接速度</h4><ul><li>转自Mr_Bluyee,<a href="https://www.jianshu.com/p/98c21990ed23" target="_blank" rel="noopener">原文链接</a></li><li>Linux kernel 4.9 及以上已支持 tcp_bbr</li></ul><ol><li>查看系统内核版本<code>uname -r</code>看内核版本是否大于等于4.9，否则要升级内核，或者安装bbr。</li><li>开启BBR：<ol><li><code>echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</code></li><li><code>echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</code></li></ol></li><li>保存生效：<code>sysctl -p</code></li><li>检查BBR是否启用：<ul><li><code>sysctl net.ipv4.tcp_available_congestion_control</code>返回值一般为：net.ipv4.tcp_available_congestion_control = reno cubic bbr</li><li><code>sysctl net.ipv4.tcp_congestion_control</code>返回值一般为：net.ipv4.tcp_congestion_control = bbr</li><li><code>sysctl net.core.default_qdisc</code>返回值一般为：net.core.default_qdisc = fq</li><li><code>lsmod | grep bbr</code>返回值有 tcp_bbr 模块则BBR已启动：<code>tcp_bbr 20480 10</code></li></ul></li></ol>]]></content>
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vps </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>23种设计模式概览</title>
      <link href="/2019/12/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<p>23种设计模式，包括设计模式的UML图、定义、优缺点及java代码实现。</p><p>代码详见github：<a href="https://github.com/Michael-Zhang-Xian-Sen/design-pattern" target="_blank" rel="noopener">https://github.com/Michael-Zhang-Xian-Sen/design-pattern</a></p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol><li>创建型模式<ol><li>抽象工厂模式（Abstract Factory Pattern）</li><li>工厂方法模式（Factory Method Pattern）</li><li>简单工厂（Simple Factory Pattern）（注：不属于设计模式。）</li><li>原型模式（Prototype Pattern）</li><li>单例模式（Singleton Pattern）</li><li>建造者模式（Builder Pattern）（又名：生成器模式）</li></ol></li><li>行为型模式<ol><li>观察者模式（Observer Pattern）</li><li>模版方法模式（Template Pattern）</li><li>命令模式（Command Pattern）</li><li>状态模式（State Pattern）</li><li>职责链模式（Chain of Responsibility）</li><li>解释器模式（Interpreter Pattern）</li><li>中介者模式（Mediator Pattern）（又名：调停者模式）</li><li>访问者模式（Visitor Pattern）</li><li>策略模式（Strategy Pattern）</li><li>备忘录模式（Memento Pattern）</li><li>迭代器模式（Iterator Pattern）</li></ol></li><li>结构型模式<ol><li>适配器模式（Adapter Pattern）</li><li>桥接模式（Bridge Pattern）</li><li>组合模式（Composite Pattern）</li><li>装饰模式（Decorator Pattern）</li><li>外观模式（Facade Pattern）</li><li>享元模式（Flyweight Pattern）</li><li>代理模式（Proxy Pattern）</li></ol></li></ol><h2 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1. 创建型模式"></a>1. 创建型模式</h2><h3 id="1-1-抽象工厂模式"><a href="#1-1-抽象工厂模式" class="headerlink" title="1.1. 抽象工厂模式"></a>1.1. 抽象工厂模式</h3><h4 id="UML图："><a href="#UML图：" class="headerlink" title="UML图："></a>UML图：</h4><p><img src="http://cdn.ewinds.pw/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.jpg" alt="image"></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>抽象工厂模式（AbstractFactory）提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>抽象工厂的工厂最为强大。</li><li>易于交换产品系列。由于具体工厂类在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，只需改变具体工厂的内容便可改变不同的产品配置。符合里氏替换原则。</li><li>抽象工厂使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中。</li><li>该模式帮助我们针对抽象编程，而不是针对具体编程。</li><li>通过减少程序和具体类之间的依赖，促进松耦合。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>添加产品族很简单，只需要对每个接口添加一个类，符合开闭原则；但是添加产品比较麻烦，如果新添加了产品C，那么所有工厂都要添加产品C，违反了开闭原则。</p><h3 id="1-2-工厂方法模式"><a href="#1-2-工厂方法模式" class="headerlink" title="1.2. 工厂方法模式"></a>1.2. 工厂方法模式</h3><h4 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.jpg" alt="image"></p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。（即：工厂方法把简单工厂的逻辑判断移动到了客户端）</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>符合开闭原则。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>增加新的产品时，需要增加新的工厂类和产品类，会带来更大的开销。<br>抽象层的加入使得理解难度增大。</p><h3 id="1-3-简单工厂"><a href="#1-3-简单工厂" class="headerlink" title="1.3 简单工厂"></a>1.3 简单工厂</h3><h4 id="UML图-1"><a href="#UML图-1" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.jpg" alt="image"></p><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>将创建对象的代码进行封装。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>根据客户端的条件，动态实例化相关的类。对于客户端来说，去除了与具体产品的依赖。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>由于若要添加逻辑，需要修改工厂类，违背了开闭原则</li></ul><h3 id="1-4-原型模式"><a href="#1-4-原型模式" class="headerlink" title="1.4 原型模式"></a>1.4 原型模式</h3><h4 id="UML图-2"><a href="#UML图-2" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>用原型实例制定创建对象的种类，并且通过拷贝原型这些原型创建新的对象。<br>感觉重点就在于实现了clone方法。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>被复制的对象的所有变量都含有与原来对象相同的值。故所有的对其他对象的引用都仍然指向原来的对象。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>在浅拷贝的基础上，将引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。</p><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ol><li>向客户隐藏制造新实例的复杂性。</li><li>提供让客户能够产生未知类型对象的选项。</li><li>在某些环境下，复制对象比创建新对象更有效。</li></ol><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ol><li>对象的复制有时相当复杂。</li></ol><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol><li>在一个复杂的类层次中，当系统必须从其中的许多类型创建新对象时，可以考虑原型。</li></ol><h3 id="1-5-单例模式"><a href="#1-5-单例模式" class="headerlink" title="1.5 单例模式"></a>1.5 单例模式</h3><h4 id="UML图-3"><a href="#UML图-3" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul><li>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。</li></ul><h4 id="饿汉式单例类"><a href="#饿汉式单例类" class="headerlink" title="饿汉式单例类"></a>饿汉式单例类</h4><p>在类被加载时便将自己实例化。</p><h4 id="懒汉式单例类"><a href="#懒汉式单例类" class="headerlink" title="懒汉式单例类"></a>懒汉式单例类</h4><p>在第一次被引用时将自己实例化。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>多线程的单例，需要加锁，避免同时创建多个实例。</li></ul><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul><li>可以使用单例模式替换全局变量。</li></ul><h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><ul><li>单例模式引入了许多的其他问题，比如在创建单例对象的时候需要加锁。</li></ul><h3 id="1-6-建造者模式（生成器模式）"><a href="#1-6-建造者模式（生成器模式）" class="headerlink" title="1.6 建造者模式（生成器模式）"></a>1.6 建造者模式（生成器模式）</h3><h4 id="UML图-4"><a href="#UML图-4" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><ol><li>将一个复杂对象的创建过程封装起来</li><li>允许对象通过多个步骤来创建，并且可以改变过程。（这和只有一个步骤的工厂模式不同）</li><li>向客户隐藏产品内部的表现。</li><li>产品的实现可以被替换，因为客户只看到一个抽象的接口。</li></ol><h4 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h4><ol><li>与工厂模式相比，采用生成器模式创建对象需要具备更多的领域知识。</li></ol><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><ol><li>经常被用来创建组合结构。</li></ol><h2 id="2-行为型模式"><a href="#2-行为型模式" class="headerlink" title="2. 行为型模式"></a>2. 行为型模式</h2><h3 id="2-1-观察者模式（发布-订阅模式）"><a href="#2-1-观察者模式（发布-订阅模式）" class="headerlink" title="2.1. 观察者模式（发布-订阅模式）"></a>2.1. 观察者模式（发布-订阅模式）</h3><h4 id="UML图：-1"><a href="#UML图：-1" class="headerlink" title="UML图："></a>UML图：</h4><p><img src="http://cdn.ewinds.pw/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><h4 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h4><ol><li>让主题和观察者之间松耦合。它们之间依然可以交互，但是不太清楚彼此的细节，使互相的依赖降到了最低。</li></ol><h4 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h4><h3 id="2-2-模版方法模式"><a href="#2-2-模版方法模式" class="headerlink" title="2.2 模版方法模式"></a>2.2 模版方法模式</h3><h4 id="UML图-5"><a href="#UML图-5" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><p>（注：父类是抽象类）</p><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h4 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h4><p>模板方法模式通过把不变的行为搬移到超类，去除子类中的重复代码来体现它的优势。即当不变的行为和可变的行为在子类中混杂在一起的时候，不变的行为会在子类中重复出现，通过模板方法模式把这些行为搬移到父类或其他的地方，可以帮助子类摆脱重复的不变行为的纠缠。</p><h3 id="2-3-命令模式"><a href="#2-3-命令模式" class="headerlink" title="2.3 命令模式"></a>2.3 命令模式</h3><h4 id="UML图-6"><a href="#UML图-6" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h4><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p><h4 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h4><ol><li>能够容易地设计一个命令队列。</li><li>在需要的情况下，可以容易地将命令记入日志。</li><li>允许接受请求的一方决定是否要否决请求。</li><li>可以容易地实现对请求的撤销和重做。</li><li>由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。</li><li>把请求一个操作的对象与知道怎么执行一个操作的对象分割开。</li></ol><h3 id="2-4-状态模式"><a href="#2-4-状态模式" class="headerlink" title="2.4 状态模式"></a>2.4 状态模式</h3><h4 id="UML图-7"><a href="#UML图-7" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h4><p>当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了这个类。<br>主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况，把状态的判断逻辑转移到表示不同状态的一些列类当中，可以把复杂的判断逻辑简化。</p><h4 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h4><p>将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。</p><h3 id="2-5-职责链模式"><a href="#2-5-职责链模式" class="headerlink" title="2.5 职责链模式"></a>2.5 职责链模式</h3><h4 id="UML图-8"><a href="#UML图-8" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h4><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象可以处理它为止。</p><h4 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h4><p>经常被用在窗口系统中，处理鼠标和键盘之类的事件。</p><h4 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h4><ol><li>可以随时添加或修改处理一个请求的结构。增强了给对象指派职责的灵活性。</li><li>将请求的发送者和接收者解耦。（状态模式两个请求之间仍然存在耦合）</li><li>可以简化Client对象，因为Client对象不需要知道链的结构。</li><li>通过改变指责链内的成员或调动他们的次序，允许使用者动态地新增或删除责任。</li></ol><h4 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h4><p>并不能保证请求一定被执行。<br>不容易观察运行时的特征，有碍于debug。</p><h3 id="2-6-解释器模式"><a href="#2-6-解释器模式" class="headerlink" title="2.6 解释器模式"></a>2.6 解释器模式</h3><h4 id="UML图-9"><a href="#UML图-9" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h4><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>如果一种特定类型的问题发生频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p><h3 id="2-7-中介者模式（调停者模式）"><a href="#2-7-中介者模式（调停者模式）" class="headerlink" title="2.7 中介者模式（调停者模式）"></a>2.7 中介者模式（调停者模式）</h3><h4 id="UML图-10"><a href="#UML图-10" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h4><p>用一个中介对象来封装一系列的对象交互。中介者使各个对象之间不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><h3 id="2-8-访问者模式"><a href="#2-8-访问者模式" class="headerlink" title="2.8 访问者模式"></a>2.8 访问者模式</h3><h4 id="UML图-11"><a href="#UML图-11" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h4><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><h3 id="2-9-策略模式"><a href="#2-9-策略模式" class="headerlink" title="2.9 策略模式"></a>2.9 策略模式</h3><h4 id="UML图-12"><a href="#UML图-12" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h4><p>它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户。</p><h3 id="2-10-备忘录模式"><a href="#2-10-备忘录模式" class="headerlink" title="2.10 备忘录模式"></a>2.10 备忘录模式</h3><h4 id="UML图-13"><a href="#UML图-13" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-15"><a href="#定义-15" class="headerlink" title="定义"></a>定义</h4><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p><h3 id="2-11-迭代器模式"><a href="#2-11-迭代器模式" class="headerlink" title="2.11 迭代器模式"></a>2.11 迭代器模式</h3><h4 id="UML图-14"><a href="#UML图-14" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-16"><a href="#定义-16" class="headerlink" title="定义"></a>定义</h4><p>提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p><p>该模式已经被多种语言所实现为</p><h2 id="3-结构型模式"><a href="#3-结构型模式" class="headerlink" title="3. 结构型模式"></a>3. 结构型模式</h2><h3 id="3-1-适配器模式"><a href="#3-1-适配器模式" class="headerlink" title="3.1 适配器模式"></a>3.1 适配器模式</h3><h4 id="UML图-15"><a href="#UML图-15" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-17"><a href="#定义-17" class="headerlink" title="定义"></a>定义</h4><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><h4 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h4><h3 id="3-2-桥接模式"><a href="#3-2-桥接模式" class="headerlink" title="3.2 桥接模式"></a>3.2 桥接模式</h3><h4 id="UML图-16"><a href="#UML图-16" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-18"><a href="#定义-18" class="headerlink" title="定义"></a>定义</h4><p>Bridge，将抽象部分与它的实现部分分离，使他们都可以独立地变化。</p><ul><li>补充理解1：实现的方式有多种。桥接模式的核心意图就是把这些实现独立出来，让它们各自地变化。这就使得每种实现的变化不会影响其他实现，从而达到应对变化的目的。</li><li>补充理解2：实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。</li></ul><h3 id="3-3-组合模式"><a href="#3-3-组合模式" class="headerlink" title="3.3 组合模式"></a>3.3 组合模式</h3><h4 id="UML图-17"><a href="#UML图-17" class="headerlink" title="UML图"></a>UML图</h4><h5 id="透明模式"><a href="#透明模式" class="headerlink" title="透明模式"></a>透明模式</h5><p><img src="http://cdn.ewinds.pw/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%28%E9%80%8F%E6%98%8E%E6%A8%A1%E5%BC%8F%29.jpg" alt="image"></p><h5 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h5><p><img src="http://cdn.ewinds.pw/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%28%E5%AE%89%E5%85%A8%E6%96%B9%E5%BC%8F%29.jpg" alt="image"></p><h4 id="定义-19"><a href="#定义-19" class="headerlink" title="定义"></a>定义</h4><p>将对象组合成树形结构，以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><ul><li>透明方式：Componet中声明所有用来管理子对象的方法。</li><li>安全方式：Componet接口中不声明管理子对象的方法，而是在Composite中声明所有用来管理子对象的方法。</li></ul><h3 id="3-4-装饰模式"><a href="#3-4-装饰模式" class="headerlink" title="3.4 装饰模式"></a>3.4 装饰模式</h3><h4 id="UML图-18"><a href="#UML图-18" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-20"><a href="#定义-20" class="headerlink" title="定义"></a>定义</h4><p>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p><h3 id="3-5-外观模式"><a href="#3-5-外观模式" class="headerlink" title="3.5 外观模式"></a>3.5 外观模式</h3><h4 id="UML图-19"><a href="#UML图-19" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-21"><a href="#定义-21" class="headerlink" title="定义"></a>定义</h4><ul><li>外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li></ul><h4 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h4><ul><li>符合迪米特法则</li><li>符合依赖倒置原则</li></ul><h3 id="3-6-享元模式"><a href="#3-6-享元模式" class="headerlink" title="3.6 享元模式"></a>3.6 享元模式</h3><h4 id="UML图-20"><a href="#UML图-20" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-22"><a href="#定义-22" class="headerlink" title="定义"></a>定义</h4><ul><li>Flyweight，运用共享技术有效地支持大量细粒度的对象。</li><li>享元对象的内部状态：不会随环境改变而改变的共享部分。</li><li>享元对象的外部状态：随环境改变而改变的、不可以共享的状态。 </li></ul><h4 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h4><p>节约存储空间。</p><h4 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h4><p>需要将部分状态外部化，使得逻辑更为复杂，</p><h3 id="3-7-代理模式"><a href="#3-7-代理模式" class="headerlink" title="3.7 代理模式"></a>3.7 代理模式</h3><h4 id="UML图-21"><a href="#UML图-21" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-23"><a href="#定义-23" class="headerlink" title="定义"></a>定义</h4><p>为其他对象提供一种代理以控制这个对象的访问。</p><h4 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h4><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>远程代理</li><li>虚拟代理</li><li>安全代理</li></ul>]]></content>
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《白日梦》 北岛</title>
      <link href="/2018/04/23/%E8%AF%97/daydream/"/>
      <content type="html"><![CDATA[<p>封面图来自：爆裂鼓手</p><a id="more"></a><hr><h2 id="《白日梦》"><a href="#《白日梦》" class="headerlink" title="《白日梦》"></a><center>《白日梦》</center></h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>在秋天的暴行之后<br>这十一月被冰霜麻醉<br>展平在墙上<br>影子重重叠叠<br>那是骨骼石化的过程<br>你没有如期归来<br>我喉咙里的果核<br>变成了温暖的石头</p><p>我，行迹可疑<br>新的季节的阅兵式<br>敲打我的窗户<br>住在钟里的人们<br>带着摆动的心脏奔走<br>我俯视时间<br>不必转身<br>一年的黑暗在杯中</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>音乐释放的蓝色灵魂<br>在烟蒂上飘摇<br>出入门窗的裂缝</p><p>一个准备切开的苹果<br>–那里没有核儿<br>没有生长敌意的种子<br>远离太阳的磁场<br>玻璃房子里生长的头发<br>如海藻，避开真实的</p><p>风暴，我们是<br>迷失在航空港里的儿童<br>总想大哭一场</p><p>在宽银幕般的骚动中<br>收集烟尘的鼻子<br>碰到一起<br>说个不停，这是我<br>是我<br>我，我们</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>喃喃梦呓的<br>书，排列在一起<br>在早晨三点钟<br>等待异端的火箭</p><p>时间并不忧郁<br>我们弃绝了山林湖泊<br>集中在一起<br>为什么我们在一起<br>一只铁皮乌鸦<br>在大理石的底座下<br>那永恒的事物的焊接处<br>不会断裂</p><p>人们从石棺里醒来<br>和我坐在一起<br>我们生前与时代合影<br>挂在长桌尽头</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>你没有如期归来<br>而这正是离别的意义<br>一次爱的旅行<br>有时候就象抽烟那样<br>简单</p><p>地下室空守着你<br>内心的白银<br>水仙花在暗中灿然开放<br>你听凭所有的坏天气<br>发怒、哭喊<br>乞求你打开窗户</p><p>书页翻开<br>所有的文字四散<br>只留下一个数字<br>–我的座位号码<br>靠近窗户<br>本次列车的终点是你</p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>向日葵的帽子不翼而飞<br>石头圆滑、可靠<br>保持着本质的完整<br>在没有人居住的地方<br>山也变得年轻<br>晚钟不必解释什么<br>巨蟒在蜕皮中进化<br>–绳索打结<br>把鱼群悬挂在高处<br>一潭死水召来无数闪电<br>虎豹的斑纹渐成蓝色<br>天空已被吞噬</p><p>历史静默<br>峭壁目送着河上<br>那自源头漂流而下的孩子<br>这人类的孩子</p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>我需要广场<br>一片空旷的广场<br>放置一个碗，一把小匙<br>一只风筝孤单的影子</p><p>占据广场的人说<br>这不可能</p><p>笼中的鸟需要散步<br>梦游者需要贫血的阳光<br>道路撞击在一起<br>需要平等的对话</p><p>人的冲动压缩成<br>铀，存放在可靠的地方</p><p>在一家小店铺<br>一张纸币，一片剃刀<br>一包剧毒的杀虫剂<br>诞生了</p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>我死的那年十岁<br>那抛向空中的球再也没<br>落到地上<br>你是唯一的目击者<br>十岁，我知道<br>然后我登上<br>那辆运载野牛的火车<br>被列入过期的提货单里<br>供人们阅读</p><p>今天早上<br>一只鸟穿透我打开的报纸<br>你的脸嵌在其中<br>一种持久的热情<br>仍在你的眼睛深处闪烁<br>我将永远处于<br>你所设计的阴影中</p><h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>多少年<br>多少火种的逃亡者<br>使日月无光<br>白马展开了长长的绷带<br>木桩钉进了煤层<br>渗出殷红的血<br>毒蜘蛛弹拨它的琴弦<br>从天而降<br>开阔地，火球滚来滚去</p><p>多少年<br>多少河流干涸<br>露出那隐秘的部分<br>这是座空荡荡的博物馆<br>谁置身其中<br>谁就会自以为是展品<br>被无形的目光注视<br>如同一颗湖泊爆炸后<br>飞出的沉睡千年的小虫</p><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p>终于有一天<br>谎言般无畏的人们<br>从巨型收音机里走出来<br>赞美着灾难<br>医生举起白色的床单<br>站在病树上疾呼：<br>是自由，没有免疫的自由<br>毒害了你们</p><h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><p>手在喘息<br>流苏是呻吟<br>雕花的窗棂互相交错<br>纸灯笼穿过游廊<br>在尽头熄灭<br>一支箭敲响了大门</p><p>牌位接连倒下<br>–连锁反应的恶梦<br>子孙们<br>是威严的石狮嘴里<br>腐烂的牙齿</p><p>当年锁住春光的庭院<br>只剩下一棵树<br>他们在酒后失态<br>围着树跳舞<br>疯狂是一种例外</p><h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><p>别把你的情欲带入秋天<br>这残废者的秋天<br>打着响亮呼哨的秋天</p><p>一只女人干燥的手<br>掠过海面，却滴水未沾<br>推移礁石的晚霞<br>是你的情欲<br>焚烧我</p><p>我，心如枯井<br>对海洋的渴望使我远离海洋<br>走向我的开端–你<br>或你的尽头–我</p><p>我们终将迷失在大雾中<br>互相呼唤<br>在不同的地点<br>成为无用的路标</p><h3 id="12"><a href="#12" class="headerlink" title="12"></a>12</h3><p>白色的长袍飘向那<br>不存在的地方<br>心如夏夜里抽搐的水泵<br>无端地发泄<br>黄昏的晚宴结束了<br>山峦散去<br>蜉蝣在水上写诗<br>地平线的颂歌时断时续<br>影子并非一个人的历史<br>戴上或摘下面具<br>花朵应运而生<br>谎言与悲哀不可分离<br>如果没有面具<br>所有钟表还有什么意义</p><p>当灵魂在岩石是显出原形<br>只有鸟会认出它们</p><h3 id="13"><a href="#13" class="headerlink" title="13"></a>13</h3><p>他指银色的沼泽说<br>那里发生过战争<br>几棵冒烟的树在地平线飞奔<br>转入地下的士兵和马<br>闪着磷光，日夜<br>追随着将军的铠甲</p><p>而我们追随的是<br>思想的流弹中<br>那逃窜的自由的兽皮</p><p>昔日阵亡者的头颅<br>如残月升起<br>越过沙沙作响的灌木丛<br>以预言家的口吻说<br>你们并非幸存者<br>你们永无归宿</p><p>新的思想呼啸而过<br>击中时代的背影<br>一滴苍蝇的血让我震惊</p><h3 id="14"><a href="#14" class="headerlink" title="14"></a>14</h3><p>我注定要坐在岸边<br>在一张白纸上<br>期待着老年斑纹似的词</p><p>出现，秩序与混乱<br>蜂房酿造着不同的情欲<br>九十九座红色的山峰</p><p>上涨，空气稀薄<br>地衣居心叵测地蔓延<br>渺小，如尘世的</p><p>计谋，钢筋支撑着权利<br>石头也会晕眩<br>这毕竟是一种可怕的</p><p>高度，白纸背面<br>孩子的手在玩影子游戏<br>光源来自海底两条交尾的<br>电鳗</p><h3 id="15"><a href="#15" class="headerlink" title="15"></a>15</h3><p>蹲伏在瓦罐的夜<br>溢出清凉的<br>水，那是我们爱的源泉</p><p>回忆如伤疤<br>我的一生在你的脚下<br>这流动的沙丘<br>凝聚在你的手上<br>成为一颗眩目的钻石</p><p>没有床，房间<br>小得使我们无法分离<br>四壁薄如棉纸<br>数不清的嘴巴画在墙上<br>低声轮唱</p><p>你没有如期归来<br>我们共同啜饮的杯子<br>砰然碎裂</p><h3 id="16"><a href="#16" class="headerlink" title="16"></a>16</h3><p>矿山废弃已久<br>它的金属拉成细长的线</p><p>猫头鹰通体透明<br>胃和神经丛掠过夜空</p><p>古生物的联盟解体了<br>粘合化石的工作</p><p>仍在进行，生存<br>永远是一种集体冒险</p><p>生存永远是和春天<br>在进行战争</p><p>绿色的履带碾过<br>阴郁的文明</p><p>喷射那水银的喷泉<br>金属的头改变了地貌</p><h3 id="17"><a href="#17" class="headerlink" title="17"></a>17</h3><p>几个世纪过去了<br>一日尚未开始<br>冷空气触摸了我的手<br>螺旋楼梯般上升<br>黑与白，光线<br>在房瓦的音阶上转换<br>一棵枣树的安宁<br>男人的喉咙成熟了</p><p>动物园的困兽<br>被合进一本书<br>钢鞭飞舞<br>悸动着的斑斓色彩<br>隔着漫长的岁月<br>凄厉地叫喊<br>一张导游图把我引入<br>城中之星星狡黠而凶狠<br>象某一事物的核心</p><h3 id="18"><a href="#18" class="headerlink" title="18"></a>18</h3><p>我总是沿着那条街的<br>孤独的意志漫步<br>喔，我的城市<br>在玻璃的坚冰上滑行</p><p>我的城市我的故事<br>我的水龙头我积怨<br>我的鹦鹉我的<br>保持平衡的睡眠</p><p>罂粟花般芳香的少女<br>从超级市场飘过<br>带着折刀般表情的人们<br>共饮冬日的寒光</p><p>诗，就象阳台一样<br>无情地折磨着我<br>被烟尘粉刷的墙<br>总在意料之中</p><h3 id="19"><a href="#19" class="headerlink" title="19"></a>19</h3><p>当你转身的时候<br>花岗石崩裂成细细的流沙<br>你用陌生的语调<br>对空旷说话，不真实<br>如同你的笑容</p><p>深深植入昨天的苦根<br>是最黑暗处的闪电<br>击中了我们想象的巢穴<br>从流沙的瀑布中<br>我们听见了水晶撞击的音乐</p><p>一次小小的外科手术<br>我们挖掘燧石的雪地上<br>留下了麻雀的爪印<br>一辆冬天疯狂的马车<br>穿过夏日的火焰</p><p>我们安然无恙<br>四季的美景印在你的衣服上</p><h3 id="20"><a href="#20" class="headerlink" title="20"></a>20</h3><p>放牧是一种观点的陈述<br>热病使羊群膨胀<br>象一个个气球上升<br>卡在天蝎星座中<br>热风卷走了我的屋顶<br>在四壁之内<br>我静观无字的天空<br>文化是一种共生现象<br>包括羊的价值<br>狼的原则<br>钟罩里一无所有<br>在我们的视野里<br>只有一条干涸的河道<br>几缕笔直的烟<br>古代圣贤们<br>无限寂寞<br>垂钓着他们的鱼</p><h3 id="21"><a href="#21" class="headerlink" title="21"></a>21</h3><p>诡秘的豆荚有五只眼睛<br>它们不愿看见白昼<br>只在黑暗里倾听</p><p>一种颜色是一个孩子<br>诞生时的啼哭</p><p>宴会上桌布洁白<br>杯中有死亡的味道<br>–悼词库挥发的沉闷气息</p><p>传统是一张航空照片<br>山河缩小成桦木的纹理</p><p>总是人，俯首听命于<br>说教、仿效、争斗<br>和他们的尊严</p><p>寻找激情的旅行者<br>穿过候鸟荒凉的栖息地</p><p>石膏像打开窗户<br>艺术家从背后<br>用工具狠狠地敲碎它们</p><h3 id="22"><a href="#22" class="headerlink" title="22"></a>22</h3><p>弱音器弄哑了的小号<br>忽然响亮地哭喊<br>那伟大悲剧的导演<br>正悄悄地死去<br>两只装着滑轮的狮子<br>仍在固定的轨道上<br>东奔西撞</p><p>曙光瘫痪在大街上<br>很多地址和名字和心事<br>在邮筒在夜里避雨<br>货车场的鸭子喧哗<br>窗户打着哈欠<br>一个来苏水味的早晨<br>值班医生正填写着死亡报告</p><p>悲剧的伟大意义呵<br>日常生活的琐碎细节</p><h3 id="23"><a href="#23" class="headerlink" title="23"></a>23</h3><p>在昼与夜之间出现了裂缝</p><p>语言突然变得陈旧<br>象第一场雪<br>那些用黑布蒙面的证人<br>紧紧包围了你<br>你把一根根松枝插在地上<br>默默点燃它们</p><p>那是一种祭奠的仪式<br>从死亡的山冈上<br>我居高临下<br>你是谁<br>要和我交换什么<br>白鹤展开一张飘动的纸<br>上面写着你的回答<br>而我一无所知</p><p>你没有如期归来</p>]]></content>
      
      <categories>
          
          <category> 现代诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sql语法：UNION子句</title>
      <link href="/2017/10/27/sql/sql%E8%AF%AD%E6%B3%95%EF%BC%9Aunion%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <content type="html"><![CDATA[<p>如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。union(或称为联合)的作用是将多个结果合并在一起显示出来。</p><p>union和union all的区别是,union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。</p><h2 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h2><p>对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序。union在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。</p><h2 id="UNION-ALL"><a href="#UNION-ALL" class="headerlink" title="UNION ALL"></a>UNION ALL</h2><p>对两个结果集进行并集操作，包括重复行，不进行排序；如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。</p>]]></content>
      
      <categories>
          
          <category> sql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sql语法：JOIN子句</title>
      <link href="/2017/10/27/sql/sql%E8%AF%AD%E6%B3%95%EF%BC%9AJOIN%E5%AD%90%E5%8F%A5/"/>
      <content type="html"><![CDATA[<ul><li>内连接： <ol><li>inner join(即join)</li></ol></li><li>外连接：<ol><li>left join</li><li>right join</li><li>full join</li></ol></li></ul><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><h3 id="1-innerJoin"><a href="#1-innerJoin" class="headerlink" title="1. innerJoin"></a>1. innerJoin</h3><p>只连接匹配行。</p><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><h3 id="1-left-join"><a href="#1-left-join" class="headerlink" title="1. left join"></a>1. left join</h3><p>返回左表的全部行和右表的满足on条件的行。如果左表的行在右表中没有匹配，那么这一行右表中对应数据用NULL代替。</p><h3 id="2-right-join"><a href="#2-right-join" class="headerlink" title="2. right join"></a>2. right join</h3><p>返回右表的全部行和左边满足ON条件的行。如果右表的行在左表中没有匹配，那么这一行左表中对应数据用NULL代替。</p><h3 id="3-full-join"><a href="#3-full-join" class="headerlink" title="3. full join"></a>3. full join</h3><p>从左表和右表返回所有的行。如果其中一个表的数据行在另一个表中没有匹配的行，则对面的数据用NULL代替。</p>]]></content>
      
      <categories>
          
          <category> sql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim中文乱码的解决方案</title>
      <link href="/2017/10/24/vim/vim%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <content type="html"><![CDATA[<p>「封面图：VIM图标」</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>出现上述现象是编码出了问题。</p><ol><li>执行<code>sudo vim ~/.vimrc</code></li><li><p>输入</p><p> set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936<br> set termencoding=utf-8<br> set encoding=utf-8</p></li></ol><h2 id="成功解决乱码。"><a href="#成功解决乱码。" class="headerlink" title="成功解决乱码。"></a>成功解决乱码。</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="为什么要改变vimrc文件"><a href="#为什么要改变vimrc文件" class="headerlink" title="为什么要改变vimrc文件"></a>为什么要改变vimrc文件</h4><p><code>vimrc</code>文件用于初始化vim。使用vim时，vim会到指定目录下寻找vimrc并用其进行初始化。更多的内容见<code>:help vimrc</code>，通过<code>version</code>，可以看到vim规定的vimrc文件路径。例如我的：</p><pre><code>system vimrc file: &quot;$VIM/vimrc&quot;user vimrc file: &quot;$HOME/.vimrc&quot;2nd user vimrc file: &quot;~/.vim/vimrc&quot;user exrc file: &quot;$HOME/.exrc&quot;fall-back for $VIM: &quot;/usr/share/vim&quot;</code></pre><h4 id="编辑内容的含义是什么？"><a href="#编辑内容的含义是什么？" class="headerlink" title="编辑内容的含义是什么？"></a>编辑内容的含义是什么？</h4><p>（1） 磁盘文件的字符编码<br>存放在磁盘上的文本文件，是按照一定的字符编码进行保存的，不同的文件可能使用了不同的字符编码。<br>这在VIM中被叫做：fileencoding。</p><p>（2） VIM缓冲区以及界面的字符编码<br>VIM运行时，其菜单、标签、以及各个缓冲区统一使用一种字符编码方式。<br>这在VIM中被叫做：encoding。</p><p>（3) 终端使用的字符编码<br>终端同一时刻只能使用一种字符编码，并按照这种编码从接收到的字节流中识别字符，并显示，终端的字符编码是可以动态调整的。<br>这在VIM中被叫做：termencoding。</p><p>可以看出，VIM涉及到的3种字符编码之间的转换：<br>读：fileencoding—–&gt; encoding<br>显：encoding ——&gt; termencoding<br>写：encoding ——-&gt; fileencoding</p><h4 id="那些字符编码"><a href="#那些字符编码" class="headerlink" title="那些字符编码"></a>那些字符编码</h4><p>UTF-8（8-bit Unicode Transformation Format）：是一种针对Unicode的可变长度字符编码，又称万国码。 支持中文。</p><p>UCS（通用字符集）：包含了用于表达所有已知语言的字符，保证了与其他字符集的双向兼容， 是所有其他字符集标准的一个超集。支持中文。Unicode规范中推荐的标记字节顺序的方法是BOM。BOM是Byte Order Mark。在UCS编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。</p><p>gb18030、gbk、gb2312肯定是支持中文的编码。</p><p>CP936其实就是GBK，IBM在发明Code Page的时候将GBK放在第936页，所以叫CP936。</p><p>参考资料： <a href="http://blog.csdn.net/smstong/article/details/51279810" target="_blank" rel="noopener">http://blog.csdn.net/smstong/article/details/51279810</a><br>参考资料： <a href="http://www.fmddlmyy.cn/text6.html" target="_blank" rel="noopener">http://www.fmddlmyy.cn/text6.html</a><br>参考资料： <a href="https://www.zhihu.com/question/35609295" target="_blank" rel="noopener">https://www.zhihu.com/question/35609295</a></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决代码换行导致元素间出现空格间距的一些方案</title>
      <link href="/2017/10/14/css%E5%9F%BA%E7%A1%80/%E6%8D%A2%E8%A1%8C%E9%80%A0%E6%88%90%E7%A9%BA%E6%A0%BC%E9%97%B4%E8%B7%9D%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <content type="html"><![CDATA[<p>最近在写东西的时候总是碰见一些莫名奇妙的bug。</p><a id="more"></a><p>在使用<code>display:inline-block</code>属性时经常会两个元素之间莫名奇妙出现空白。</p><p>空白是因代码中的换行产生的，以下是解决方案。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>使用margin移动至合适位置</li><li>代码不进行换行</li><li>设置任意父级块的字体大小为0</li><li>视情况改为浮动布局</li><li><p>将两个标签中间的空白部分进行注释</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> /&gt;</span><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   --&gt;</span><span class="tag">&lt;<span class="name">input</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>将闭合标签<code>&gt;</code>放到下一个标签的开始处</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">   /&gt;</span><span class="tag">&lt;<span class="name">input</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>标准盒模型和怪异盒模型</title>
      <link href="/2017/08/07/css%E5%9F%BA%E7%A1%80/%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%80%AA%E5%BC%82%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
      <content type="html"><![CDATA[<h3 id="标准盒子模型"><a href="#标准盒子模型" class="headerlink" title="标准盒子模型"></a>标准盒子模型</h3><p>即<code>box-sizing:content-box</code>;<br>dom的width：content的width。<br>DOM元素显示时占据的总宽度 = margin + padding + border + content<br>chrome、ff的浏览器默认样式即为标准盒子模型。</p><h3 id="IE盒子模型"><a href="#IE盒子模型" class="headerlink" title="IE盒子模型"></a>IE盒子模型</h3><p>即<code>box-sizing:border-box;</code><br>dom的width：content的width+padding+border<br>元素的总宽度 = width + margin<br>ie浏览器默认的浏览器默认样式即为IE盒子模型。<br>此时content的宽高只能通过调整width、padding、border来设置。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「写给大家看的设计书」</title>
      <link href="/2017/08/07/%E8%AE%BE%E8%AE%A1/%E3%80%8C%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E3%80%8D/"/>
      <content type="html"><![CDATA[<p>不懂设计的前端不是一个好前端 =。=！</p><a id="more"></a><h2 id="笔记部分"><a href="#笔记部分" class="headerlink" title="笔记部分"></a>笔记部分</h2><h3 id="PART1：「设计原则」"><a href="#PART1：「设计原则」" class="headerlink" title="PART1：「设计原则」"></a>PART1：「设计原则」</h3><h4 id="第一章：「引言」"><a href="#第一章：「引言」" class="headerlink" title="第一章：「引言」"></a>第一章：「引言」</h4><p>通过<strong>约书亚树</strong>作为引言。</p><p>作者试图用关于这棵树的小故事说明一个道理：如果能说出一个物品的名称，那么在日常生活中你就会经常注意到它。<strong>掌握它，拥有它，让它受你所控</strong>。</p><p>类比于学习，差不多的道理。可能效果没那么明显，因为对于一些名词，你没有理解它原理性内容，见到次数再多也不会拥有它。但知道它的名称，总归是揭下它神秘面纱的第一步。</p><ul><li>4大基本原则<ol><li>对比</li><li>重复</li><li>对齐</li><li>亲密性</li></ol></li></ul><h4 id="第二章：「亲密性」"><a href="#第二章：「亲密性」" class="headerlink" title="第二章：「亲密性」"></a>第二章：「亲密性」</h4><ul><li>物理位置的接近就意味着存在关联。</li><li>把相关的元素分在一组，使他们建立更近的亲密性。</li><li>亲密性的根本目的是实现组织性。</li></ul><h4 id="第三章：「对齐」"><a href="#第三章：「对齐」" class="headerlink" title="第三章：「对齐」"></a>第三章：「对齐」</h4><ul><li>任何元素都不能在页面上随意安放。每一项都应当与页面上的某个内容存在某种视觉联系。</li><li>采用同一种对齐方式的元素会产生一种「边界强度」，其为布局提供力度。</li><li>勇敢一些，不要畏缩！</li><li>一个页面只使用一种对齐方式。</li><li>可以有意为之打破边界，如将插图斜着插入边界，只要效果比原来更好。不必过于拘束。勇敢一些，不要畏缩！</li><li>在打破规则前必须清楚规则是什么。</li><li>对齐也会使元素之间产生视觉联系。</li><li>对齐的根本目的是使页面统一而且由条理。</li></ul><h4 id="第四章：「重复」"><a href="#第四章：「重复」" class="headerlink" title="第四章：「重复」"></a>第四章：「重复」</h4><ul><li>设计的某些方面需要在整个作品中重复。</li><li>在一系列作品中尤其需要注意重复。</li><li>重复的目的就是统一， 并增强视觉效果。</li></ul><h4 id="第五章：「对比」"><a href="#第五章：「对比」" class="headerlink" title="第五章：「对比」"></a>第五章：「对比」</h4><ul><li>页面的元素之间要有对比效果，达到吸引读者的对比效果。</li><li>对比的根本目的有两个。一个目的是增强页面的效果，如果一个页面看起来很有意思，往往更有可读性。另一个目的是有助于信息的组织。</li></ul><h4 id="第六章：「4大基本原则复习」"><a href="#第六章：「4大基本原则复习」" class="headerlink" title="第六章：「4大基本原则复习」"></a>第六章：「4大基本原则复习」</h4><ul><li><strong>不要畏畏缩缩！</strong></li></ul><h4 id="第七章：「颜色运用」"><a href="#第七章：「颜色运用」" class="headerlink" title="第七章：「颜色运用」"></a>第七章：「颜色运用」</h4><ul><li>色轮<ul><li>三原色(tricolor):红黄蓝，色轮的基础。这三种颜色无法创建。</li><li><img src="http://opqksc9nz.bkt.clouddn.com/%E4%B8%89%E5%8E%9F%E8%89%B2.jpg" alt="三原色"></li><li>三间色(secondary color):将三原色色轮上相邻颜色<strong>等量</strong>混合，形成三间色。分别为橙、绿、紫色。</li><li><img src="http://opqksc9nz.bkt.clouddn.com/%E4%B8%89%E9%97%B4%E8%89%B2.jpg" alt="三间色"></li><li>第三色(tertiary colour):再将空白两边的颜色按<strong>等量</strong>混合，形成第三色。</li><li><img src="http://opqksc9nz.bkt.clouddn.com/%E7%AC%AC%E4%B8%89%E8%89%B2.jpg" alt="第三色"></li><li>「互补色」:色轮上相对(完全对立)的颜色。通常一种作为主色，另一种用来强调。</li><li>「三色组」:色轮上彼此等距的三种颜色形成的让人愉悦的三色组。<ul><li>「基色三色组」:红黄蓝。</li><li>「间色三色组」：绿橙紫</li><li>还有两组，作者没有细分，不作累述。</li></ul></li><li>「分裂互补三色组」:从色轮的一遍选择一种颜色，再从色轮上找到其对面的互补色两侧的颜色。具有更细致的颜色边界。</li><li>「类似色」:由色轮上彼此相邻的颜色构成。</li></ul></li><li>暗色和亮色<ul><li>基本色轮只涉及纯「色调」，即纯色。还可向其添加黑色或者白色，对色轮进行扩展。</li><li>纯色就是色调。</li><li>向色调增加黑色就构成一个暗色。</li><li>向色调增加一个白色构成一个亮色。</li><li>「单色组合」:由一种色调及其相应的多种亮色和暗色组成。</li><li>「暗色组合」:由暗色和亮色进行组合，不使用色调。</li></ul></li><li>注意色质<ul><li>「色质」:某种颜色的特定明暗度、深浅度或色调。</li><li>颜色组合导致视觉抖动:色质过于接近。</li><li><strong>避免让类似色质的色调挨在一起！</strong></li></ul></li><li>暖色与冷色<ul><li>「暖色」:其中包含红色或黄色。通过对颜色加此种颜色可以对颜色”加热”。</li><li>「冷色」:其中包含蓝色。通过对颜色加此种颜色可以对颜色”降温”</li><li>冷色趋于做背景色，为后退型。</li><li>暖色为趋进型。</li><li>在冷色和暖色的搭配中，少用暖色。</li></ul></li><li>两种颜色模型<ul><li>「CMYK」:Cyan(一种蓝色)、Magenta(一种红、粉红色)、Yellow(黄色)、Key(黑色)。<ul><li>「四色处理」:这四种颜色可以打印出成千上万种颜色。</li></ul></li><li>「RGB」:Red(红色)、Green(绿色)、Blue(蓝色)<ul><li>红色混合绿色可以产生黄色。</li><li>red、yellow、blue为颜料三原色。rgb为光学三原色。</li></ul></li><li><strong>需要印刷的项目应当使用CMYK</strong></li><li><strong>需要在屏幕上看到的内容则应使用RGB</strong></li></ul></li></ul><h4 id="第八章：「创建包装或品牌」"><a href="#第八章：「创建包装或品牌」" class="headerlink" title="第八章：「创建包装或品牌」"></a>第八章：「创建包装或品牌」</h4><ul><li>创建包装或品牌<ul><li>必须有某个标识性图像或某种标识性风格。</li></ul></li><li>企业名片</li><li>信笺和信封</li><li>传单</li><li>新闻简报</li><li>宣传册</li><li>明信片</li><li>报纸广告</li><li>简历</li></ul><h3 id="PART2：「字体设计」"><a href="#PART2：「字体设计」" class="headerlink" title="PART2：「字体设计」"></a>PART2：「字体设计」</h3><h4 id="第九章：「字体的基本规则」"><a href="#第九章：「字体的基本规则」" class="headerlink" title="第九章：「字体的基本规则」"></a>第九章：「字体的基本规则」</h4><ul><li>关于英语:标点后面加一个空格。作者是以英文做的示例， 不知道对中文是否适用。 好像不是很适用。 看上去总觉得怪怪的。</li><li>引号<ul><li>印刷引号:“66和99”</li><li>打字机引号:”竖杠引号”</li><li>问号和感叹号如果属于引用的一部分就出现在引号内。</li><li>问号和感叹号如果不属于引用的一部分就出现在引号外。</li></ul></li><li>撇号<ul><li>使用印刷撇号！！！’’’</li><li>省略字母：除了所属性词语之外，撇号意味着省略一个字母如：isn’t Rock’n’Roll，注意是99不是69！</li><li>撇号是9！</li></ul></li><li>连接号<ul><li>连字符<ul><li>odd-looking-critters</li><li>在转行时放在单词的前半部之后，用于断词。</li></ul></li><li>一字线<ul><li>「如何输入」:中文的破折号由两个一字线组成，所以其为破折号的一半，在中文打字法，输入中文的模式下，按下shift+0旁边的键(即连字符)，再删除一次横线，剩下的即为一字线。</li><li>一字线意味着一个持续事件，也可用to代替，前后无空格。例如：7:30—9:30pm</li><li>「宽度」:类似大写字母N的宽度</li></ul></li><li>破折号<ul><li>表示思想的突然变化。</li><li>「宽度」:即中文的破折号，一字线的两倍。</li><li>表意强度:句号&gt;破折号&gt;逗号</li><li>两侧无空格。</li></ul></li></ul></li><li>特殊符号<ul><li>PC上的特殊符号<ul><li>ANSI编码:alt+数字键</li><li>重音符号:alt+数字键</li></ul></li><li>MAC上的特殊符号<ul><li>shift/option+字符</li></ul></li></ul></li><li>大写字母<ul><li>全部大写比全部小写难以阅读，因为大写字母没有轮廓形状变化。</li></ul></li><li>下划线<ul><li>永远不要使用。</li><li>代替：<strong>粗体字</strong>、大号字、不同的字体、颜色。</li></ul></li><li>字距调整<ul><li>「字距调整」:挪动字符间距.</li><li>通常值针对与英语，因为字符键可能存在较大缝隙。</li></ul></li><li>寡妇和孤儿<ul><li>「寡妇」:一段文字的最后一行字符数少于7个。</li><li>「孤儿」:一段的最后一行由于太长而和其他文字分开，在下一栏或下一页的最上面结束。</li></ul></li><li>其他<ul><li>跟随在有样式的文字后的标点与文字样式一样。</li><li>括号中的标点<ul><li>如果括号中的文字是整个句子的一部分，标点在闭括号外。</li><li>括号内的文字是一个完整的句子，标点在括号内。</li></ul></li><li>段落缩进或段落进空行：二者只可选其一。因为都代表“下文为新的一段”的意思。</li><li>首段:不一定需要缩进。</li><li>方框内的文字:尽量在放扩四周留够空间，不要太挤。</li><li>在列表中使用项目符号或装饰符号，而不是连字符。</li></ul></li></ul><h4 id="第十章：「字体（与人生）」"><a href="#第十章：「字体（与人生）」" class="headerlink" title="第十章：「字体（与人生）」"></a>第十章：「字体（与人生）」</h4><ul><li>协调与冲突<ul><li>「协调」:只使用一个字体系列，样式、大小、字体粗细无变化。</li><li>「冲突」:结合使用多个字体系列，很类似但并不相同。</li><li>「对比」:结合的多种字体和元素彼此之间并不相同。</li><li>协调是一个稳妥有用的概念，但冲突务必要避免。</li><li>字体对比存在6种明确的不同方式:大小、粗细、结构、形状、方向和颜色。</li></ul></li></ul><h4 id="第十一章：「字体类别」"><a href="#第十一章：「字体类别」" class="headerlink" title="第十一章：「字体类别」"></a>第十一章：「字体类别」</h4><ul><li>「OldStyle」 旧式体<ul><li>都有衬线，且小写字母衬线存在角度。</li><li>「粗细过渡」:曲线笔画存在一种从粗到细的变化。</li><li>「适合阅读」</li><li>「对角强调线」:曲线最细部分的一条线。 </li></ul></li><li>「Modern」 现代体<ul><li>都有衬线，衬线水平。</li><li>「剧烈粗细过渡」:曲线笔画存在一种剧烈的从粗到细的变化。</li><li>强调线完全垂直。</li><li>「不适合大量显示正文」</li></ul></li><li>「Slab serif」 粗衬线体<ul><li>都有衬线。</li><li>「几乎不存在粗细过渡」</li><li>适合阅读。尤其是小孩。</li></ul></li><li>「Sans serif」 无衬线体<ul><li>「Sans」:法语“没有”。</li><li>没有衬线。</li><li>「几乎不存在粗细过渡」</li><li>页面中使用或许有奇效。</li></ul></li><li>「Script」 手写体<ul><li>很漂亮。</li><li>花里胡哨。</li><li>但是要少用。</li></ul></li><li>「Decorative」 花体<ul><li>各种奇效。</li></ul></li></ul><h4 id="第十二章：「字体对比」"><a href="#第十二章：「字体对比」" class="headerlink" title="第十二章：「字体对比」"></a>第十二章：「字体对比」</h4><ul><li>对比6要素：<ol><li>大小</li><li>粗细</li><li>结构</li><li>形状</li><li>方向</li><li>颜色</li></ol></li><li>「必须选取两个不同字体类别中的字体」不要把同一个类别中的两个自体放在同一个页面上。</li></ul><h2 id="最后说说"><a href="#最后说说" class="headerlink" title="最后说说"></a>最后说说</h2><p>花了近四个小时的时间整理，要把内容回顾了一遍。</p><p>多少还是有点收获吧，虽然方法笨。</p><p>贵有恒，何必担心收获不够多。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Attribute和property的区别</title>
      <link href="/2017/08/01/js%E5%9F%BA%E7%A1%80/Attribute%E2%80%98n&#39;property/"/>
      <content type="html"><![CDATA[<p>阅读提示：</p><ol><li>本篇文章中的attribute，全部翻译为“属性”。而property，全部翻译为“特性”。</li><li>点表示法指js对象通过“.”获取特性，方括号表示法指js对象通过“[]”获取特性。</li></ol><a id="more"></a><h2 id="抛砖"><a href="#抛砖" class="headerlink" title="抛砖"></a>抛砖</h2><p>前段时间，有位学长问了我一个题目：在html文档中，给一个标签添加了一个属性，但是js通过点表示法无法对其进行引用。这是为什么？</p><p>当时我是脸上是大写的“懵”字。于是乎写了段代码进行尝试，如图：<br><img src="http://opqksc9nz.bkt.clouddn.com/attribute1.png" alt="啊图片"><br><img src="http://opqksc9nz.bkt.clouddn.com/attribute2.png" alt="啊图片"><br><img src="http://opqksc9nz.bkt.clouddn.com/attribute3.png" alt="啊图片"></p><p>点击标题后，并没有返回value的值，而是undefined。结果很是出人意料。<br>再做一次实验，这回获取的是DOM对象的id，代码及结果如下</p><p><img src="http://opqksc9nz.bkt.clouddn.com/attribute4.png" alt="啊图片"><br><img src="http://opqksc9nz.bkt.clouddn.com/attribute5.png" alt="啊图片"><br><img src="http://opqksc9nz.bkt.clouddn.com/attribute6.png" alt="啊图片"></p><p>对比两次的结果，是不是感觉非常奇怪？</p><h2 id="引玉"><a href="#引玉" class="headerlink" title="引玉"></a>引玉</h2><p>关系到点表示法、括号表示法与”getAttribute”和”Attribute”与”Property”的区别了。</p><p>首先，为什么取不到value属性的值呢？</p><p>在入门的时候，我们应该都学过这两种操作方式，对一个对象用点表示法或方括号表示法，表示获取该对象的属性。对象的getAttribute方法，也可获取对象的属性。但是，此属性非彼属性，一个是Attribute，另一个是property。</p><p>那么，为什么给”&lt;\h3&gt;”标签设置的value，只添加了Attributes中value的值呢？</p><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>打开我们的神器——开发人员工具，选择</p><h3>的DOM节点后，在Elements选项卡下找到Properties，如图：<p></p><p><img src="http://opqksc9nz.bkt.clouddn.com/attribute7.png" alt="啊图片"></p><p>仔细观察上边的键值对，是不是有一个叫做attributes的键？</p><p><img src="http://opqksc9nz.bkt.clouddn.com/attribute8.png" alt="啊图片"></p><p>而我们的id、value都在里边有所显示。继续展开0:id、1:value来一探究竟。</p><p><img src="http://opqksc9nz.bkt.clouddn.com/attribute9.png" alt="啊图片"></p><p><img src="http://opqksc9nz.bkt.clouddn.com/attribute10.png" alt="啊图片"></p><p>可以发现，二者展开后都具有nodeValue字段，并且他们的值为html标签中的属性值。</p><p>但是在properties中，我们可以找到名为id的键，且其绑定值为myHeader，而无法找到名叫value的键。可见，我们在html标签中声明的id，同时存在于property和attribute中，而value只在attribute中具有。</p><p>之所以会出现“抛砖”中的现象，是因为点表示法和方括号表示法，获取到的是对象的property，而getAttribute方法获取的是对象的Attributes。</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><h4 id="Question"><a href="#Question" class="headerlink" title="Question:"></a>Question:</h4><p>为什么在html标签中声明的不同属性，一个存在于对象的property，而另一个在对象的property和attribute中都存在呢？</p><h4 id="Answer"><a href="#Answer" class="headerlink" title="Answer:"></a>Answer:</h4><p>区分以下几种情况：</p><ol><li>在html标签申明属性。<ol><li>若该属性在对象的property中存在，properties和attributes二者都可能会更新（若有特殊限制，如dir，对于值的格式有要求，则有可能在property中不会更新）</li><li>若属性不存在对象的property中，则只会在attributes中刷新。</li></ol></li><li>通过js添加属性<ol><li>如果是通过使用点表示法和方括号表示法添加属性，则只会在properties中添加，而不会在attributes中添加。<br><img src="http://opqksc9nz.bkt.clouddn.com/attribute11.png" alt="啊图片"></li><li>同理，通过对对象使用setAttributes方法添加属性，则会在对象的attributes中添加该属性，在对象的property有可能添加该属性（若该属性之前存在于property中，且对该属性的值如果有特殊要求，本次赋值对其满足，则可添加）。</li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>让我们再来回顾一下本篇文章中所涉及的知识点：</p><ol><li>对象使用点表示法和括号表示法与使用“getAttribute()”方法有何不同。</li><li>如何通过js或开发人员工具查看对象的properties和attributes。</li><li>如何通过js对对象的property和attribute进行设置。</li></ol></h3>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js语言最佳实践</title>
      <link href="/2017/07/30/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/js%E8%AF%AD%E8%A8%80%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <content type="html"><![CDATA[<h3 id="解耦应用逻辑-事件处理程序"><a href="#解耦应用逻辑-事件处理程序" class="headerlink" title="解耦应用逻辑/事件处理程序"></a>解耦应用逻辑/事件处理程序</h3><p>应将应用逻辑和实践处理程序分离。</p><ul><li>优点<ul><li>更容易进行单元测试。</li><li>更容易更改触发特定过程的事件。</li></ul></li></ul><h3 id="编码实践"><a href="#编码实践" class="headerlink" title="编码实践"></a>编码实践</h3><ul><li>值比较使用严格比较操作符（===），减少类型的转换操作。</li><li>在赋值时，可以使用逻辑运算简化代码<ul><li>&amp;&amp;：返回第一个false的原始值，若全部为true返回最后一个true的原始值。</li><li>||：返回第一个true的原始值，若全部为false则返回最后一个false的原始值。</li><li>!!：快速取得当前值得布尔值。</li></ul></li><li>switch效率略高于if else。</li></ul>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java lombok插件</title>
      <link href="/2017/06/14/java/java%20lombok%E6%8F%92%E4%BB%B6/"/>
      <content type="html"><![CDATA[<p>lombok是一个java库，可以在构建工具或编辑器中引用。这款插件能够使得我们在代码中，通过使用插件提供的注解，减少getter、setter等重复代码的编写。</p><hr><p>常用的注解如下：</p><h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a><code>@Data</code></h3><p><code>@Data</code>注解集成了一系列注解：<code>@ToString()</code>、<code>@EqualsAndHashCode</code>、<code>@Getter/@Setter</code>、<code>@RequiredArgsConstructor</code>。<br>\</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java插件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《HTTP下午茶》</title>
      <link href="/2017/06/14/http/http_afternoon_tea/"/>
      <content type="html"><![CDATA[<p>HTTP协议的入门小书，全书通俗易读，辅以插图食用口味更佳。</p><a id="more"></a><p>传送门：<a href="https://www.kancloud.cn/kancloud/tealeaf-http/43837" target="_blank" rel="noopener">https://www.kancloud.cn/kancloud/tealeaf-http/43837</a></p><p>书中简要介绍了如下内容：</p><ul><li>如何通过网址如何上网<ul><li>DNS</li><li>客户端和服务器。</li></ul></li><li>无状态协议</li><li>URL</li><li>抓包工具</li><li>HTTP请求<ul><li>get请求</li><li>post请求</li><li>HTTP状态码</li></ul></li><li>如何构建有状态的web应用<ul><li>session</li><li>cookies</li><li>ajax</li></ul></li><li>WEB安全<ul><li>HTTPS</li><li>同源策略</li><li>会话劫持</li><li>XSS攻击（会话劫持的对策）</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>标签页动态图标的实现</title>
      <link href="/2017/05/24/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/title-icon/"/>
      <content type="html"><![CDATA[<p>很久之前在一个人的博客上，看到了一个很有意思的效果——当我在他的页面浏览时，选项卡图标和title是一个模样，当我离开他的页面以后，他的博客所在选项卡图标又变成了另一幅模样。当时感觉非常有趣，但没有花时间去考虑如何实现。</p><a id="more"></a><p>最近读《JavaScript高级程序设计》第十三章事件时，看到了unload事件。在书中对其的介绍如下：<br>     与load事件对应的是unload事件，这个事件在文档完全被卸载后触发。只要用户从一个页面转换到另一个页面，就会发生onunload事件。</p><p>首先映入脑海的是使用onunload来实现切换选项卡时，选项卡的图标和title进行变换的效果。首先要学习一下onunload事件。</p><hr><h4 id="第一次尝试："><a href="#第一次尝试：" class="headerlink" title="第一次尝试："></a>第一次尝试：</h4><p>测试onunload方法：<br>test2.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;     </span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;onunload事件&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body onunload=&quot;alert(&apos;Unloaded！&apos;)&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>在chrome浏览器中，关闭test2.html文档或者切换该选项卡，onunload未起作用。</p><p><img src="http://opqksc9nz.bkt.clouddn.com/chromef123.png" alt="啊图片"></p><p>首先，高程上的意思有点磨棱两可。在网上一通谷歌后才明白，“文档完全被卸载”，“用户从一个页面转换到另一个页面”实际是关掉选项卡再进行的切换。实在是坑啊，看来我们方向找错了。<br>其次，我们来探究一下onunload为何未起作用。在onunload位置打上断点。并将右侧的pause on exceptions打开。如上图所示。这里有一个小知识点。</p><p>通过调试，在第五次调试时推出该页面，并提示错误信息“Blocked alert(‘Unloaded！’) during unload.”前四次中，前两步为渲染过程，后两步为网页卸载过程，但是仍不知为何会抛出这个错误，还请大神指点迷津。</p><hr><h4 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h4><p>搜索一番，更正思路，以下是实现代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;被发现啦(*´∇｀*)&lt;/title&gt;</span><br><span class="line">    &lt;link href=&quot;../img/1.ico&quot;  rel=&quot;icon&quot; type=&quot;image/vnd.microsoft.icon&quot;/&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    //浏览器选项卡变换</span><br><span class="line">    //判断hidden属性是否存在于document属性中。</span><br><span class="line">    var hiddenProperty = &apos;hidden&apos; in document ? &apos;hidden&apos; :</span><br><span class="line">        &apos;webkitHidden&apos; in document ? &apos;webkitHidden&apos; :</span><br><span class="line">            &apos;mozHidden&apos; in document ? &apos;mozHidden&apos; :</span><br><span class="line">                null;</span><br><span class="line">    //用于在字符串中用字符串替代指定字符。第一个参数为原字符串中被替换字符串的正则表达式，第二个参数为用于替换的文本或字符串。</span><br><span class="line">    var visibilityChangeEvent = hiddenProperty.replace(/hidden/i, &apos;visibilitychange&apos;);</span><br><span class="line">    //构造匿名函数，为更换标签页状态事件所要执行的函数。</span><br><span class="line">    var onVisibilityChange = function()&#123;</span><br><span class="line">        //获取link元素</span><br><span class="line">        var links = document.head.getElementsByTagName(&quot;link&quot;);</span><br><span class="line">        if (!document[hiddenProperty]) &#123;</span><br><span class="line">            document.title=&apos;被发现啦(*´∇｀*)&apos;;</span><br><span class="line">            links[0].href = &quot;../img/1.ico&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            document.title=&apos;藏好啦(つд⊂)&apos;;</span><br><span class="line">            links[0].href=&quot;../img/2.ico&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    //用于向指定元素添加事件句柄，第一个参数为事件名，第二个参数为指定要事件触发时执行的函数。</span><br><span class="line">    document.addEventListener(visibilityChangeEvent, onVisibilityChange);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>有几点需要注意。<br>变量hiddenProperty获取的是当前浏览器的hidden属性，使用了三个三元运算符来保证其兼容性。通过replace替换成为visibilitychange+属性名中除hidden外字符串。在这里要着重注意一下visibilitychange这个事件，在我们的这个效果中起到了关键的作用。<br>通过dom获取link标签。更改title和href。<br>为元素添加事件句柄使用addEventListener()函数。<br>最后我们可以发现，实现这个效果，真的是，相当，相当简单。</p><hr><h4 id="小知识点1：关于chrome的调试"><a href="#小知识点1：关于chrome的调试" class="headerlink" title="小知识点1：关于chrome的调试"></a>小知识点1：关于chrome的调试</h4><p>在界面下方能看到按钮，它是设置程序运行时遇到异常时是否中断的开关。点击该按钮会在3种状态间切换：<br><img src="http://opqksc9nz.bkt.clouddn.com/all_catch.png" alt="all_catch"> 遇到所有异常都会中断，包括已捕获的情况。（两条白色竖杠包含在蓝色八边形中<br><img src="http://opqksc9nz.bkt.clouddn.com/some_catch.png" alt="some_catch"> 仅在出现未捕获的异常时才中断。（两条白色竖杠包含在紫色八边形中 ）<br><img src="http://opqksc9nz.bkt.clouddn.com/no_catch.png" alt="no_catch"> 默认遇到异常不中断。（两条白色竖杠包含在黑色八边形中）</p><h4 id="小知识点2：visibilitychange事件"><a href="#小知识点2：visibilitychange事件" class="headerlink" title="小知识点2：visibilitychange事件"></a>小知识点2：visibilitychange事件</h4><p>浏览器标签页被隐藏或显示的时候会触发visibilitychange事件.<br>示例程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&quot;visibilitychange&quot;, function() &#123;</span><br><span class="line">  console.log( document.visibilityState );&#125;);</span><br></pre></td></tr></table></figure><p>该事件具有四个属性：</p><ul><li>target属性：事件的目标。</li><li>type属性：被触发的事件的类型。</li><li>bubbles：表明事件是否冒泡。</li><li>cancelable：表明是否可以取消事件的默认行为。</li></ul><h4 id="另外附上一对选项卡图标"><a href="#另外附上一对选项卡图标" class="headerlink" title="另外附上一对选项卡图标"></a>另外附上一对选项卡图标</h4><p><img src="http://opqksc9nz.bkt.clouddn.com/1.ico" alt="1"><br><img src="http://opqksc9nz.bkt.clouddn.com/2.ico" alt="2"></p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GitHub Page + Hexo 搭建博客（win10）</title>
      <link href="/2017/05/10/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/build-blog/"/>
      <content type="html"><![CDATA[<p>简要介绍一下搭建博客的过程、遇到的问题及解决方案。</p><a id="more"></a><h3 id="搭建hexo博客"><a href="#搭建hexo博客" class="headerlink" title="搭建hexo博客"></a>搭建hexo博客</h3><p><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="noopener">参考</a>这篇博客写的相当详细。</p><h3 id="创建GithubPages"><a href="#创建GithubPages" class="headerlink" title="创建GithubPages"></a>创建GithubPages</h3><p><a href="https://pages.github.com/" target="_blank" rel="noopener">官方教程</a></p><p>简单来说：</p><ol><li>登录你的github，在repositories里点击“new”新建一个仓库。ok,我们该给仓库起名了。</li><li>仓库名称必须为：你的用户名.github.io,例如我的github名称为Michael-Zhang-Xian-Sen,所以仓库名必须为：Michael-Zhang-Xian-Sen.github.io</li></ol><h3 id="发表文章"><a href="#发表文章" class="headerlink" title="发表文章"></a>发表文章</h3><ol><li>新建文章<br>hexo n 命令，会在项目\source_posts中生成my new post.md文件，用编辑器打开即可进行编写。<br>或者写好.md文件后，在\source_posts中新建md文件。</li><li>推送文章<br>执行：<blockquote><p>hexo g #生成文章<br>hexo d #部署，可与hexo g合并为hexo d -g</p></blockquote></li><li>md文章标头格式<blockquote><p>title： 文章页面上的显示名称，可以任意修改，不会出现在URL中。<br>date：文章生成时间。格式为xxxx-xx-xx xx:xx:xx<br>categories：文章所属分类<br>tags：文章标签。</p></blockquote></li></ol><h3 id="更改主题配置"><a href="#更改主题配置" class="headerlink" title="更改主题配置"></a>更改主题配置</h3><p>在hexo下的/themes/(你的主题名称)/_config.yml文件，对其进行更改。<br>最后通过hexo d -g提交更改。</p><h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><p>hexo new “postName” #新建文章<br>hexo new page “pageName” #新建页面<br>hexo generate #生成静态页面至public目录<br>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br>hexo deploy #将.deploy目录部署到GitHub<br>hexo help # 查看帮助<br>hexo version #查看Hexo的版本</p><h3 id="部分简写："><a href="#部分简写：" class="headerlink" title="部分简写："></a>部分简写：</h3><p>hexo n == hexo new<br>hexo g == hexo generate<br>hexo s == hexo server<br>hexo d == hexo deploy</p>]]></content>
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win10 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/temp/PS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/temp/babel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/temp/java%E5%BE%AE%E6%9C%8D%E5%8A%A1.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/temp/npm%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/temp/%E6%83%B3%E6%B3%95.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <content type="html"><![CDATA[<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ul><li>语言<ul><li>比较了解：JS、CSS、HTML、C</li><li>略懂一些：JAVA、PYTHON</li></ul></li><li>框架<ul><li>比较了解：VUE、SpringBoot、jQuery、D3.js</li></ul></li></ul><h3 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h3><ul><li>游戏：代码写累了打两盘CSGO，放松一下。</li><li>电影：Christopher Nolan、Quentin Tarantino、姜文</li><li>想要学习摄影和剪辑。</li></ul>]]></content>
    </entry>
    
    <entry>
      <title>gallery</title>
      <link href="/gallery/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index%202.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/temp/BootstrapVue%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95.html"/>
      <content type="html"><![CDATA[<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>表单的一项经常是一些文字带一个表单input，比如标题，要写清楚标题两个字，旁边附带一个输入框。<br>则就是bootstrap中表单组的概念。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b-form-group</span> <span class="attr">label</span>=<span class="string">"性别"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b-form-radio-group</span> <span class="attr">v-model</span>=<span class="string">"form.gender"</span> <span class="attr">:disabled</span>=<span class="string">"disabled"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">b-form-radio</span> <span class="attr">value</span>=<span class="string">"true"</span>&gt;</span>男性<span class="tag">&lt;/<span class="name">b-form-radio</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">b-form-radio</span> <span class="attr">value</span>=<span class="string">"false"</span>&gt;</span>女性<span class="tag">&lt;/<span class="name">b-form-radio</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">b-form-radio-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">b-form-group</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/temp/iTerm2.html"/>
      <content type="html"><![CDATA[<p>chsh命令。切换shell环境。</p>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/temp/js%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%BE%AA%E7%8E%AF%E5%92%8C%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86.html"/>
      <content type="html"><![CDATA[<h3 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1. for循环"></a>1. for循环</h3><p>最简单的循环。写起来麻烦，但几乎什么啥都能干。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(循环体运行之前执行，一般为赋值语句;循环条件判断语句;循环体运行完毕后执行，)&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-foreach"><a href="#2-foreach" class="headerlink" title="2. foreach"></a>2. foreach</h3><p>语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组.foreach(callback(currentValue[,index[,array]])[,thisArg]);</span><br></pre></td></tr></table></figure></p><p>参数：</p><ul><li>callback:为数组中每个元素执行的函数，该函数接收三个参数：</li><li>currentValue:数组中正在处理的当前元素。</li><li>index 可选:数组中正在处理的当前元素的索引。</li><li>array 可选:forEach() 方法正在操作的数组。</li><li>thisArg 可选 可选参数。当执行回调函数 callback 时，用作 this 的值。</li></ul><p>返回值：</p><ul><li>undefined</li></ul><p>其他注意事项：</p><ul><li>forEach() 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。</li><li>除了抛出异常以外，没有办法中止或跳出 forEach() 循环</li></ul><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3>]]></content>
    </entry>
    
    <entry>
      <title>js小记：this入门及进阶</title>
      <link href="/temp/js%E5%B0%8F%E8%AE%B0%EF%BC%9Athis%E7%9A%84%E5%90%AB%E4%B9%89%E5%8F%8A%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95.html"/>
      <content type="html"><![CDATA[<h2 id="this的进阶知识"><a href="#this的进阶知识" class="headerlink" title="this的进阶知识"></a>this的进阶知识</h2><h3 id="this的箭头函数"><a href="#this的箭头函数" class="headerlink" title="this的箭头函数"></a>this的箭头函数</h3><h3 id="更改this的作用域。"><a href="#更改this的作用域。" class="headerlink" title="更改this的作用域。"></a>更改this的作用域。</h3><h4 id="方法1-call"><a href="#方法1-call" class="headerlink" title="方法1:call"></a>方法1:call</h4>]]></content>
    </entry>
    
    <entry>
      <title>mac配置代理</title>
      <link href="/temp/mac%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86.html"/>
      <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>查看代理软件中的代理信息。</li><li>设置系统偏好设置中的代理。</li><li>设置shell下的代理。</li></ol><h3 id="1-查看代理软件中的代理信息"><a href="#1-查看代理软件中的代理信息" class="headerlink" title="1. 查看代理软件中的代理信息"></a>1. 查看代理软件中的代理信息</h3><p>以v2rayn客户端为例。通过在 在配置信息中找到”本地http端口”及”本地socks5端口”。<br>猜测两端口的作用如下。</p><ul><li>本地http端口：本机中的http请求将通过该端口进行转发。</li><li>本地socks5端口：本机中部分请求使用socks5协议通过该端口进行转发。</li></ul><h3 id="2-设置系统偏好设置中的代理信息"><a href="#2-设置系统偏好设置中的代理信息" class="headerlink" title="2. 设置系统偏好设置中的代理信息"></a>2. 设置系统偏好设置中的代理信息</h3><p>配置如下信息<br>系统偏好设置-&gt;网络-&gt;高级-&gt;代理</p><ul><li>勾选自动发现代理</li><li>如果使用pac模式，请勾选自动代理配置</li></ul><h3 id="3-设置shell下的代理"><a href="#3-设置shell下的代理" class="headerlink" title="3. 设置shell下的代理"></a>3. 设置shell下的代理</h3><p>修改用户的bash配置信息，添加如下内容</p><ul><li>export http_proxy=socks5://127.0.0.1:1081（步骤1中的本地soskc5端口）</li><li>export https_proxy=socks5://127.0.0.1:1081（同上）</li><li>export http_proxy=<a href="http://127.0.0.1:8001/（步骤1中的本地http端口）" target="_blank" rel="noopener">http://127.0.0.1:8001/（步骤1中的本地http端口）</a></li><li>export https_proxy=<a href="http://127.0.0.1:8001/（同上）" target="_blank" rel="noopener">http://127.0.0.1:8001/（同上）</a></li></ul><p>不清楚为什么，修改完毕后使用source命令使用配置没有作用，重新启动bash后才成功使用新配置。</p>]]></content>
    </entry>
    
    <entry>
      <title>初识uri scheme</title>
      <link href="/temp/schema.html"/>
      <content type="html"><![CDATA[<p>初识scheme</p><a id="more"></a><p>uri scheme即uri方案。指URi命名结构的第一级。</p>]]></content>
    </entry>
    
    <entry>
      <title>vue-cli配置代理进行跨域</title>
      <link href="/temp/vue-cli%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86.html"/>
      <content type="html"><![CDATA[<p>记录通过vue-cli配置代理进行跨域的实践及感悟。</p><a id="more"></a><h3 id="实践：通过vue-cli配置代理进行跨域。"><a href="#实践：通过vue-cli配置代理进行跨域。" class="headerlink" title="实践：通过vue-cli配置代理进行跨域。"></a>实践：通过vue-cli配置代理进行跨域。</h3><ol><li>在项目根目录添加vue.config.js文件（如果已经有则跳过）。</li><li>添加如下代码：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;  <span class="comment">// 该配置仅针对开发模式有效</span></span><br><span class="line">    proxy: &#123;    <span class="comment">// 该对象下的内容为代理配置</span></span><br><span class="line">      <span class="string">'/api'</span>: &#123; <span class="comment">// 代理具有'\api'前缀的请求</span></span><br><span class="line">        target: <span class="string">'http://localhost:8080/video_war/'</span>, <span class="comment">// 将匹配的前缀（本示例中为'api'）改为target属性的内容。</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>, <span class="comment">// </span></span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    </entry>
    
    <entry>
      <title>vue学习笔记：深入了解组件</title>
      <link href="/temp/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <content type="html"><![CDATA[<p>主要学习了组件的引入（组件注册）、组件的数据（prop）、组件的行为（自定义事件）、组件间协作（插槽）。</p><a id="more"></a>]]></content>
    </entry>
    
    <entry>
      <title>vue学习笔记：工具</title>
      <link href="/temp/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0:%E5%B7%A5%E5%85%B7.html"/>
      <content type="html"><![CDATA[<p>主要学习vue的单文件组件、单元测试、TypeScript及生产环境的部署。</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h2 id="1-单文件组件"><a href="#1-单文件组件" class="headerlink" title="1. 单文件组件"></a>1. 单文件组件</h2><p>单文件组件大致指的是将一个vue文件作为一个组件。使用vue-cli搭建的项目中的<code>.vue</code>文件即单文件组件。</p><h2 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2. 单元测试"></a>2. 单元测试</h2><p>将组件当作黑盒，只关注输入和输出，只针对输入和输出进行测试。不论如何改变组件的内部逻辑，只要该组件响应输入的输出内容正确，能够通过测试，则该组件就是正确的。</p><p>进行单元测试需要安装如下插件：</p><ol><li><code>Vue Test Utils</code>。安装命令：<code>npm install --save-dev @vue/test-utils</code></li><li>一个测试运行器（<code>jest</code>或<code>mocha</code>）。安装命令：<code>npm install --save-dev jest</code></li></ol><p>相关学习资料</p><ul><li>Vue Test Utils：<a href="https://vue-test-utils.vuejs.org/zh/" target="_blank" rel="noopener">https://vue-test-utils.vuejs.org/zh/</a></li><li>jest：<a href="https://jestjs.io/docs/en/getting-started" target="_blank" rel="noopener">https://jestjs.io/docs/en/getting-started</a></li></ul><h2 id="3-TypeScript支持"><a href="#3-TypeScript支持" class="headerlink" title="3. TypeScript支持"></a>3. TypeScript支持</h2><h2 id="4-生产环境部署"><a href="#4-生产环境部署" class="headerlink" title="4. 生产环境部署"></a>4. 生产环境部署</h2>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/temp/vue%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3.html"/>
      <content type="html"><![CDATA[<h2 id="做项目中遇到的一些问题"><a href="#做项目中遇到的一些问题" class="headerlink" title="做项目中遇到的一些问题"></a>做项目中遇到的一些问题</h2><h3 id="如何对使用父组件通过v-bind传递给子组件的数据进行过滤？"><a href="#如何对使用父组件通过v-bind传递给子组件的数据进行过滤？" class="headerlink" title="如何对使用父组件通过v-bind传递给子组件的数据进行过滤？"></a>如何对使用父组件通过v-bind传递给子组件的数据进行过滤？</h3><h4 id="方案1-使用过滤器。"><a href="#方案1-使用过滤器。" class="headerlink" title="方案1:使用过滤器。"></a>方案1:使用过滤器。</h4><p>vue文档中指出过滤器可以用在两个地方：1. 双花括号差值。 2. v-bind表达式</p>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/temp/web%E7%AB%AF%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83.html"/>
      <content type="html"><![CDATA[<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>中文：微软雅黑字体。<br>英文：arial字体。</p><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p>12px：网页的最小字体，突出性的日期、版权等注释性内容。<br>14px：适用于非突出的普通正文内容。<br>16px：突出性的标题内容。</p><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>黑</p><ul><li>#999999;</li><li>#666666;</li><li>#333333;</li></ul><p>灰</p><ul><li>#8a9699;</li><li>#5c6466;</li><li>#2e3233;</li></ul>]]></content>
    </entry>
    
    <entry>
      <title>《你不知道的JavaScript 上卷》第二部分</title>
      <link href="/temp/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%20%E4%B8%8A%E5%8D%B7%E3%80%8B%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html"/>
      <content type="html"><![CDATA[<p>第二部分：this和对象原型。</p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>## </p><hr>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/temp/%E5%85%B3%E4%BA%8Enpm.html"/>
      <content type="html"><![CDATA[<h2 id="关于npx"><a href="#关于npx" class="headerlink" title="关于npx"></a>关于npx</h2><ul><li>npx 想要解决的主要问题，就是调用项目内部安装的模块。</li><li>npx还可以安装模块，且默认不是全局安装，而是安装到一个临时目录，用完即删。可以通过命令进行指定是否使用本地的模块而不是安装模块（–no-install）、强制安装并使用远程模块（–ignore-existing）</li><li><code>-p</code>参数，指定要安装的模块。</li><li><code>-c</code>参数，使得所有命令交由npx解释。</li><li>npx还可以远程执行github源码。</li><li>npm从5.2版本开始支持npx</li></ul><h3 id="dependencies和devDependencies的区别"><a href="#dependencies和devDependencies的区别" class="headerlink" title="dependencies和devDependencies的区别"></a>dependencies和devDependencies的区别</h3><ul><li><code>devDependencies</code>：开发环境使用。<br>npm i -D 是 npm install –save-dev 的简写，是指安装模块并保存到 package.json 的 devDependencies</li><li><code>dependencies</code>：生产环境使用</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>删除一个依赖：<code>npm remove</code></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>阮一峰的npx使用教程：<a href="http://www.ruanyifeng.com/blog/2019/02/npx.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/02/npx.html</a></li></ul>]]></content>
    </entry>
    
    <entry>
      <title>外边距折叠</title>
      <link href="/temp/%E5%A4%96%E8%BE%B9%E8%B7%9D%E6%8A%98%E5%8F%A0.html"/>
      <content type="html"><![CDATA[<h3 id="形成外布局重叠的情况："><a href="#形成外布局重叠的情况：" class="headerlink" title="形成外布局重叠的情况："></a>形成外布局重叠的情况：</h3><p>外边距重叠的含义：块的上外边距(margin-top)和下外边距(margin-bottom)有时合并(折叠)为单个边距，其大小为单个边距的最大值(或如果它们相等，则仅为其中一个)，</p><ol><li>同一层相邻元素之间：相邻的两个元素之间的外边距重叠，除非后一个元素加上clear-fix清除浮动。</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>知乎回答：<a href="https://www.zhihu.com/question/19823139?sort=created" target="_blank" rel="noopener">https://www.zhihu.com/question/19823139?sort=created</a></li><li>MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing</a></li></ol>]]></content>
    </entry>
    
    <entry>
      <title>定位、文档流与文本流</title>
      <link href="/temp/%E5%AE%9A%E4%BD%8D%E3%80%81%E6%96%87%E6%A1%A3%E6%B5%81%E4%B8%8E%E6%96%87%E6%9C%AC%E6%B5%81.html"/>
      <content type="html"><![CDATA[<h3 id="几种定位"><a href="#几种定位" class="headerlink" title="几种定位"></a>几种定位</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>mdn有关文档流及定位的介绍：<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/%E5%AE%9A%E4%BD%8D" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/%E5%AE%9A%E4%BD%8D</a></li></ol>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/temp/%E5%85%B3%E4%BA%8E%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91.html"/>
      <content type="html"><![CDATA[<p>加密型<br>无特征。但是墙通过判断包大小可以阻断。<br>ss,ssr,v2ray by Vmess</p><p>伪装型<br>伪装为HTTPS流量。<br>Trojan,v2ray WebSocket+LTs</p><ul><li>Trojan TCP+TLS</li><li>V2ray webocket+TLS</li></ul>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/temp/%E5%B8%B8%E8%AF%86%E7%A7%AF%E7%B4%AF.html"/>
      <content type="html"><![CDATA[<h3 id="crlf"><a href="#crlf" class="headerlink" title="crlf"></a>crlf</h3><p>回车换行（Carriage-Return Line-Feed）</p><ul><li>回车(CR, ASCII 13, \r) </li><li>换行(LF, ASCII 10, \n)</li></ul>]]></content>
    </entry>
    
    <entry>
      <title>关于异步（三）： 并发模型与事件循环机制</title>
      <link href="/temp/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html"/>
      <content type="html"><![CDATA[<h2 id="运行时概念"><a href="#运行时概念" class="headerlink" title="运行时概念"></a>运行时概念</h2><ul><li><strong>函数调用</strong>形成栈帧</li><li><strong>对象</strong>被分配在堆中</li><li><strong>待处理消息</strong>在队列中。消息关联着一个用以处理这个消息的回调函数。</li></ul><h2 id="事件循环（EventLoop）"><a href="#事件循环（EventLoop）" class="headerlink" title="事件循环（EventLoop）"></a>事件循环（EventLoop）</h2><ol><li>事件循环时，“运行时”会先处理队头的消息。处理方式即将该消息移出队列，然后使用其输入参数调用关联的函数，形成栈帧，然后继续执行这个函数直到完成（栈空）。</li><li>处理完后，执行下一个消息。</li></ol><h3 id="添加“消息”"><a href="#添加“消息”" class="headerlink" title="添加“消息”"></a>添加“消息”</h3><p>条件：</p><ol><li>事件被事件监听器绑定。</li><li>事件发生。</li></ol><p>注意：</p><ul><li>如果没有事件监听器，则该事件被丢失。</li></ul><h3 id="关于处理消息的“执行至完成”过程"><a href="#关于处理消息的“执行至完成”过程" class="headerlink" title="关于处理消息的“执行至完成”过程"></a>关于处理消息的“执行至完成”过程</h3><ul><li>缺陷：如果消息耗费时间长，则无法处理其他的事情，比如用户的其他交互。</li><li>对策：<ol><li>采用loading动画等提示信息。</li><li>将消息剪裁为多个消息。</li></ol></li></ul><h3 id="关于setTimeout"><a href="#关于setTimeout" class="headerlink" title="关于setTimeout"></a>关于setTimeout</h3><p>setTimeout接收的参数如下：</p><ul><li>待加入队列的消息。</li><li>一个时间值。即消息被加入队列的最小延迟时间。<br>当经过最小延迟时间后，该消息将入队，但必须要等待到前边的内容全部处理完毕后才能执行。</li></ul>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/temp/%E8%AF%84%E4%BC%B0.html"/>
      <content type="html"><![CDATA[<p>数据库层面</p><ol><li>项目管理：project表要改 </li><li>子项目管理：project_child表要改</li><li>查封资产管理：assets_seized需要改动</li><li>查封资产记录表：assets_seized_record需要改动</li><li>子项目地址表：childPrj_address_book需要改动</li><li>日志信息表：log_info需要改动</li><li>任务表：task需要改动</li><li>周报表：week_record需要改动</li></ol><p>mapper层面</p><ol><li>删除项目deleteProject、deleteProjectByNo</li><li>修改项目updateProject、</li><li>插入项目insertProject</li><li>查找项目：selectByProjectNo</li></ol><p>controller层面</p><ol><li>获取project：getProject</li></ol><hr><p>采用修改客户id显示的方式需要改为0001的显示方式。</p><p>项目编号改为0001 0001的方式</p><ol><li>编号显示的问题</li><li>导出的问题。</li><li>搜索的问题。</li><li>修改的问题。</li><li>删除的问题。</li></ol><ol><li>增加✔️</li><li>删除✔️</li><li>修改✔️</li><li><p>导出✔️</p></li><li><p>增加（审批）（已测试）</p></li><li>删除（审批）（已测试）</li><li>修改（审批）（已测试）</li></ol><p>晚上十一点后把数据库更新一下，重新部署一下前端和后台。</p><p>查封资产需要改。<br>查封资产记录需要改。<br>子项目地址簿需要改。<br>子项目协作团队需要改。<br>客户需要改。<br>litigious需要改。<br>日志信息需要改。<br>message需要改。<br>party需要改。<br>项目表需要改。<br>子项目表需要改。<br>任务表需要改。<br>to_do_team表需要改。</p><p>客户要改一下。</p>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/temp/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8A%9F%E8%83%BD.html"/>
      <content type="html"><![CDATA[<h2 id="前端导出excel文件"><a href="#前端导出excel文件" class="headerlink" title="前端导出excel文件"></a>前端导出excel文件</h2><ol><li>save as的前端实现</li></ol><p>插件：</p><ol><li>FileSaver <a href="https://www.npmjs.com/package/file-saver" target="_blank" rel="noopener">npm地址</a>, <a href="https://github.com/eligrey/FileSaver.js/" target="_blank" rel="noopener">GitHub地址</a> </li><li>xlsx <a href="https://www.npmjs.com/package/xlsx" target="_blank" rel="noopener">npm地址</a></li><li>script-loader <a href="https://www.npmjs.com/package/script-loader" target="_blank" rel="noopener">npm地址</a> </li></ol>]]></content>
    </entry>
    
    <entry>
      <title>项目的一些思考</title>
      <link href="/temp/%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html"/>
      <content type="html"><![CDATA[<p>项目的一些交互设计主要仿照如下网站：</p><ul><li>七牛云</li><li>腾讯云</li><li>阿里云</li></ul><a id="more"></a><p>项目内容。</p><h2 id="登陆模块"><a href="#登陆模块" class="headerlink" title="登陆模块"></a>登陆模块</h2><h3 id="七牛云登陆模块分析"><a href="#七牛云登陆模块分析" class="headerlink" title="七牛云登陆模块分析"></a>七牛云登陆模块分析</h3><h4 id="1-用户交互"><a href="#1-用户交互" class="headerlink" title="1. 用户交互"></a>1. 用户交互</h4><p>输入框内容</p><ol><li>未输入文本时，输入框的背景色为白色，输入框内的背景为浅色文字，文字内容为名词：“七牛注册邮箱”、“七牛登陆密码”。</li><li>输入文本之后，背景文字消失，无其他变化。</li></ol><p>快捷键：回车</p><ol><li>当光标在任意输入框内，都可以通过回车登陆。</li></ol><h4 id="2-登陆按钮点击操作。"><a href="#2-登陆按钮点击操作。" class="headerlink" title="2. 登陆按钮点击操作。"></a>2. 登陆按钮点击操作。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">loginButton.on(&apos;click&apos;, function(e) &#123;</span><br><span class="line">  // 判断是否已经发送了登陆请求。</span><br><span class="line">  if (isSendingSigninReq) &#123;   </span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获取需要传送的内容的值。</span><br><span class="line">  var email = emailElement.val()</span><br><span class="line">  var password = passwordElement.val()</span><br><span class="line">  var captchaVal = captchaIn.val()</span><br><span class="line"></span><br><span class="line">  // 值判空</span><br><span class="line">  if (!loginValidEmpty()) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 拼凑字符串</span><br><span class="line">  var clientId = getURLParameter(&quot;client_id&quot;) || &quot;&quot;</span><br><span class="line">  var redirectUrl = getURLParameter(&quot;redirect_url&quot;) || &quot;&quot;</span><br><span class="line">  var url = &quot;/signin?client_id=&quot; + clientId + &quot;&amp;redirect_url=&quot; + redirectUrl</span><br><span class="line"></span><br><span class="line">  // 设置已经发送过登陆请求。</span><br><span class="line">  isSendingSigninReq = true</span><br><span class="line">  // 添加样式。disabled属性，导致按钮的颜色变浅，光标变化。</span><br><span class="line">  // cursor: not-allowed;</span><br><span class="line">  // filter: alpha(opacity=65);</span><br><span class="line">  // -webkit-box-shadow: none;</span><br><span class="line">  // box-shadow: none;</span><br><span class="line">  // opacity: .65;</span><br><span class="line">  loginButton.addClass(&apos;disabled&apos;);</span><br><span class="line"></span><br><span class="line">  performRequest(url, &quot;POST&quot;, &#123;</span><br><span class="line">    &quot;username&quot;: email,</span><br><span class="line">    &quot;password&quot;: password,</span><br><span class="line">    &quot;captcha&quot;: captchaVal</span><br><span class="line">  &#125;, loginSuccess, loginError, function(e) &#123;</span><br><span class="line">    isSendingSigninReq = false</span><br><span class="line">    loginButton.removeClass(&apos;disabled&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="律师事务所登陆操作"><a href="#律师事务所登陆操作" class="headerlink" title="律师事务所登陆操作"></a>律师事务所登陆操作</h3><h4 id="1-用户交互-1"><a href="#1-用户交互-1" class="headerlink" title="1. 用户交互"></a>1. 用户交互</h4><p>猜测：按钮点击，然后提交表单，然后接收返回的内容，是一整套流程。这个流程里边有很多细节。可以探究一下。</p><h3 id="登陆模块还可以采取的改进方式"><a href="#登陆模块还可以采取的改进方式" class="headerlink" title="登陆模块还可以采取的改进方式"></a>登陆模块还可以采取的改进方式</h3><ul><li>表单提交最大的等待时间？</li><li></li></ul>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/temp/%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F%E8%BD%AC%E6%8D%A2.html"/>
      <content type="html"><![CDATA[<p>A querystring parsing and stringifying library with some added security.</p>]]></content>
    </entry>
    
  
</search>
