<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>23种设计模式概览</title>
      <link href="/2019/12/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<p>23种设计模式，包括设计模式的UML图、定义、优缺点及java代码实现。</p><p>代码详见github：<a href="https://github.com/Michael-Zhang-Xian-Sen/design-pattern" target="_blank" rel="noopener">https://github.com/Michael-Zhang-Xian-Sen/design-pattern</a></p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol><li>创建型模式<ol><li>抽象工厂模式（Abstract Factory Pattern）</li><li>工厂方法模式（Factory Method Pattern）</li><li>简单工厂（Simple Factory Pattern）（注：不属于设计模式。）</li><li>原型模式（Prototype Pattern）</li><li>单例模式（Singleton Pattern）</li><li>建造者模式（Builder Pattern）（又名：生成器模式）</li></ol></li><li>行为型模式<ol><li>观察者模式（Observer Pattern）</li><li>模版方法模式（Template Pattern）</li><li>命令模式（Command Pattern）</li><li>状态模式（State Pattern）</li><li>职责链模式（Chain of Responsibility）</li><li>解释器模式（Interpreter Pattern）</li><li>中介者模式（Mediator Pattern）（又名：调停者模式）</li><li>访问者模式（Visitor Pattern）</li><li>策略模式（Strategy Pattern）</li><li>备忘录模式（Memento Pattern）</li><li>迭代器模式（Iterator Pattern）</li></ol></li><li>结构型模式<ol><li>适配器模式（Adapter Pattern）</li><li>桥接模式（Bridge Pattern）</li><li>组合模式（Composite Pattern）</li><li>装饰模式（Decorator Pattern）</li><li>外观模式（Facade Pattern）</li><li>享元模式（Flyweight Pattern）</li><li>代理模式（Proxy Pattern）</li></ol></li></ol><h2 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1. 创建型模式"></a>1. 创建型模式</h2><h3 id="1-1-抽象工厂模式"><a href="#1-1-抽象工厂模式" class="headerlink" title="1.1. 抽象工厂模式"></a>1.1. 抽象工厂模式</h3><h4 id="UML图："><a href="#UML图：" class="headerlink" title="UML图："></a>UML图：</h4><p><img src="http://cdn.ewinds.pw/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.jpg" alt="image"></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>抽象工厂模式（AbstractFactory）提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>抽象工厂的工厂最为强大。</li><li>易于交换产品系列。由于具体工厂类在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，只需改变具体工厂的内容便可改变不同的产品配置。符合里氏替换原则。</li><li>抽象工厂使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中。</li><li>该模式帮助我们针对抽象编程，而不是针对具体编程。</li><li>通过减少程序和具体类之间的依赖，促进松耦合。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>添加产品族很简单，只需要对每个接口添加一个类，符合开闭原则；但是添加产品比较麻烦，如果新添加了产品C，那么所有工厂都要添加产品C，违反了开闭原则。</p><h3 id="1-2-工厂方法模式"><a href="#1-2-工厂方法模式" class="headerlink" title="1.2. 工厂方法模式"></a>1.2. 工厂方法模式</h3><h4 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.jpg" alt="image"></p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。（即：工厂方法把简单工厂的逻辑判断移动到了客户端）</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>符合开闭原则。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>增加新的产品时，需要增加新的工厂类和产品类，会带来更大的开销。<br>抽象层的加入使得理解难度增大。</p><h3 id="1-3-简单工厂"><a href="#1-3-简单工厂" class="headerlink" title="1.3 简单工厂"></a>1.3 简单工厂</h3><h4 id="UML图-1"><a href="#UML图-1" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.jpg" alt="image"></p><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>将创建对象的代码进行封装。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>根据客户端的条件，动态实例化相关的类。对于客户端来说，去除了与具体产品的依赖。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>由于若要添加逻辑，需要修改工厂类，违背了开闭原则</li></ul><h3 id="1-4-原型模式"><a href="#1-4-原型模式" class="headerlink" title="1.4 原型模式"></a>1.4 原型模式</h3><h4 id="UML图-2"><a href="#UML图-2" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>用原型实例制定创建对象的种类，并且通过拷贝原型这些原型创建新的对象。<br>感觉重点就在于实现了clone方法。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>被复制的对象的所有变量都含有与原来对象相同的值。故所有的对其他对象的引用都仍然指向原来的对象。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>在浅拷贝的基础上，将引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。</p><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ol><li>向客户隐藏制造新实例的复杂性。</li><li>提供让客户能够产生未知类型对象的选项。</li><li>在某些环境下，复制对象比创建新对象更有效。</li></ol><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ol><li>对象的复制有时相当复杂。</li></ol><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol><li>在一个复杂的类层次中，当系统必须从其中的许多类型创建新对象时，可以考虑原型。</li></ol><h3 id="1-5-单例模式"><a href="#1-5-单例模式" class="headerlink" title="1.5 单例模式"></a>1.5 单例模式</h3><h4 id="UML图-3"><a href="#UML图-3" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul><li>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。</li></ul><h4 id="饿汉式单例类"><a href="#饿汉式单例类" class="headerlink" title="饿汉式单例类"></a>饿汉式单例类</h4><p>在类被加载时便将自己实例化。</p><h4 id="懒汉式单例类"><a href="#懒汉式单例类" class="headerlink" title="懒汉式单例类"></a>懒汉式单例类</h4><p>在第一次被引用时将自己实例化。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>多线程的单例，需要加锁，避免同时创建多个实例。</li></ul><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul><li>可以使用单例模式替换全局变量。</li></ul><h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><ul><li>单例模式引入了许多的其他问题，比如在创建单例对象的时候需要加锁。</li></ul><h3 id="1-6-建造者模式（生成器模式）"><a href="#1-6-建造者模式（生成器模式）" class="headerlink" title="1.6 建造者模式（生成器模式）"></a>1.6 建造者模式（生成器模式）</h3><h4 id="UML图-4"><a href="#UML图-4" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><ol><li>将一个复杂对象的创建过程封装起来</li><li>允许对象通过多个步骤来创建，并且可以改变过程。（这和只有一个步骤的工厂模式不同）</li><li>向客户隐藏产品内部的表现。</li><li>产品的实现可以被替换，因为客户只看到一个抽象的接口。</li></ol><h4 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h4><ol><li>与工厂模式相比，采用生成器模式创建对象需要具备更多的领域知识。</li></ol><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><ol><li>经常被用来创建组合结构。</li></ol><h2 id="2-行为型模式"><a href="#2-行为型模式" class="headerlink" title="2. 行为型模式"></a>2. 行为型模式</h2><h3 id="2-1-观察者模式（发布-订阅模式）"><a href="#2-1-观察者模式（发布-订阅模式）" class="headerlink" title="2.1. 观察者模式（发布-订阅模式）"></a>2.1. 观察者模式（发布-订阅模式）</h3><h4 id="UML图：-1"><a href="#UML图：-1" class="headerlink" title="UML图："></a>UML图：</h4><p><img src="http://cdn.ewinds.pw/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><h4 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h4><ol><li>让主题和观察者之间松耦合。它们之间依然可以交互，但是不太清楚彼此的细节，使互相的依赖降到了最低。</li></ol><h4 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h4><h3 id="2-2-模版方法模式"><a href="#2-2-模版方法模式" class="headerlink" title="2.2 模版方法模式"></a>2.2 模版方法模式</h3><h4 id="UML图-5"><a href="#UML图-5" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><p>（注：父类是抽象类）</p><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h4 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h4><p>模板方法模式通过把不变的行为搬移到超类，去除子类中的重复代码来体现它的优势。即当不变的行为和可变的行为在子类中混杂在一起的时候，不变的行为会在子类中重复出现，通过模板方法模式把这些行为搬移到父类或其他的地方，可以帮助子类摆脱重复的不变行为的纠缠。</p><h3 id="2-3-命令模式"><a href="#2-3-命令模式" class="headerlink" title="2.3 命令模式"></a>2.3 命令模式</h3><h4 id="UML图-6"><a href="#UML图-6" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h4><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p><h4 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h4><ol><li>能够容易地设计一个命令队列。</li><li>在需要的情况下，可以容易地将命令记入日志。</li><li>允许接受请求的一方决定是否要否决请求。</li><li>可以容易地实现对请求的撤销和重做。</li><li>由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。</li><li>把请求一个操作的对象与知道怎么执行一个操作的对象分割开。</li></ol><h3 id="2-4-状态模式"><a href="#2-4-状态模式" class="headerlink" title="2.4 状态模式"></a>2.4 状态模式</h3><h4 id="UML图-7"><a href="#UML图-7" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h4><p>当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了这个类。<br>主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况，把状态的判断逻辑转移到表示不同状态的一些列类当中，可以把复杂的判断逻辑简化。</p><h4 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h4><p>将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。</p><h3 id="2-5-职责链模式"><a href="#2-5-职责链模式" class="headerlink" title="2.5 职责链模式"></a>2.5 职责链模式</h3><h4 id="UML图-8"><a href="#UML图-8" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h4><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象可以处理它为止。</p><h4 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h4><p>经常被用在窗口系统中，处理鼠标和键盘之类的事件。</p><h4 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h4><ol><li>可以随时添加或修改处理一个请求的结构。增强了给对象指派职责的灵活性。</li><li>将请求的发送者和接收者解耦。（状态模式两个请求之间仍然存在耦合）</li><li>可以简化Client对象，因为Client对象不需要知道链的结构。</li><li>通过改变指责链内的成员或调动他们的次序，允许使用者动态地新增或删除责任。</li></ol><h4 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h4><p>并不能保证请求一定被执行。<br>不容易观察运行时的特征，有碍于debug。</p><h3 id="2-6-解释器模式"><a href="#2-6-解释器模式" class="headerlink" title="2.6 解释器模式"></a>2.6 解释器模式</h3><h4 id="UML图-9"><a href="#UML图-9" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h4><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>如果一种特定类型的问题发生频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p><h3 id="2-7-中介者模式（调停者模式）"><a href="#2-7-中介者模式（调停者模式）" class="headerlink" title="2.7 中介者模式（调停者模式）"></a>2.7 中介者模式（调停者模式）</h3><h4 id="UML图-10"><a href="#UML图-10" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h4><p>用一个中介对象来封装一系列的对象交互。中介者使各个对象之间不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><h3 id="2-8-访问者模式"><a href="#2-8-访问者模式" class="headerlink" title="2.8 访问者模式"></a>2.8 访问者模式</h3><h4 id="UML图-11"><a href="#UML图-11" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h4><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><h3 id="2-9-策略模式"><a href="#2-9-策略模式" class="headerlink" title="2.9 策略模式"></a>2.9 策略模式</h3><h4 id="UML图-12"><a href="#UML图-12" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h4><p>它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户。</p><h3 id="2-10-备忘录模式"><a href="#2-10-备忘录模式" class="headerlink" title="2.10 备忘录模式"></a>2.10 备忘录模式</h3><h4 id="UML图-13"><a href="#UML图-13" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-15"><a href="#定义-15" class="headerlink" title="定义"></a>定义</h4><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p><h3 id="2-11-迭代器模式"><a href="#2-11-迭代器模式" class="headerlink" title="2.11 迭代器模式"></a>2.11 迭代器模式</h3><h4 id="UML图-14"><a href="#UML图-14" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-16"><a href="#定义-16" class="headerlink" title="定义"></a>定义</h4><p>提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p><p>该模式已经被多种语言所实现为</p><h2 id="3-结构型模式"><a href="#3-结构型模式" class="headerlink" title="3. 结构型模式"></a>3. 结构型模式</h2><h3 id="3-1-适配器模式"><a href="#3-1-适配器模式" class="headerlink" title="3.1 适配器模式"></a>3.1 适配器模式</h3><h4 id="UML图-15"><a href="#UML图-15" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-17"><a href="#定义-17" class="headerlink" title="定义"></a>定义</h4><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><h4 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h4><h3 id="3-2-桥接模式"><a href="#3-2-桥接模式" class="headerlink" title="3.2 桥接模式"></a>3.2 桥接模式</h3><h4 id="UML图-16"><a href="#UML图-16" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-18"><a href="#定义-18" class="headerlink" title="定义"></a>定义</h4><p>Bridge，将抽象部分与它的实现部分分离，使他们都可以独立地变化。</p><ul><li>补充理解1：实现的方式有多种。桥接模式的核心意图就是把这些实现独立出来，让它们各自地变化。这就使得每种实现的变化不会影响其他实现，从而达到应对变化的目的。</li><li>补充理解2：实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。</li></ul><h3 id="3-3-组合模式"><a href="#3-3-组合模式" class="headerlink" title="3.3 组合模式"></a>3.3 组合模式</h3><h4 id="UML图-17"><a href="#UML图-17" class="headerlink" title="UML图"></a>UML图</h4><h5 id="透明模式"><a href="#透明模式" class="headerlink" title="透明模式"></a>透明模式</h5><p><img src="http://cdn.ewinds.pw/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%28%E9%80%8F%E6%98%8E%E6%A8%A1%E5%BC%8F%29.jpg" alt="image"></p><h5 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h5><p><img src="http://cdn.ewinds.pw/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%28%E5%AE%89%E5%85%A8%E6%96%B9%E5%BC%8F%29.jpg" alt="image"></p><h4 id="定义-19"><a href="#定义-19" class="headerlink" title="定义"></a>定义</h4><p>将对象组合成树形结构，以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><ul><li>透明方式：Componet中声明所有用来管理子对象的方法。</li><li>安全方式：Componet接口中不声明管理子对象的方法，而是在Composite中声明所有用来管理子对象的方法。</li></ul><h3 id="3-4-装饰模式"><a href="#3-4-装饰模式" class="headerlink" title="3.4 装饰模式"></a>3.4 装饰模式</h3><h4 id="UML图-18"><a href="#UML图-18" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-20"><a href="#定义-20" class="headerlink" title="定义"></a>定义</h4><p>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p><h3 id="3-5-外观模式"><a href="#3-5-外观模式" class="headerlink" title="3.5 外观模式"></a>3.5 外观模式</h3><h4 id="UML图-19"><a href="#UML图-19" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-21"><a href="#定义-21" class="headerlink" title="定义"></a>定义</h4><ul><li>外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li></ul><h4 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h4><ul><li>符合迪米特法则</li><li>符合依赖倒置原则</li></ul><h3 id="3-6-享元模式"><a href="#3-6-享元模式" class="headerlink" title="3.6 享元模式"></a>3.6 享元模式</h3><h4 id="UML图-20"><a href="#UML图-20" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-22"><a href="#定义-22" class="headerlink" title="定义"></a>定义</h4><ul><li>Flyweight，运用共享技术有效地支持大量细粒度的对象。</li><li>享元对象的内部状态：不会随环境改变而改变的共享部分。</li><li>享元对象的外部状态：随环境改变而改变的、不可以共享的状态。 </li></ul><h4 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h4><p>节约存储空间。</p><h4 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h4><p>需要将部分状态外部化，使得逻辑更为复杂，</p><h3 id="3-7-代理模式"><a href="#3-7-代理模式" class="headerlink" title="3.7 代理模式"></a>3.7 代理模式</h3><h4 id="UML图-21"><a href="#UML图-21" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://cdn.ewinds.pw/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg" alt="image"></p><h4 id="定义-23"><a href="#定义-23" class="headerlink" title="定义"></a>定义</h4><p>为其他对象提供一种代理以控制这个对象的访问。</p><h4 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h4><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>远程代理</li><li>虚拟代理</li><li>安全代理</li></ul>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>考研作息时间表（第一阶段）</title>
      <link href="/2018/05/02/%E4%BD%9C%E6%81%AFschedule/"/>
      <content type="html"><![CDATA[<p>本作息表将执行至本学期结束。届时重新规划时间表，以适应暑假的复习生活。</p><a id="more"></a><h2 id="时间安排"><a href="#时间安排" class="headerlink" title="时间安排"></a>时间安排</h2><p>8:30-12:30 高数<br>14:30-17:30 英语/专业课<br>19:00-21:00 高数/专业课<br>21:20-22:00 锻炼<br>23:30 必须睡觉</p><h2 id="每日必做："><a href="#每日必做：" class="headerlink" title="每日必做："></a>每日必做：</h2><ol><li>按时睡觉！</li><li>锻炼：跑步五圈+40个蹲起||30个俯卧撑+80个蹲起</li><li>记单词：高质量背诵50个单词。</li></ol><p>若提前完成计划的学习内容，晚上可提前锻炼后回来撸代码。</p><p>若无要事必须严格按照作息表执行！</p><h2 id="ps-复习两个月的感受。"><a href="#ps-复习两个月的感受。" class="headerlink" title="ps:复习两个月的感受。"></a>ps:复习两个月的感受。</h2><p>早晨肯定是效率最好的，毋庸置疑，基本不会犯困，不会瞌睡，不会走神，也能坐得住，可以静下心来学习。<br>下午效率最差。2:00-3:30基本是半睡半醒中度过。甚至到四点还没有缓过神来，所以安排一些轻松的学习内容，不是那么耗费脑子。<br>晚上效率一般。这时候外界干扰较多，注意力容易分散。</p><p>想打乱计划很简单，只需熬一次夜！所以，现在立刻睡觉！</p>]]></content>
      
      <categories>
          
          <category> 白日梦 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《白日梦》 北岛</title>
      <link href="/2018/04/23/daydream/"/>
      <content type="html"><![CDATA[<p>考研就像是和梦想的院校谈恋爱。哦不，是追她，还没开始谈。（天天生活在劝退阴影里的我。）</p><p>「封面图来自：爆裂鼓手」</p><a id="more"></a><hr><h2 id="《白日梦》"><a href="#《白日梦》" class="headerlink" title="《白日梦》"></a><center>《白日梦》</center></h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>在秋天的暴行之后<br>这十一月被冰霜麻醉<br>展平在墙上<br>影子重重叠叠<br>那是骨骼石化的过程<br>你没有如期归来<br>我喉咙里的果核<br>变成了温暖的石头</p><p>我，行迹可疑<br>新的季节的阅兵式<br>敲打我的窗户<br>住在钟里的人们<br>带着摆动的心脏奔走<br>我俯视时间<br>不必转身<br>一年的黑暗在杯中</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>音乐释放的蓝色灵魂<br>在烟蒂上飘摇<br>出入门窗的裂缝</p><p>一个准备切开的苹果<br>–那里没有核儿<br>没有生长敌意的种子<br>远离太阳的磁场<br>玻璃房子里生长的头发<br>如海藻，避开真实的</p><p>风暴，我们是<br>迷失在航空港里的儿童<br>总想大哭一场</p><p>在宽银幕般的骚动中<br>收集烟尘的鼻子<br>碰到一起<br>说个不停，这是我<br>是我<br>我，我们</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>喃喃梦呓的<br>书，排列在一起<br>在早晨三点钟<br>等待异端的火箭</p><p>时间并不忧郁<br>我们弃绝了山林湖泊<br>集中在一起<br>为什么我们在一起<br>一只铁皮乌鸦<br>在大理石的底座下<br>那永恒的事物的焊接处<br>不会断裂</p><p>人们从石棺里醒来<br>和我坐在一起<br>我们生前与时代合影<br>挂在长桌尽头</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>你没有如期归来<br>而这正是离别的意义<br>一次爱的旅行<br>有时候就象抽烟那样<br>简单</p><p>地下室空守着你<br>内心的白银<br>水仙花在暗中灿然开放<br>你听凭所有的坏天气<br>发怒、哭喊<br>乞求你打开窗户</p><p>书页翻开<br>所有的文字四散<br>只留下一个数字<br>–我的座位号码<br>靠近窗户<br>本次列车的终点是你</p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>向日葵的帽子不翼而飞<br>石头圆滑、可靠<br>保持着本质的完整<br>在没有人居住的地方<br>山也变得年轻<br>晚钟不必解释什么<br>巨蟒在蜕皮中进化<br>–绳索打结<br>把鱼群悬挂在高处<br>一潭死水召来无数闪电<br>虎豹的斑纹渐成蓝色<br>天空已被吞噬</p><p>历史静默<br>峭壁目送着河上<br>那自源头漂流而下的孩子<br>这人类的孩子</p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>我需要广场<br>一片空旷的广场<br>放置一个碗，一把小匙<br>一只风筝孤单的影子</p><p>占据广场的人说<br>这不可能</p><p>笼中的鸟需要散步<br>梦游者需要贫血的阳光<br>道路撞击在一起<br>需要平等的对话</p><p>人的冲动压缩成<br>铀，存放在可靠的地方</p><p>在一家小店铺<br>一张纸币，一片剃刀<br>一包剧毒的杀虫剂<br>诞生了</p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>我死的那年十岁<br>那抛向空中的球再也没<br>落到地上<br>你是唯一的目击者<br>十岁，我知道<br>然后我登上<br>那辆运载野牛的火车<br>被列入过期的提货单里<br>供人们阅读</p><p>今天早上<br>一只鸟穿透我打开的报纸<br>你的脸嵌在其中<br>一种持久的热情<br>仍在你的眼睛深处闪烁<br>我将永远处于<br>你所设计的阴影中</p><h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>多少年<br>多少火种的逃亡者<br>使日月无光<br>白马展开了长长的绷带<br>木桩钉进了煤层<br>渗出殷红的血<br>毒蜘蛛弹拨它的琴弦<br>从天而降<br>开阔地，火球滚来滚去</p><p>多少年<br>多少河流干涸<br>露出那隐秘的部分<br>这是座空荡荡的博物馆<br>谁置身其中<br>谁就会自以为是展品<br>被无形的目光注视<br>如同一颗湖泊爆炸后<br>飞出的沉睡千年的小虫</p><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p>终于有一天<br>谎言般无畏的人们<br>从巨型收音机里走出来<br>赞美着灾难<br>医生举起白色的床单<br>站在病树上疾呼：<br>是自由，没有免疫的自由<br>毒害了你们</p><h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><p>手在喘息<br>流苏是呻吟<br>雕花的窗棂互相交错<br>纸灯笼穿过游廊<br>在尽头熄灭<br>一支箭敲响了大门</p><p>牌位接连倒下<br>–连锁反应的恶梦<br>子孙们<br>是威严的石狮嘴里<br>腐烂的牙齿</p><p>当年锁住春光的庭院<br>只剩下一棵树<br>他们在酒后失态<br>围着树跳舞<br>疯狂是一种例外</p><h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><p>别把你的情欲带入秋天<br>这残废者的秋天<br>打着响亮呼哨的秋天</p><p>一只女人干燥的手<br>掠过海面，却滴水未沾<br>推移礁石的晚霞<br>是你的情欲<br>焚烧我</p><p>我，心如枯井<br>对海洋的渴望使我远离海洋<br>走向我的开端–你<br>或你的尽头–我</p><p>我们终将迷失在大雾中<br>互相呼唤<br>在不同的地点<br>成为无用的路标</p><h3 id="12"><a href="#12" class="headerlink" title="12"></a>12</h3><p>白色的长袍飘向那<br>不存在的地方<br>心如夏夜里抽搐的水泵<br>无端地发泄<br>黄昏的晚宴结束了<br>山峦散去<br>蜉蝣在水上写诗<br>地平线的颂歌时断时续<br>影子并非一个人的历史<br>戴上或摘下面具<br>花朵应运而生<br>谎言与悲哀不可分离<br>如果没有面具<br>所有钟表还有什么意义</p><p>当灵魂在岩石是显出原形<br>只有鸟会认出它们</p><h3 id="13"><a href="#13" class="headerlink" title="13"></a>13</h3><p>他指银色的沼泽说<br>那里发生过战争<br>几棵冒烟的树在地平线飞奔<br>转入地下的士兵和马<br>闪着磷光，日夜<br>追随着将军的铠甲</p><p>而我们追随的是<br>思想的流弹中<br>那逃窜的自由的兽皮</p><p>昔日阵亡者的头颅<br>如残月升起<br>越过沙沙作响的灌木丛<br>以预言家的口吻说<br>你们并非幸存者<br>你们永无归宿</p><p>新的思想呼啸而过<br>击中时代的背影<br>一滴苍蝇的血让我震惊</p><h3 id="14"><a href="#14" class="headerlink" title="14"></a>14</h3><p>我注定要坐在岸边<br>在一张白纸上<br>期待着老年斑纹似的词</p><p>出现，秩序与混乱<br>蜂房酿造着不同的情欲<br>九十九座红色的山峰</p><p>上涨，空气稀薄<br>地衣居心叵测地蔓延<br>渺小，如尘世的</p><p>计谋，钢筋支撑着权利<br>石头也会晕眩<br>这毕竟是一种可怕的</p><p>高度，白纸背面<br>孩子的手在玩影子游戏<br>光源来自海底两条交尾的<br>电鳗</p><h3 id="15"><a href="#15" class="headerlink" title="15"></a>15</h3><p>蹲伏在瓦罐的夜<br>溢出清凉的<br>水，那是我们爱的源泉</p><p>回忆如伤疤<br>我的一生在你的脚下<br>这流动的沙丘<br>凝聚在你的手上<br>成为一颗眩目的钻石</p><p>没有床，房间<br>小得使我们无法分离<br>四壁薄如棉纸<br>数不清的嘴巴画在墙上<br>低声轮唱</p><p>你没有如期归来<br>我们共同啜饮的杯子<br>砰然碎裂</p><h3 id="16"><a href="#16" class="headerlink" title="16"></a>16</h3><p>矿山废弃已久<br>它的金属拉成细长的线</p><p>猫头鹰通体透明<br>胃和神经丛掠过夜空</p><p>古生物的联盟解体了<br>粘合化石的工作</p><p>仍在进行，生存<br>永远是一种集体冒险</p><p>生存永远是和春天<br>在进行战争</p><p>绿色的履带碾过<br>阴郁的文明</p><p>喷射那水银的喷泉<br>金属的头改变了地貌</p><h3 id="17"><a href="#17" class="headerlink" title="17"></a>17</h3><p>几个世纪过去了<br>一日尚未开始<br>冷空气触摸了我的手<br>螺旋楼梯般上升<br>黑与白，光线<br>在房瓦的音阶上转换<br>一棵枣树的安宁<br>男人的喉咙成熟了</p><p>动物园的困兽<br>被合进一本书<br>钢鞭飞舞<br>悸动着的斑斓色彩<br>隔着漫长的岁月<br>凄厉地叫喊<br>一张导游图把我引入<br>城中之星星狡黠而凶狠<br>象某一事物的核心</p><h3 id="18"><a href="#18" class="headerlink" title="18"></a>18</h3><p>我总是沿着那条街的<br>孤独的意志漫步<br>喔，我的城市<br>在玻璃的坚冰上滑行</p><p>我的城市我的故事<br>我的水龙头我积怨<br>我的鹦鹉我的<br>保持平衡的睡眠</p><p>罂粟花般芳香的少女<br>从超级市场飘过<br>带着折刀般表情的人们<br>共饮冬日的寒光</p><p>诗，就象阳台一样<br>无情地折磨着我<br>被烟尘粉刷的墙<br>总在意料之中</p><h3 id="19"><a href="#19" class="headerlink" title="19"></a>19</h3><p>当你转身的时候<br>花岗石崩裂成细细的流沙<br>你用陌生的语调<br>对空旷说话，不真实<br>如同你的笑容</p><p>深深植入昨天的苦根<br>是最黑暗处的闪电<br>击中了我们想象的巢穴<br>从流沙的瀑布中<br>我们听见了水晶撞击的音乐</p><p>一次小小的外科手术<br>我们挖掘燧石的雪地上<br>留下了麻雀的爪印<br>一辆冬天疯狂的马车<br>穿过夏日的火焰</p><p>我们安然无恙<br>四季的美景印在你的衣服上</p><h3 id="20"><a href="#20" class="headerlink" title="20"></a>20</h3><p>放牧是一种观点的陈述<br>热病使羊群膨胀<br>象一个个气球上升<br>卡在天蝎星座中<br>热风卷走了我的屋顶<br>在四壁之内<br>我静观无字的天空<br>文化是一种共生现象<br>包括羊的价值<br>狼的原则<br>钟罩里一无所有<br>在我们的视野里<br>只有一条干涸的河道<br>几缕笔直的烟<br>古代圣贤们<br>无限寂寞<br>垂钓着他们的鱼</p><h3 id="21"><a href="#21" class="headerlink" title="21"></a>21</h3><p>诡秘的豆荚有五只眼睛<br>它们不愿看见白昼<br>只在黑暗里倾听</p><p>一种颜色是一个孩子<br>诞生时的啼哭</p><p>宴会上桌布洁白<br>杯中有死亡的味道<br>–悼词库挥发的沉闷气息</p><p>传统是一张航空照片<br>山河缩小成桦木的纹理</p><p>总是人，俯首听命于<br>说教、仿效、争斗<br>和他们的尊严</p><p>寻找激情的旅行者<br>穿过候鸟荒凉的栖息地</p><p>石膏像打开窗户<br>艺术家从背后<br>用工具狠狠地敲碎它们</p><h3 id="22"><a href="#22" class="headerlink" title="22"></a>22</h3><p>弱音器弄哑了的小号<br>忽然响亮地哭喊<br>那伟大悲剧的导演<br>正悄悄地死去<br>两只装着滑轮的狮子<br>仍在固定的轨道上<br>东奔西撞</p><p>曙光瘫痪在大街上<br>很多地址和名字和心事<br>在邮筒在夜里避雨<br>货车场的鸭子喧哗<br>窗户打着哈欠<br>一个来苏水味的早晨<br>值班医生正填写着死亡报告</p><p>悲剧的伟大意义呵<br>日常生活的琐碎细节</p><h3 id="23"><a href="#23" class="headerlink" title="23"></a>23</h3><p>在昼与夜之间出现了裂缝</p><p>语言突然变得陈旧<br>象第一场雪<br>那些用黑布蒙面的证人<br>紧紧包围了你<br>你把一根根松枝插在地上<br>默默点燃它们</p><p>那是一种祭奠的仪式<br>从死亡的山冈上<br>我居高临下<br>你是谁<br>要和我交换什么<br>白鹤展开一张飘动的纸<br>上面写着你的回答<br>而我一无所知</p><p>你没有如期归来</p>]]></content>
      
      <categories>
          
          <category> 现代诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim中文乱码的解决方案</title>
      <link href="/2017/10/27/vim%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <content type="html"><![CDATA[<p>某人喜欢在linux服务器上修改协会的官网文件。用vim编辑时却总是出现“删除一个字符增加一个字符”、“保存以后增加一堆字符”的现象。实在看不下去，遂修补之。「封面图来自：VIM图标」</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>出现上述现象是编码出了问题。</p><ol><li>执行<code>sudo vim ~/.vimrc</code></li><li><p>输入</p><p> set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936<br> set termencoding=utf-8<br> set encoding=utf-8</p></li></ol><h2 id="成功解决乱码。"><a href="#成功解决乱码。" class="headerlink" title="成功解决乱码。"></a>成功解决乱码。</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="为什么要改变vimrc文件"><a href="#为什么要改变vimrc文件" class="headerlink" title="为什么要改变vimrc文件"></a>为什么要改变vimrc文件</h4><p><code>vimrc</code>文件用于初始化vim。使用vim时，vim会到指定目录下寻找vimrc并用其进行初始化。更多的内容见<code>:help vimrc</code>，通过<code>version</code>，可以看到vim规定的vimrc文件路径。例如我的：</p><pre><code>system vimrc file: &quot;$VIM/vimrc&quot;user vimrc file: &quot;$HOME/.vimrc&quot;2nd user vimrc file: &quot;~/.vim/vimrc&quot;user exrc file: &quot;$HOME/.exrc&quot;fall-back for $VIM: &quot;/usr/share/vim&quot;</code></pre><h4 id="编辑内容的含义是什么？"><a href="#编辑内容的含义是什么？" class="headerlink" title="编辑内容的含义是什么？"></a>编辑内容的含义是什么？</h4><p>（1） 磁盘文件的字符编码<br>存放在磁盘上的文本文件，是按照一定的字符编码进行保存的，不同的文件可能使用了不同的字符编码。<br>这在VIM中被叫做：fileencoding。</p><p>（2） VIM缓冲区以及界面的字符编码<br>VIM运行时，其菜单、标签、以及各个缓冲区统一使用一种字符编码方式。<br>这在VIM中被叫做：encoding。</p><p>（3) 终端使用的字符编码<br>终端同一时刻只能使用一种字符编码，并按照这种编码从接收到的字节流中识别字符，并显示，终端的字符编码是可以动态调整的。<br>这在VIM中被叫做：termencoding。</p><p>可以看出，VIM涉及到的3种字符编码之间的转换：<br>读：fileencoding—–&gt; encoding<br>显：encoding ——&gt; termencoding<br>写：encoding ——-&gt; fileencoding</p><h4 id="那些字符编码"><a href="#那些字符编码" class="headerlink" title="那些字符编码"></a>那些字符编码</h4><p>UTF-8（8-bit Unicode Transformation Format）：是一种针对Unicode的可变长度字符编码，又称万国码。 支持中文。</p><p>UCS（通用字符集）：包含了用于表达所有已知语言的字符，保证了与其他字符集的双向兼容， 是所有其他字符集标准的一个超集。支持中文。Unicode规范中推荐的标记字节顺序的方法是BOM。BOM是Byte Order Mark。在UCS编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。</p><p>gb18030、gbk、gb2312肯定是支持中文的编码。</p><p>CP936其实就是GBK，IBM在发明Code Page的时候将GBK放在第936页，所以叫CP936。</p><p>参考资料： <a href="http://blog.csdn.net/smstong/article/details/51279810" target="_blank" rel="noopener">http://blog.csdn.net/smstong/article/details/51279810</a><br>参考资料： <a href="http://www.fmddlmyy.cn/text6.html" target="_blank" rel="noopener">http://www.fmddlmyy.cn/text6.html</a><br>参考资料： <a href="https://www.zhihu.com/question/35609295" target="_blank" rel="noopener">https://www.zhihu.com/question/35609295</a></p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>换行造成空格间距的解决方案</title>
      <link href="/2017/10/14/%E6%8D%A2%E8%A1%8C%E9%80%A0%E6%88%90%E7%A9%BA%E6%A0%BC%E9%97%B4%E8%B7%9D%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <content type="html"><![CDATA[<p>最近在写东西的时候总是碰见一些莫名奇妙的bug。</p><p>在使用<code>display:inline-block</code>属性时经常会两个元素之间莫名奇妙出现空白。</p><p>空白是因代码中的换行产生的，以下是解决方案。</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>使用margin移动至合适位置</li><li>代码不进行换行</li><li>设置任意父级块的字体大小为0</li><li>视情况改为浮动布局</li><li><p>将两个标签中间的空白部分进行注释</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> /&gt;</span><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   --&gt;</span><span class="tag">&lt;<span class="name">input</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>将闭合标签<code>&gt;</code>放到下一个标签的开始处</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">   /&gt;</span><span class="tag">&lt;<span class="name">input</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>「写给大家看的设计书」</title>
      <link href="/2017/08/07/%E3%80%8C%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E3%80%8D/"/>
      <content type="html"><![CDATA[<h3 id="本文是读书笔记兼读后感。"><a href="#本文是读书笔记兼读后感。" class="headerlink" title="本文是读书笔记兼读后感。"></a>本文是读书笔记兼读后感。</h3><p>由于经常做PPT和写网页，都涉及到设计。而自己设计出来的东西和自己的预期又相差太大。以后在做前端工作时，万一设计师没有给设计图，或者是针对细节处要自由发挥，没有一个好的欣赏和设计水平，设计出的东西奇丑无比，简直罪恶。</p><a id="more"></a><p>记得上次设计一系列关于某比赛的H5页面，页面布局和图片搭配被协会的设计师吐槽得不行不行的。</p><p>一句话，我不认为前端就不需要懂设计。</p><p>于是乎，决定在闲暇时间学一些设计相关的内容。</p><p>在知乎偶然间看到有人推荐《写给大家看的设计书》，豆瓣上的评价也不低。就看这本吧。</p><p>作者语言风趣，通俗易懂。前半部分围绕四大基本原则来讲述，后边对字体设计进行了科普，总结的原则非常精辟，但有些例子的效果感觉差别不大。</p><p>下面是关于本书的一些笔记</p><h2 id="笔记部分"><a href="#笔记部分" class="headerlink" title="笔记部分"></a>笔记部分</h2><h3 id="PART1：「设计原则」"><a href="#PART1：「设计原则」" class="headerlink" title="PART1：「设计原则」"></a>PART1：「设计原则」</h3><h4 id="第一章：「引言」"><a href="#第一章：「引言」" class="headerlink" title="第一章：「引言」"></a>第一章：「引言」</h4><p>通过<strong>约书亚树</strong>作为引言。</p><p>作者试图用关于这棵树的小故事说明一个道理：如果能说出一个物品的名称，那么在日常生活中你就会经常注意到它。<strong>掌握它，拥有它，让它受你所控</strong>。</p><p>类比于学习，差不多的道理。可能效果没那么明显，因为对于一些名词，你没有理解它原理性内容，见到次数再多也不会拥有它。但知道它的名称，总归是揭下它神秘面纱的第一步。</p><ul><li>4大基本原则<ol><li>对比</li><li>重复</li><li>对齐</li><li>亲密性</li></ol></li></ul><h4 id="第二章：「亲密性」"><a href="#第二章：「亲密性」" class="headerlink" title="第二章：「亲密性」"></a>第二章：「亲密性」</h4><ul><li>物理位置的接近就意味着存在关联。</li><li>把相关的元素分在一组，使他们建立更近的亲密性。</li><li>亲密性的根本目的是实现组织性。</li></ul><h4 id="第三章：「对齐」"><a href="#第三章：「对齐」" class="headerlink" title="第三章：「对齐」"></a>第三章：「对齐」</h4><ul><li>任何元素都不能在页面上随意安放。每一项都应当与页面上的某个内容存在某种视觉联系。</li><li>采用同一种对齐方式的元素会产生一种「边界强度」，其为布局提供力度。</li><li>勇敢一些，不要畏缩！</li><li>一个页面只使用一种对齐方式。</li><li>可以有意为之打破边界，如将插图斜着插入边界，只要效果比原来更好。不必过于拘束。勇敢一些，不要畏缩！</li><li>在打破规则前必须清楚规则是什么。</li><li>对齐也会使元素之间产生视觉联系。</li><li>对齐的根本目的是使页面统一而且由条理。</li></ul><h4 id="第四章：「重复」"><a href="#第四章：「重复」" class="headerlink" title="第四章：「重复」"></a>第四章：「重复」</h4><ul><li>设计的某些方面需要在整个作品中重复。</li><li>在一系列作品中尤其需要注意重复。</li><li>重复的目的就是统一， 并增强视觉效果。</li></ul><h4 id="第五章：「对比」"><a href="#第五章：「对比」" class="headerlink" title="第五章：「对比」"></a>第五章：「对比」</h4><ul><li>页面的元素之间要有对比效果，达到吸引读者的对比效果。</li><li>对比的根本目的有两个。一个目的是增强页面的效果，如果一个页面看起来很有意思，往往更有可读性。另一个目的是有助于信息的组织。</li></ul><h4 id="第六章：「4大基本原则复习」"><a href="#第六章：「4大基本原则复习」" class="headerlink" title="第六章：「4大基本原则复习」"></a>第六章：「4大基本原则复习」</h4><ul><li><strong>不要畏畏缩缩！</strong></li></ul><h4 id="第七章：「颜色运用」"><a href="#第七章：「颜色运用」" class="headerlink" title="第七章：「颜色运用」"></a>第七章：「颜色运用」</h4><ul><li>色轮<ul><li>三原色(tricolor):红黄蓝，色轮的基础。这三种颜色无法创建。</li><li><img src="http://opqksc9nz.bkt.clouddn.com/%E4%B8%89%E5%8E%9F%E8%89%B2.jpg" alt="三原色"></li><li>三间色(secondary color):将三原色色轮上相邻颜色<strong>等量</strong>混合，形成三间色。分别为橙、绿、紫色。</li><li><img src="http://opqksc9nz.bkt.clouddn.com/%E4%B8%89%E9%97%B4%E8%89%B2.jpg" alt="三间色"></li><li>第三色(tertiary colour):再将空白两边的颜色按<strong>等量</strong>混合，形成第三色。</li><li><img src="http://opqksc9nz.bkt.clouddn.com/%E7%AC%AC%E4%B8%89%E8%89%B2.jpg" alt="第三色"></li><li>「互补色」:色轮上相对(完全对立)的颜色。通常一种作为主色，另一种用来强调。</li><li>「三色组」:色轮上彼此等距的三种颜色形成的让人愉悦的三色组。<ul><li>「基色三色组」:红黄蓝。</li><li>「间色三色组」：绿橙紫</li><li>还有两组，作者没有细分，不作累述。</li></ul></li><li>「分裂互补三色组」:从色轮的一遍选择一种颜色，再从色轮上找到其对面的互补色两侧的颜色。具有更细致的颜色边界。</li><li>「类似色」:由色轮上彼此相邻的颜色构成。</li></ul></li><li>暗色和亮色<ul><li>基本色轮只涉及纯「色调」，即纯色。还可向其添加黑色或者白色，对色轮进行扩展。</li><li>纯色就是色调。</li><li>向色调增加黑色就构成一个暗色。</li><li>向色调增加一个白色构成一个亮色。</li><li>「单色组合」:由一种色调及其相应的多种亮色和暗色组成。</li><li>「暗色组合」:由暗色和亮色进行组合，不使用色调。</li></ul></li><li>注意色质<ul><li>「色质」:某种颜色的特定明暗度、深浅度或色调。</li><li>颜色组合导致视觉抖动:色质过于接近。</li><li><strong>避免让类似色质的色调挨在一起！</strong></li></ul></li><li>暖色与冷色<ul><li>「暖色」:其中包含红色或黄色。通过对颜色加此种颜色可以对颜色”加热”。</li><li>「冷色」:其中包含蓝色。通过对颜色加此种颜色可以对颜色”降温”</li><li>冷色趋于做背景色，为后退型。</li><li>暖色为趋进型。</li><li>在冷色和暖色的搭配中，少用暖色。</li></ul></li><li>两种颜色模型<ul><li>「CMYK」:Cyan(一种蓝色)、Magenta(一种红、粉红色)、Yellow(黄色)、Key(黑色)。<ul><li>「四色处理」:这四种颜色可以打印出成千上万种颜色。</li></ul></li><li>「RGB」:Red(红色)、Green(绿色)、Blue(蓝色)<ul><li>红色混合绿色可以产生黄色。</li><li>red、yellow、blue为颜料三原色。rgb为光学三原色。</li></ul></li><li><strong>需要印刷的项目应当使用CMYK</strong></li><li><strong>需要在屏幕上看到的内容则应使用RGB</strong></li></ul></li></ul><h4 id="第八章：「创建包装或品牌」"><a href="#第八章：「创建包装或品牌」" class="headerlink" title="第八章：「创建包装或品牌」"></a>第八章：「创建包装或品牌」</h4><ul><li>创建包装或品牌<ul><li>必须有某个标识性图像或某种标识性风格。</li></ul></li><li>企业名片</li><li>信笺和信封</li><li>传单</li><li>新闻简报</li><li>宣传册</li><li>明信片</li><li>报纸广告</li><li>简历</li></ul><h3 id="PART2：「字体设计」"><a href="#PART2：「字体设计」" class="headerlink" title="PART2：「字体设计」"></a>PART2：「字体设计」</h3><h4 id="第九章：「字体的基本规则」"><a href="#第九章：「字体的基本规则」" class="headerlink" title="第九章：「字体的基本规则」"></a>第九章：「字体的基本规则」</h4><ul><li>关于英语:标点后面加一个空格。作者是以英文做的示例， 不知道对中文是否适用。 好像不是很适用。 看上去总觉得怪怪的。</li><li>引号<ul><li>印刷引号:“66和99”</li><li>打字机引号:”竖杠引号”</li><li>问号和感叹号如果属于引用的一部分就出现在引号内。</li><li>问号和感叹号如果不属于引用的一部分就出现在引号外。</li></ul></li><li>撇号<ul><li>使用印刷撇号！！！’’’</li><li>省略字母：除了所属性词语之外，撇号意味着省略一个字母如：isn’t Rock’n’Roll，注意是99不是69！</li><li>撇号是9！</li></ul></li><li>连接号<ul><li>连字符<ul><li>odd-looking-critters</li><li>在转行时放在单词的前半部之后，用于断词。</li></ul></li><li>一字线<ul><li>「如何输入」:中文的破折号由两个一字线组成，所以其为破折号的一半，在中文打字法，输入中文的模式下，按下shift+0旁边的键(即连字符)，再删除一次横线，剩下的即为一字线。</li><li>一字线意味着一个持续事件，也可用to代替，前后无空格。例如：7:30—9:30pm</li><li>「宽度」:类似大写字母N的宽度</li></ul></li><li>破折号<ul><li>表示思想的突然变化。</li><li>「宽度」:即中文的破折号，一字线的两倍。</li><li>表意强度:句号&gt;破折号&gt;逗号</li><li>两侧无空格。</li></ul></li></ul></li><li>特殊符号<ul><li>PC上的特殊符号<ul><li>ANSI编码:alt+数字键</li><li>重音符号:alt+数字键</li></ul></li><li>MAC上的特殊符号<ul><li>shift/option+字符</li></ul></li></ul></li><li>大写字母<ul><li>全部大写比全部小写难以阅读，因为大写字母没有轮廓形状变化。</li></ul></li><li>下划线<ul><li>永远不要使用。</li><li>代替：<strong>粗体字</strong>、大号字、不同的字体、颜色。</li></ul></li><li>字距调整<ul><li>「字距调整」:挪动字符间距.</li><li>通常值针对与英语，因为字符键可能存在较大缝隙。</li></ul></li><li>寡妇和孤儿<ul><li>「寡妇」:一段文字的最后一行字符数少于7个。</li><li>「孤儿」:一段的最后一行由于太长而和其他文字分开，在下一栏或下一页的最上面结束。</li></ul></li><li>其他<ul><li>跟随在有样式的文字后的标点与文字样式一样。</li><li>括号中的标点<ul><li>如果括号中的文字是整个句子的一部分，标点在闭括号外。</li><li>括号内的文字是一个完整的句子，标点在括号内。</li></ul></li><li>段落缩进或段落进空行：二者只可选其一。因为都代表“下文为新的一段”的意思。</li><li>首段:不一定需要缩进。</li><li>方框内的文字:尽量在放扩四周留够空间，不要太挤。</li><li>在列表中使用项目符号或装饰符号，而不是连字符。</li></ul></li></ul><h4 id="第十章：「字体（与人生）」"><a href="#第十章：「字体（与人生）」" class="headerlink" title="第十章：「字体（与人生）」"></a>第十章：「字体（与人生）」</h4><ul><li>协调与冲突<ul><li>「协调」:只使用一个字体系列，样式、大小、字体粗细无变化。</li><li>「冲突」:结合使用多个字体系列，很类似但并不相同。</li><li>「对比」:结合的多种字体和元素彼此之间并不相同。</li><li>协调是一个稳妥有用的概念，但冲突务必要避免。</li><li>字体对比存在6种明确的不同方式:大小、粗细、结构、形状、方向和颜色。</li></ul></li></ul><h4 id="第十一章：「字体类别」"><a href="#第十一章：「字体类别」" class="headerlink" title="第十一章：「字体类别」"></a>第十一章：「字体类别」</h4><ul><li>「OldStyle」 旧式体<ul><li>都有衬线，且小写字母衬线存在角度。</li><li>「粗细过渡」:曲线笔画存在一种从粗到细的变化。</li><li>「适合阅读」</li><li>「对角强调线」:曲线最细部分的一条线。 </li></ul></li><li>「Modern」 现代体<ul><li>都有衬线，衬线水平。</li><li>「剧烈粗细过渡」:曲线笔画存在一种剧烈的从粗到细的变化。</li><li>强调线完全垂直。</li><li>「不适合大量显示正文」</li></ul></li><li>「Slab serif」 粗衬线体<ul><li>都有衬线。</li><li>「几乎不存在粗细过渡」</li><li>适合阅读。尤其是小孩。</li></ul></li><li>「Sans serif」 无衬线体<ul><li>「Sans」:法语“没有”。</li><li>没有衬线。</li><li>「几乎不存在粗细过渡」</li><li>页面中使用或许有奇效。</li></ul></li><li>「Script」 手写体<ul><li>很漂亮。</li><li>花里胡哨。</li><li>但是要少用。</li></ul></li><li>「Decorative」 花体<ul><li>各种奇效。</li></ul></li></ul><h4 id="第十二章：「字体对比」"><a href="#第十二章：「字体对比」" class="headerlink" title="第十二章：「字体对比」"></a>第十二章：「字体对比」</h4><ul><li>对比6要素：<ol><li>大小</li><li>粗细</li><li>结构</li><li>形状</li><li>方向</li><li>颜色</li></ol></li><li>「必须选取两个不同字体类别中的字体」不要把同一个类别中的两个自体放在同一个页面上。</li></ul><h2 id="最后说说"><a href="#最后说说" class="headerlink" title="最后说说"></a>最后说说</h2><p>花了近四个小时的时间整理，要把内容回顾了一遍。</p><p>多少还是有点收获吧，虽然方法笨。</p><p>贵有恒，何必担心收获不够多。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「写给大家看的设计书」</title>
      <link href="/2017/08/07/2019%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<h3 id="本文是读书笔记兼读后感。"><a href="#本文是读书笔记兼读后感。" class="headerlink" title="本文是读书笔记兼读后感。"></a>本文是读书笔记兼读后感。</h3><p>由于经常做PPT和写网页，都涉及到设计。而自己设计出来的东西和自己的预期又相差太大。以后在做前端工作时，万一设计师没有给设计图，或者是针对细节处要自由发挥，没有一个好的欣赏和设计水平，设计出的东西奇丑无比，简直罪恶。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Attribute和property的区别</title>
      <link href="/2017/08/01/Attribute%E2%80%98n&#39;property/"/>
      <content type="html"><![CDATA[<p>阅读提示：</p><ol><li>本篇文章中的attribute，全部翻译为“属性”。而property，全部翻译为“特性”。</li><li>点表示法指js对象通过“.”获取特性，方括号表示法指js对象通过“[]”获取特性。</li></ol><a id="more"></a><h2 id="抛砖"><a href="#抛砖" class="headerlink" title="抛砖"></a>抛砖</h2><p>前段时间，有位学长问了我一个题目：在html文档中，给一个标签添加了一个属性，但是js通过点表示法无法对其进行引用。这是为什么？</p><p>当时我是脸上是大写的“懵”字。于是乎写了段代码进行尝试，如图：<br><img src="http://opqksc9nz.bkt.clouddn.com/attribute1.png" alt="啊图片"><br><img src="http://opqksc9nz.bkt.clouddn.com/attribute2.png" alt="啊图片"><br><img src="http://opqksc9nz.bkt.clouddn.com/attribute3.png" alt="啊图片"></p><p>点击标题后，并没有返回value的值，而是undefined。结果很是出人意料。<br>再做一次实验，这回获取的是DOM对象的id，代码及结果如下</p><p><img src="http://opqksc9nz.bkt.clouddn.com/attribute4.png" alt="啊图片"><br><img src="http://opqksc9nz.bkt.clouddn.com/attribute5.png" alt="啊图片"><br><img src="http://opqksc9nz.bkt.clouddn.com/attribute6.png" alt="啊图片"></p><p>对比两次的结果，是不是感觉非常奇怪？</p><h2 id="引玉"><a href="#引玉" class="headerlink" title="引玉"></a>引玉</h2><p>关系到点表示法、括号表示法与”getAttribute”和”Attribute”与”Property”的区别了。</p><p>首先，为什么取不到value属性的值呢？</p><p>在入门的时候，我们应该都学过这两种操作方式，对一个对象用点表示法或方括号表示法，表示获取该对象的属性。对象的getAttribute方法，也可获取对象的属性。但是，此属性非彼属性，一个是Attribute，另一个是property。</p><p>那么，为什么给”&lt;\h3&gt;”标签设置的value，只添加了Attributes中value的值呢？</p><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>打开我们的神器——开发人员工具，选择</p><h3>的DOM节点后，在Elements选项卡下找到Properties，如图：<p></p><p><img src="http://opqksc9nz.bkt.clouddn.com/attribute7.png" alt="啊图片"></p><p>仔细观察上边的键值对，是不是有一个叫做attributes的键？</p><p><img src="http://opqksc9nz.bkt.clouddn.com/attribute8.png" alt="啊图片"></p><p>而我们的id、value都在里边有所显示。继续展开0:id、1:value来一探究竟。</p><p><img src="http://opqksc9nz.bkt.clouddn.com/attribute9.png" alt="啊图片"></p><p><img src="http://opqksc9nz.bkt.clouddn.com/attribute10.png" alt="啊图片"></p><p>可以发现，二者展开后都具有nodeValue字段，并且他们的值为html标签中的属性值。</p><p>但是在properties中，我们可以找到名为id的键，且其绑定值为myHeader，而无法找到名叫value的键。可见，我们在html标签中声明的id，同时存在于property和attribute中，而value只在attribute中具有。</p><p>之所以会出现“抛砖”中的现象，是因为点表示法和方括号表示法，获取到的是对象的property，而getAttribute方法获取的是对象的Attributes。</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><h4 id="Question"><a href="#Question" class="headerlink" title="Question:"></a>Question:</h4><p>为什么在html标签中声明的不同属性，一个存在于对象的property，而另一个在对象的property和attribute中都存在呢？</p><h4 id="Answer"><a href="#Answer" class="headerlink" title="Answer:"></a>Answer:</h4><p>区分以下几种情况：</p><ol><li>在html标签申明属性。<ol><li>若该属性在对象的property中存在，properties和attributes二者都可能会更新（若有特殊限制，如dir，对于值的格式有要求，则有可能在property中不会更新）</li><li>若属性不存在对象的property中，则只会在attributes中刷新。</li></ol></li><li>通过js添加属性<ol><li>如果是通过使用点表示法和方括号表示法添加属性，则只会在properties中添加，而不会在attributes中添加。<br><img src="http://opqksc9nz.bkt.clouddn.com/attribute11.png" alt="啊图片"></li><li>同理，通过对对象使用setAttributes方法添加属性，则会在对象的attributes中添加该属性，在对象的property有可能添加该属性（若该属性之前存在于property中，且对该属性的值如果有特殊要求，本次赋值对其满足，则可添加）。</li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>让我们再来回顾一下本篇文章中所涉及的知识点：</p><ol><li>对象使用点表示法和括号表示法与使用“getAttribute()”方法有何不同。</li><li>如何通过js或开发人员工具查看对象的properties和attributes。</li><li>如何通过js对对象的property和attribute进行设置。</li></ol></h3>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> attribute </tag>
            
            <tag> property </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ss搭建教程及各平台连接方案</title>
      <link href="/2017/07/16/vps-%E5%8D%9A%E5%AE%A2pop/"/>
      <content type="html"><![CDATA[<p>想要自己用vps搭建ss服务，怎么买服务器？怎么搭建？搭建好了怎么用？答案就在这篇文章里呐~若在实操过程中出现问题，欢迎留言或是发邮箱给博主~「封面图来自：《飞行家》，2004，莱昂纳多主演」</p><a id="more"></a><ol><li><a href="#buy">购买vps</a></li><li><a href="#build">搭建ss服务</a></li><li><a href="#mulit-user">添加多用户</a></li><li><a href="#use-windows">windows下使用ss</a></li><li><a href="#use-android">android下使用ss</a></li><li><a href="#use-ubuntu">ubuntu下使用ss</a></li><li><a href="#use-ios">ios系统下使用ss</a></li><li><a href="#use-ssh">小白：如何连接到远程服务器？</a></li><li><a href="#optimization">网速太慢，有没有优化方案？</a></li></ol><h3 id="购买vps"><a href="#购买vps" class="headerlink" title="购买vps"></a><div id="buy">购买vps</div></h3><p>在<a href="https://bwh1.net/index.php" target="_blank" rel="noopener">BandwagonHOST</a>购买vps。<br>可使用支付宝付款，记得使用优惠码：IAMSMART5TDT48。</p><p>本人买的19.99刀每年，没错，几乎就是最便宜的那一款（好像有9.9刀一年的？反正买不到..）。</p><p>配置虽低，但使用体验非常顺滑。google一下、流畅看油管1080p视频完全没有问题。</p><h3 id="搭建ss服务"><a href="#搭建ss服务" class="headerlink" title="搭建ss服务"></a><div id="build">搭建ss服务</div></h3><p>官方可以支持一键安装ss，大家在kiwiVM控制面板可以找到。<br>想要动手的同学可以使用这个<a href="https://github.com/ziggear/shadowsocks" target="_blank" rel="noopener">github库</a>，自行安装，仓库的readme文档里详细介绍了安装过程。博主按照文档成功搭建。</p><h3 id="如何添加多用户？"><a href="#如何添加多用户？" class="headerlink" title="如何添加多用户？"></a><div id="mulit-user">如何添加多用户？</div></h3><p>通过上述repo安装的同学，可以修改配置文件<code>#vim /etc/shadowsocks.json</code>来添加多用户。</p><h3 id="windows下使用ss"><a href="#windows下使用ss" class="headerlink" title="windows下使用ss"></a><div id="use-windiows">windows下使用ss</div></h3><ol><li><a href="http://opqksc9nz.bkt.clouddn.com/Shadowsocks.exe" target="_blank" rel="noopener">下载windows版shadowsocks</a></li><li>配置服务器ip，服务器端口，密码。</li><li>右键shadowsocks图标，在菜单里选择系统代理，PAC模式，即可使用。</li><li>若仍无法使用可将PAC模式切换至GLOBAL(全局)模式。</li></ol><h3 id="android下使用ss"><a href="#android下使用ss" class="headerlink" title="android下使用ss"></a><div id="use-android">android下使用ss</div></h3><ol><li><a href="http://opqksc9nz.bkt.clouddn.com/ssr-3_4_0_5.apk.1%253B+filename-%253Dutf-8%27+%27ssr-3_4_0_5.apk" target="_blank" rel="noopener">下载SSR</a></li><li>进行相应配置，不再赘述。</li></ol><h3 id="ubuntu下使用ss"><a href="#ubuntu下使用ss" class="headerlink" title="ubuntu下使用ss"></a><div id="use-ubuntu">ubuntu下使用ss</div></h3><ol><li>下载GUI版本<a href="https://github.com/shadowsocks/shadowsocks-qt5" target="_blank" rel="noopener">shadowsocks客户端</a>，并配置相应内容，</li><li>下载chrome浏览器插件SwitchyOmega，进行相应配置.</li></ol><h3 id="ios系统使用SsrConnectPro建立ss连接"><a href="#ios系统使用SsrConnectPro建立ss连接" class="headerlink" title="ios系统使用SsrConnectPro建立ss连接"></a><div id="use-ios">ios系统使用SsrConnectPro建立ss连接</div></h3><p>app主界面如下：<br><img src="http://opqksc9nz.bkt.clouddn.com/SsrConnectPro.png" alt="SsrConnectPro主界面"><br>配置界面如下：<br><img src="http://opqksc9nz.bkt.clouddn.com/SsrConnectPro%20%282%29.png" alt="SsrConnectPro配置界面"></p><p>使用步骤：</p><ol><li>在app store内下载SsrConnectPro</li><li>打开应用,选择右上角的”+”号,添加服务器配置</li><li>TYPE(类型),选择SS</li><li>NAME(名称):只是用来区分你所添加的不同的服务器的,起一个你喜欢的名字.</li><li>Server(服务器):输入服务器ip</li><li>Porty(端口):输入远程服务器的端口号.</li><li>Password(密码):输入远程服务器端口所对应的密码.</li><li>ProxyMethod(代理模式):选择System(系统)或Global(全局)代理模式.(我用的是系统)</li><li>Method(加密方式):提供商给你的配置里肯定有,一定要选择正确.</li><li>点击 Save Configuration(保存配置)</li><li>点击connect,即可愉快的番蔷学习.</li></ol><p>ps：第一次配置完毕以后，可在ios设备的系统设置，选择“vpn”选项进行打开或关闭ss连接。非常方便。</p><h3 id="小白：如何连接到远程服务器？"><a href="#小白：如何连接到远程服务器？" class="headerlink" title="小白：如何连接到远程服务器？"></a><div id="use-ssh">小白：如何连接到远程服务器？</div></h3><h4 id="解决方案1：提供商提供的的云服务器控制面板"><a href="#解决方案1：提供商提供的的云服务器控制面板" class="headerlink" title="解决方案1：提供商提供的的云服务器控制面板"></a>解决方案1：提供商提供的的云服务器控制面板</h4><p>云服务器提供商一般会提供web端的远程连接方案，比如搬瓦工的kiwivm面板、腾讯云的控制台。<br>它们给用户提供了一个可以在官网操作云服务器的方法，优点是简单易懂，缺点是过于麻烦，每次登陆服务器都要登陆到云服务提供商的网站，非常不方便。<br>建议大家花点时间，学习以下的配置方案，这样在使用电脑、手机的时候都可以方便的连接到自己的服务器上。</p><h4 id="解决方案2：使用ssh连接远程服务器"><a href="#解决方案2：使用ssh连接远程服务器" class="headerlink" title="解决方案2：使用ssh连接远程服务器"></a>解决方案2：使用ssh连接远程服务器</h4><p>分为三个平台：<a href="#user-windows">windows</a>,<a href="#user-android">android</a>,<a href="#user-ubuntu">ubuntu(linux)</a><br>所需已知条件：</p><ol><li>远程服务器的ip</li><li>远程服务器上ssh服务开放的端口号</li><li>远程服务器系统上的用户名称</li><li>该用户对应的密码。</li></ol><h4 id="windows连接vps"><a href="#windows连接vps" class="headerlink" title="windows连接vps"></a><div id="user-windows">windows连接vps</div></h4><ol><li>下载xshell 5.<br><a href="http://www.netsarang.com/download/down_form.html?code=522&amp;downloadType=0&amp;licenseType=1" target="_blank" rel="noopener">下载免费使用的个人/家庭版本</a><br>填写完毕并提交后，会在所填邮箱收到一封包含下载地址的邮件，点入相应链接，即可进行下载。</li><li>下载完毕后打开应用，点击左上角的new，添加会话。</li><li>填写配置信息。<ul><li>Name(会话的名称，用来区分其他会话，取一个自己喜欢的名字即可)</li><li>Host(主机，即所要连接的远程服务器。填写远程服务器ip地址，也可填写域名，必填。)</li><li>Port Number(远程服务器SSH服务使用的端口，必填。)</li><li>在左栏选择Authentication（认证），选择验证模式，为Password。</li><li>User Name(用户名称)，即填写远程服务器上的一个用户的名称。</li><li>Password(密码)，即填写该用户所对应的密码。</li></ul></li><li>点击OK进行保存</li><li>之后返回程序的主界面，双击会话即可登陆远程服务器。</li></ol><h4 id="Android手机连接vps"><a href="#Android手机连接vps" class="headerlink" title="Android手机连接vps"></a><div id="user-android">Android手机连接vps</div></h4><ol><li><a href="http://opqksc9nz.bkt.clouddn.com/com.sonelli.juicessh.apk" target="_blank" rel="noopener">下载JuiceSSH</a></li><li>进行配置。请同学自己摸索吧。重要的仍然是那四个已知条件，配置正确后即可连接。</li></ol><h4 id="ubuntu连接vps"><a href="#ubuntu连接vps" class="headerlink" title="ubuntu连接vps"></a><div id="user-ubuntu">ubuntu连接vps</div></h4><p>仅介绍一条命令,基本可以通吃.</p><p><code>sudo ssh -p port_number user_name@xxx.xxx.xxx.xxx</code></p><p>sudo: 使用root权限运行<br>-p: 指定端口选项.<br>port_number: 该位置填写指定的端口号<br>user_name: 用户名称<br>xxx.xxx.xxx.xxx: 该位置填写远程服务器的ip</p><h4 id="网速太慢，有没有优化方案？"><a href="#网速太慢，有没有优化方案？" class="headerlink" title="网速太慢，有没有优化方案？"></a><div id="optimization">网速太慢，有没有优化方案？</div></h4><ol><li>使用google bbr拥塞控制。<a href="http://www.bandwagonhost.net/1082.html" target="_blank" rel="noopener">参考他人教程</a>（亲测成功，速度提升3-4倍）</li></ol>]]></content>
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vps </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《HTTP下午茶》</title>
      <link href="/2017/06/14/http_afternoon_tea/"/>
      <content type="html"><![CDATA[<p>于2017年6月14日读过此书。</p><p>入门小书，书中并未教人如何编写代码，而是进行概念讲解。全书通俗易读，辅以插图食用口味更佳。</p><a id="more"></a><p>传送门：<a href="https://www.kancloud.cn/kancloud/tealeaf-http/43837" target="_blank" rel="noopener">https://www.kancloud.cn/kancloud/tealeaf-http/43837</a></p><p>书里简要介绍了如下内容：</p><ul><li>如何通过网址如何上网<ul><li>DNS</li><li>客户端和服务器。</li></ul></li><li>无状态协议</li><li>URL</li><li>抓包工具</li><li>HTTP请求<ul><li>get请求</li><li>post请求</li><li>HTTP状态码</li></ul></li><li>如何构建有状态的web应用<ul><li>session</li><li>cookies</li><li>ajax</li></ul></li><li>WEB安全<ul><li>HTTPS</li><li>同源策略</li><li>会话劫持</li><li>XSS攻击（会话劫持的对策）</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态选项卡title及图标</title>
      <link href="/2017/05/24/title-icon/"/>
      <content type="html"><![CDATA[<p>很久之前在一个人的博客上，看到了一个很有意思的效果——当我在他的页面浏览时，选项卡图标和title是一个模样，当我离开他的页面以后，他的博客所在选项卡图标又变成了另一幅模样。当时感觉非常有趣，但没有花时间去考虑如何实现。</p><a id="more"></a><p>最近读《JavaScript高级程序设计》第十三章事件时，看到了unload事件。在书中对其的介绍如下：<br>     与load事件对应的是unload事件，这个事件在文档完全被卸载后触发。只要用户从一个页面转换到另一个页面，就会发生onunload事件。</p><p>首先映入脑海的是使用onunload来实现切换选项卡时，选项卡的图标和title进行变换的效果。首先要学习一下onunload事件。</p><hr><h4 id="第一次尝试："><a href="#第一次尝试：" class="headerlink" title="第一次尝试："></a>第一次尝试：</h4><p>测试onunload方法：<br>test2.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;     </span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;onunload事件&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body onunload=&quot;alert(&apos;Unloaded！&apos;)&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>在chrome浏览器中，关闭test2.html文档或者切换该选项卡，onunload未起作用。</p><p><img src="http://opqksc9nz.bkt.clouddn.com/chromef123.png" alt="啊图片"></p><p>首先，高程上的意思有点磨棱两可。在网上一通谷歌后才明白，“文档完全被卸载”，“用户从一个页面转换到另一个页面”实际是关掉选项卡再进行的切换。实在是坑啊，看来我们方向找错了。<br>其次，我们来探究一下onunload为何未起作用。在onunload位置打上断点。并将右侧的pause on exceptions打开。如上图所示。这里有一个小知识点。</p><p>通过调试，在第五次调试时推出该页面，并提示错误信息“Blocked alert(‘Unloaded！’) during unload.”前四次中，前两步为渲染过程，后两步为网页卸载过程，但是仍不知为何会抛出这个错误，还请大神指点迷津。</p><hr><h4 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h4><p>搜索一番，更正思路，以下是实现代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;被发现啦(*´∇｀*)&lt;/title&gt;</span><br><span class="line">    &lt;link href=&quot;../img/1.ico&quot;  rel=&quot;icon&quot; type=&quot;image/vnd.microsoft.icon&quot;/&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    //浏览器选项卡变换</span><br><span class="line">    //判断hidden属性是否存在于document属性中。</span><br><span class="line">    var hiddenProperty = &apos;hidden&apos; in document ? &apos;hidden&apos; :</span><br><span class="line">        &apos;webkitHidden&apos; in document ? &apos;webkitHidden&apos; :</span><br><span class="line">            &apos;mozHidden&apos; in document ? &apos;mozHidden&apos; :</span><br><span class="line">                null;</span><br><span class="line">    //用于在字符串中用字符串替代指定字符。第一个参数为原字符串中被替换字符串的正则表达式，第二个参数为用于替换的文本或字符串。</span><br><span class="line">    var visibilityChangeEvent = hiddenProperty.replace(/hidden/i, &apos;visibilitychange&apos;);</span><br><span class="line">    //构造匿名函数，为更换标签页状态事件所要执行的函数。</span><br><span class="line">    var onVisibilityChange = function()&#123;</span><br><span class="line">        //获取link元素</span><br><span class="line">        var links = document.head.getElementsByTagName(&quot;link&quot;);</span><br><span class="line">        if (!document[hiddenProperty]) &#123;</span><br><span class="line">            document.title=&apos;被发现啦(*´∇｀*)&apos;;</span><br><span class="line">            links[0].href = &quot;../img/1.ico&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            document.title=&apos;藏好啦(つд⊂)&apos;;</span><br><span class="line">            links[0].href=&quot;../img/2.ico&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    //用于向指定元素添加事件句柄，第一个参数为事件名，第二个参数为指定要事件触发时执行的函数。</span><br><span class="line">    document.addEventListener(visibilityChangeEvent, onVisibilityChange);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>有几点需要注意。<br>变量hiddenProperty获取的是当前浏览器的hidden属性，使用了三个三元运算符来保证其兼容性。通过replace替换成为visibilitychange+属性名中除hidden外字符串。在这里要着重注意一下visibilitychange这个事件，在我们的这个效果中起到了关键的作用。<br>通过dom获取link标签。更改title和href。<br>为元素添加事件句柄使用addEventListener()函数。<br>最后我们可以发现，实现这个效果，真的是，相当，相当简单。</p><hr><h4 id="小知识点1：关于chrome的调试"><a href="#小知识点1：关于chrome的调试" class="headerlink" title="小知识点1：关于chrome的调试"></a>小知识点1：关于chrome的调试</h4><p>在界面下方能看到按钮，它是设置程序运行时遇到异常时是否中断的开关。点击该按钮会在3种状态间切换：<br><img src="http://opqksc9nz.bkt.clouddn.com/all_catch.png" alt="all_catch"> 遇到所有异常都会中断，包括已捕获的情况。（两条白色竖杠包含在蓝色八边形中<br><img src="http://opqksc9nz.bkt.clouddn.com/some_catch.png" alt="some_catch"> 仅在出现未捕获的异常时才中断。（两条白色竖杠包含在紫色八边形中 ）<br><img src="http://opqksc9nz.bkt.clouddn.com/no_catch.png" alt="no_catch"> 默认遇到异常不中断。（两条白色竖杠包含在黑色八边形中）</p><h4 id="小知识点2：visibilitychange事件"><a href="#小知识点2：visibilitychange事件" class="headerlink" title="小知识点2：visibilitychange事件"></a>小知识点2：visibilitychange事件</h4><p>浏览器标签页被隐藏或显示的时候会触发visibilitychange事件.<br>示例程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&quot;visibilitychange&quot;, function() &#123;</span><br><span class="line">  console.log( document.visibilityState );&#125;);</span><br></pre></td></tr></table></figure><p>该事件具有四个属性：</p><ul><li>target属性：事件的目标。</li><li>type属性：被触发的事件的类型。</li><li>bubbles：表明事件是否冒泡。</li><li>cancelable：表明是否可以取消事件的默认行为。</li></ul><h4 id="另外附上一对选项卡图标"><a href="#另外附上一对选项卡图标" class="headerlink" title="另外附上一对选项卡图标"></a>另外附上一对选项卡图标</h4><p>觉得这一对相当有趣，怎么用就看客官自由发挥了。<br><img src="http://opqksc9nz.bkt.clouddn.com/1.ico" alt="1"><br><img src="http://opqksc9nz.bkt.clouddn.com/2.ico" alt="2"></p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 选项卡 </tag>
            
            <tag> title </tag>
            
            <tag> 图标 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <content type="html"><![CDATA[<p>准备考研。</p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>email<br><a href="mailto:zhanghao@xiyouant.org" target="_blank" rel="noopener">zhanghao@xiyouant.org</a></li></ul>]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
